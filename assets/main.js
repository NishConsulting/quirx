!function(n){function e(r){if(t[r])return t[r].exports;var a=t[r]={exports:{},id:r,loaded:!1};return n[r].call(a.exports,a,a.exports,e),a.loaded=!0,a.exports}var t={};return e.m=n,e.c=t,e.p="/assets/",e(0)}([/*!******************!*\
  !*** multi main ***!
  \******************/
function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(/*! ./src/index.jsx */100);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** multi main\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///multi_main?")},/*!**********************************!*\
  !*** ./~/react/lib/invariant.js ***!
  \**********************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule invariant\n */\n\n\"use strict\";\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (false) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        'Invariant Violation: ' +\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/invariant.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/invariant.js?")},/*!**************************************!*\
  !*** ./~/react/lib/Object.assign.js ***!
  \**************************************/
function(module,exports){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Object.assign\n */\n\n// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign\n\n'use strict';\n\nfunction assign(target, sources) {\n  if (target == null) {\n    throw new TypeError('Object.assign target cannot be null or undefined');\n  }\n\n  var to = Object(target);\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {\n    var nextSource = arguments[nextIndex];\n    if (nextSource == null) {\n      continue;\n    }\n\n    var from = Object(nextSource);\n\n    // We don't currently support accessors nor proxies. Therefore this\n    // copy cannot throw. If we ever supported this then we must handle\n    // exceptions and side-effects. We don't support symbols so they won't\n    // be transferred.\n\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n  }\n\n  return to;\n}\n\nmodule.exports = assign;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/Object.assign.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/Object.assign.js?")},/*!********************************!*\
  !*** ./~/react/lib/warning.js ***!
  \********************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule warning\n */\n\n\"use strict\";\n\nvar emptyFunction = __webpack_require__(/*! ./emptyFunction */ 10);\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction;\n\nif (false) {\n  warning = function(condition, format ) {for (var args=[],$__0=2,$__1=arguments.length;$__0<$__1;$__0++) args.push(arguments[$__0]);\n    if (format === undefined) {\n      throw new Error(\n        '`warning(condition, format, ...args)` requires a warning ' +\n        'message argument'\n      );\n    }\n\n    if (format.length < 10 || /^[s\\W]*$/.test(format)) {\n      throw new Error(\n        'The warning format should be able to uniquely identify this ' +\n        'warning. Please, use a more descriptive format than: ' + format\n      );\n    }\n\n    if (format.indexOf('Failed Composite propType: ') === 0) {\n      return; // Ignore CompositeComponent proptype check.\n    }\n\n    if (!condition) {\n      var argIndex = 0;\n      var message = 'Warning: ' + format.replace(/%s/g, function()  {return args[argIndex++];});\n      console.warn(message);\n      try {\n        // --- Welcome to debugging React ---\n        // This error was thrown as a convenience so that you can use this stack\n        // to find the callsite that caused this warning to fire.\n        throw new Error(message);\n      } catch(x) {}\n    }\n  };\n}\n\nmodule.exports = warning;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/warning.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/warning.js?")},/*!*************************************!*\
  !*** ./~/react/lib/ReactElement.js ***!
  \*************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactElement\n */\n\n'use strict';\n\nvar ReactContext = __webpack_require__(/*! ./ReactContext */ 51);\nvar ReactCurrentOwner = __webpack_require__(/*! ./ReactCurrentOwner */ 14);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true\n};\n\n/**\n * Warn for mutations.\n *\n * @internal\n * @param {object} object\n * @param {string} key\n */\nfunction defineWarningProperty(object, key) {\n  Object.defineProperty(object, key, {\n\n    configurable: false,\n    enumerable: true,\n\n    get: function() {\n      if (!this._store) {\n        return null;\n      }\n      return this._store[key];\n    },\n\n    set: function(value) {\n      (false ? warning(\n        false,\n        'Don\\'t set the %s property of the React element. Instead, ' +\n        'specify the correct value when initially creating the element.',\n        key\n      ) : null);\n      this._store[key] = value;\n    }\n\n  });\n}\n\n/**\n * This is updated to true if the membrane is successfully created.\n */\nvar useMutationMembrane = false;\n\n/**\n * Warn for mutations.\n *\n * @internal\n * @param {object} element\n */\nfunction defineMutationMembrane(prototype) {\n  try {\n    var pseudoFrozenProperties = {\n      props: true\n    };\n    for (var key in pseudoFrozenProperties) {\n      defineWarningProperty(prototype, key);\n    }\n    useMutationMembrane = true;\n  } catch (x) {\n    // IE will fail on defineProperty\n  }\n}\n\n/**\n * Base constructor for all React elements. This is only used to make this\n * work with a dynamic instanceof check. Nothing should live on this prototype.\n *\n * @param {*} type\n * @param {string|object} ref\n * @param {*} key\n * @param {*} props\n * @internal\n */\nvar ReactElement = function(type, key, ref, owner, context, props) {\n  // Built-in properties that belong on the element\n  this.type = type;\n  this.key = key;\n  this.ref = ref;\n\n  // Record the component responsible for creating this element.\n  this._owner = owner;\n\n  // TODO: Deprecate withContext, and then the context becomes accessible\n  // through the owner.\n  this._context = context;\n\n  if (false) {\n    // The validation flag and props are currently mutative. We put them on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    this._store = {props: props, originalProps: assign({}, props)};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    try {\n      Object.defineProperty(this._store, 'validated', {\n        configurable: false,\n        enumerable: false,\n        writable: true\n      });\n    } catch (x) {\n    }\n    this._store.validated = false;\n\n    // We're not allowed to set props directly on the object so we early\n    // return and rely on the prototype membrane to forward to the backing\n    // store.\n    if (useMutationMembrane) {\n      Object.freeze(this);\n      return;\n    }\n  }\n\n  this.props = props;\n};\n\n// We intentionally don't expose the function on the constructor property.\n// ReactElement should be indistinguishable from a plain object.\nReactElement.prototype = {\n  _isReactElement: true\n};\n\nif (false) {\n  defineMutationMembrane(ReactElement.prototype);\n}\n\nReactElement.createElement = function(type, config, children) {\n  var propName;\n\n  // Reserved names are extracted\n  var props = {};\n\n  var key = null;\n  var ref = null;\n\n  if (config != null) {\n    ref = config.ref === undefined ? null : config.ref;\n    key = config.key === undefined ? null : '' + config.key;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (config.hasOwnProperty(propName) &&\n          !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (typeof props[propName] === 'undefined') {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  return new ReactElement(\n    type,\n    key,\n    ref,\n    ReactCurrentOwner.current,\n    ReactContext.current,\n    props\n  );\n};\n\nReactElement.createFactory = function(type) {\n  var factory = ReactElement.createElement.bind(null, type);\n  // Expose the type on the factory and the prototype so that it can be\n  // easily accessed on elements. E.g. <Foo />.type === Foo.type.\n  // This should not be named `constructor` since this may not be the function\n  // that created the element, and it may not even be a constructor.\n  // Legacy hook TODO: Warn if this is accessed\n  factory.type = type;\n  return factory;\n};\n\nReactElement.cloneAndReplaceProps = function(oldElement, newProps) {\n  var newElement = new ReactElement(\n    oldElement.type,\n    oldElement.key,\n    oldElement.ref,\n    oldElement._owner,\n    oldElement._context,\n    newProps\n  );\n\n  if (false) {\n    // If the key on the original is valid, then the clone is valid\n    newElement._store.validated = oldElement._store.validated;\n  }\n  return newElement;\n};\n\nReactElement.cloneElement = function(element, config, children) {\n  var propName;\n\n  // Original props are copied\n  var props = assign({}, element.props);\n\n  // Reserved names are extracted\n  var key = element.key;\n  var ref = element.ref;\n\n  // Owner will be preserved, unless ref is overridden\n  var owner = element._owner;\n\n  if (config != null) {\n    if (config.ref !== undefined) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n    if (config.key !== undefined) {\n      key = '' + config.key;\n    }\n    // Remaining properties override existing props\n    for (propName in config) {\n      if (config.hasOwnProperty(propName) &&\n          !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  return new ReactElement(\n    element.type,\n    key,\n    ref,\n    owner,\n    element._context,\n    props\n  );\n};\n\n/**\n * @param {?object} object\n * @return {boolean} True if `object` is a valid component.\n * @final\n */\nReactElement.isValidElement = function(object) {\n  // ReactTestUtils is often used outside of beforeEach where as React is\n  // within it. This leads to two different instances of React on the same\n  // page. To identify a element from a different React instance we use\n  // a flag instead of an instanceof check.\n  var isElement = !!(object && object._isReactElement);\n  // if (isElement && !(object instanceof ReactElement)) {\n  // This is an indicator that you're using multiple versions of React at the\n  // same time. This will screw with ownership and stuff. Fix it, please.\n  // TODO: We could possibly warn here.\n  // }\n  return isElement;\n};\n\nmodule.exports = ReactElement;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactElement.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactElement.js?")},/*!********************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.js ***!
  \********************************************************/
function(module,exports,__webpack_require__){eval("'use strict';\nvar global = typeof self != 'undefined' ? self : Function('return this')()\n  , core   = {}\n  , defineProperty = Object.defineProperty\n  , hasOwnProperty = {}.hasOwnProperty\n  , ceil  = Math.ceil\n  , floor = Math.floor\n  , max   = Math.max\n  , min   = Math.min;\n// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.\nvar DESC = !!function(){\n  try {\n    return defineProperty({}, 'a', {get: function(){ return 2; }}).a == 2;\n  } catch(e){ /* empty */ }\n}();\nvar hide = createDefiner(1);\n// 7.1.4 ToInteger\nfunction toInteger(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n}\nfunction desc(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n}\nfunction simpleSet(object, key, value){\n  object[key] = value;\n  return object;\n}\nfunction createDefiner(bitmap){\n  return DESC ? function(object, key, value){\n    return $.setDesc(object, key, desc(bitmap, value));\n  } : simpleSet;\n}\n\nfunction isObject(it){\n  return it !== null && (typeof it == 'object' || typeof it == 'function');\n}\nfunction isFunction(it){\n  return typeof it == 'function';\n}\nfunction assertDefined(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n}\n\nvar $ = module.exports = __webpack_require__(/*! ./$.fw */ 105)({\n  g: global,\n  core: core,\n  html: global.document && document.documentElement,\n  // http://jsperf.com/core-js-isobject\n  isObject:   isObject,\n  isFunction: isFunction,\n  that: function(){\n    return this;\n  },\n  // 7.1.4 ToInteger\n  toInteger: toInteger,\n  // 7.1.15 ToLength\n  toLength: function(it){\n    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n  },\n  toIndex: function(index, length){\n    index = toInteger(index);\n    return index < 0 ? max(index + length, 0) : min(index, length);\n  },\n  has: function(it, key){\n    return hasOwnProperty.call(it, key);\n  },\n  create:     Object.create,\n  getProto:   Object.getPrototypeOf,\n  DESC:       DESC,\n  desc:       desc,\n  getDesc:    Object.getOwnPropertyDescriptor,\n  setDesc:    defineProperty,\n  setDescs:   Object.defineProperties,\n  getKeys:    Object.keys,\n  getNames:   Object.getOwnPropertyNames,\n  getSymbols: Object.getOwnPropertySymbols,\n  assertDefined: assertDefined,\n  // Dummy, fix for not array-like ES3 string in es5 module\n  ES5Object: Object,\n  toObject: function(it){\n    return $.ES5Object(assertDefined(it));\n  },\n  hide: hide,\n  def: createDefiner(0),\n  set: global.Symbol ? simpleSet : hide,\n  each: [].forEach\n});\n/* eslint-disable no-undef */\nif(typeof __e != 'undefined')__e = core;\nif(typeof __g != 'undefined')__g = global;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.js?")},/*!*********************************************!*\
  !*** ./~/react/lib/ExecutionEnvironment.js ***!
  \*********************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ExecutionEnvironment\n */\n\n/*jslint evil: true */\n\n\"use strict\";\n\nvar canUseDOM = !!(\n  (typeof window !== 'undefined' &&\n  window.document && window.document.createElement)\n);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners:\n    canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\n\nmodule.exports = ExecutionEnvironment;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ExecutionEnvironment.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ExecutionEnvironment.js?")},/*!***************************************!*\
  !*** ./~/react/lib/EventConstants.js ***!
  \***************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventConstants\n */\n\n'use strict';\n\nvar keyMirror = __webpack_require__(/*! ./keyMirror */ 34);\n\nvar PropagationPhases = keyMirror({bubbled: null, captured: null});\n\n/**\n * Types of raw signals from the browser caught at the top level.\n */\nvar topLevelTypes = keyMirror({\n  topBlur: null,\n  topChange: null,\n  topClick: null,\n  topCompositionEnd: null,\n  topCompositionStart: null,\n  topCompositionUpdate: null,\n  topContextMenu: null,\n  topCopy: null,\n  topCut: null,\n  topDoubleClick: null,\n  topDrag: null,\n  topDragEnd: null,\n  topDragEnter: null,\n  topDragExit: null,\n  topDragLeave: null,\n  topDragOver: null,\n  topDragStart: null,\n  topDrop: null,\n  topError: null,\n  topFocus: null,\n  topInput: null,\n  topKeyDown: null,\n  topKeyPress: null,\n  topKeyUp: null,\n  topLoad: null,\n  topMouseDown: null,\n  topMouseMove: null,\n  topMouseOut: null,\n  topMouseOver: null,\n  topMouseUp: null,\n  topPaste: null,\n  topReset: null,\n  topScroll: null,\n  topSelectionChange: null,\n  topSubmit: null,\n  topTextInput: null,\n  topTouchCancel: null,\n  topTouchEnd: null,\n  topTouchMove: null,\n  topTouchStart: null,\n  topWheel: null\n});\n\nvar EventConstants = {\n  topLevelTypes: topLevelTypes,\n  PropagationPhases: PropagationPhases\n};\n\nmodule.exports = EventConstants;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EventConstants.js\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EventConstants.js?")},/*!***********************************!*\
  !*** ./~/react/lib/ReactClass.js ***!
  \***********************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactClass\n */\n\n'use strict';\n\nvar ReactComponent = __webpack_require__(/*! ./ReactComponent */ 75);\nvar ReactCurrentOwner = __webpack_require__(/*! ./ReactCurrentOwner */ 14);\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\nvar ReactErrorUtils = __webpack_require__(/*! ./ReactErrorUtils */ 153);\nvar ReactInstanceMap = __webpack_require__(/*! ./ReactInstanceMap */ 24);\nvar ReactLifeCycle = __webpack_require__(/*! ./ReactLifeCycle */ 54);\nvar ReactPropTypeLocations = __webpack_require__(/*! ./ReactPropTypeLocations */ 55);\nvar ReactPropTypeLocationNames = __webpack_require__(/*! ./ReactPropTypeLocationNames */ 39);\nvar ReactUpdateQueue = __webpack_require__(/*! ./ReactUpdateQueue */ 56);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\nvar keyMirror = __webpack_require__(/*! ./keyMirror */ 34);\nvar keyOf = __webpack_require__(/*! ./keyOf */ 11);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nvar MIXINS_KEY = keyOf({mixins: null});\n\n/**\n * Policies that describe methods in `ReactClassInterface`.\n */\nvar SpecPolicy = keyMirror({\n  /**\n   * These methods may be defined only once by the class specification or mixin.\n   */\n  DEFINE_ONCE: null,\n  /**\n   * These methods may be defined by both the class specification and mixins.\n   * Subsequent definitions will be chained. These methods must return void.\n   */\n  DEFINE_MANY: null,\n  /**\n   * These methods are overriding the base class.\n   */\n  OVERRIDE_BASE: null,\n  /**\n   * These methods are similar to DEFINE_MANY, except we assume they return\n   * objects. We try to merge the keys of the return values of all the mixed in\n   * functions. If there is a key conflict we throw.\n   */\n  DEFINE_MANY_MERGED: null\n});\n\n\nvar injectedMixins = [];\n\n/**\n * Composite components are higher-level components that compose other composite\n * or native components.\n *\n * To create a new type of `ReactClass`, pass a specification of\n * your new class to `React.createClass`. The only requirement of your class\n * specification is that you implement a `render` method.\n *\n *   var MyComponent = React.createClass({\n *     render: function() {\n *       return <div>Hello World</div>;\n *     }\n *   });\n *\n * The class specification supports a specific protocol of methods that have\n * special meaning (e.g. `render`). See `ReactClassInterface` for\n * more the comprehensive protocol. Any other properties and methods in the\n * class specification will available on the prototype.\n *\n * @interface ReactClassInterface\n * @internal\n */\nvar ReactClassInterface = {\n\n  /**\n   * An array of Mixin objects to include when defining your component.\n   *\n   * @type {array}\n   * @optional\n   */\n  mixins: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * An object containing properties and methods that should be defined on\n   * the component's constructor instead of its prototype (static methods).\n   *\n   * @type {object}\n   * @optional\n   */\n  statics: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Definition of prop types for this component.\n   *\n   * @type {object}\n   * @optional\n   */\n  propTypes: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Definition of context types for this component.\n   *\n   * @type {object}\n   * @optional\n   */\n  contextTypes: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Definition of context types this component sets for its children.\n   *\n   * @type {object}\n   * @optional\n   */\n  childContextTypes: SpecPolicy.DEFINE_MANY,\n\n  // ==== Definition methods ====\n\n  /**\n   * Invoked when the component is mounted. Values in the mapping will be set on\n   * `this.props` if that prop is not specified (i.e. using an `in` check).\n   *\n   * This method is invoked before `getInitialState` and therefore cannot rely\n   * on `this.state` or use `this.setState`.\n   *\n   * @return {object}\n   * @optional\n   */\n  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,\n\n  /**\n   * Invoked once before the component is mounted. The return value will be used\n   * as the initial value of `this.state`.\n   *\n   *   getInitialState: function() {\n   *     return {\n   *       isOn: false,\n   *       fooBaz: new BazFoo()\n   *     }\n   *   }\n   *\n   * @return {object}\n   * @optional\n   */\n  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,\n\n  /**\n   * @return {object}\n   * @optional\n   */\n  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,\n\n  /**\n   * Uses props from `this.props` and state from `this.state` to render the\n   * structure of the component.\n   *\n   * No guarantees are made about when or how often this method is invoked, so\n   * it must not have side effects.\n   *\n   *   render: function() {\n   *     var name = this.props.name;\n   *     return <div>Hello, {name}!</div>;\n   *   }\n   *\n   * @return {ReactComponent}\n   * @nosideeffects\n   * @required\n   */\n  render: SpecPolicy.DEFINE_ONCE,\n\n\n\n  // ==== Delegate methods ====\n\n  /**\n   * Invoked when the component is initially created and about to be mounted.\n   * This may have side effects, but any external subscriptions or data created\n   * by this method must be cleaned up in `componentWillUnmount`.\n   *\n   * @optional\n   */\n  componentWillMount: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked when the component has been mounted and has a DOM representation.\n   * However, there is no guarantee that the DOM node is in the document.\n   *\n   * Use this as an opportunity to operate on the DOM when the component has\n   * been mounted (initialized and rendered) for the first time.\n   *\n   * @param {DOMElement} rootNode DOM element representing the component.\n   * @optional\n   */\n  componentDidMount: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked before the component receives new props.\n   *\n   * Use this as an opportunity to react to a prop transition by updating the\n   * state using `this.setState`. Current props are accessed via `this.props`.\n   *\n   *   componentWillReceiveProps: function(nextProps, nextContext) {\n   *     this.setState({\n   *       likesIncreasing: nextProps.likeCount > this.props.likeCount\n   *     });\n   *   }\n   *\n   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop\n   * transition may cause a state change, but the opposite is not true. If you\n   * need it, you are probably looking for `componentWillUpdate`.\n   *\n   * @param {object} nextProps\n   * @optional\n   */\n  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked while deciding if the component should be updated as a result of\n   * receiving new props, state and/or context.\n   *\n   * Use this as an opportunity to `return false` when you're certain that the\n   * transition to the new props/state/context will not require a component\n   * update.\n   *\n   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {\n   *     return !equal(nextProps, this.props) ||\n   *       !equal(nextState, this.state) ||\n   *       !equal(nextContext, this.context);\n   *   }\n   *\n   * @param {object} nextProps\n   * @param {?object} nextState\n   * @param {?object} nextContext\n   * @return {boolean} True if the component should update.\n   * @optional\n   */\n  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,\n\n  /**\n   * Invoked when the component is about to update due to a transition from\n   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`\n   * and `nextContext`.\n   *\n   * Use this as an opportunity to perform preparation before an update occurs.\n   *\n   * NOTE: You **cannot** use `this.setState()` in this method.\n   *\n   * @param {object} nextProps\n   * @param {?object} nextState\n   * @param {?object} nextContext\n   * @param {ReactReconcileTransaction} transaction\n   * @optional\n   */\n  componentWillUpdate: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked when the component's DOM representation has been updated.\n   *\n   * Use this as an opportunity to operate on the DOM when the component has\n   * been updated.\n   *\n   * @param {object} prevProps\n   * @param {?object} prevState\n   * @param {?object} prevContext\n   * @param {DOMElement} rootNode DOM element representing the component.\n   * @optional\n   */\n  componentDidUpdate: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked when the component is about to be removed from its parent and have\n   * its DOM representation destroyed.\n   *\n   * Use this as an opportunity to deallocate any external resources.\n   *\n   * NOTE: There is no `componentDidUnmount` since your component will have been\n   * destroyed by that point.\n   *\n   * @optional\n   */\n  componentWillUnmount: SpecPolicy.DEFINE_MANY,\n\n\n\n  // ==== Advanced methods ====\n\n  /**\n   * Updates the component's currently mounted DOM representation.\n   *\n   * By default, this implements React's rendering and reconciliation algorithm.\n   * Sophisticated clients may wish to override this.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   * @overridable\n   */\n  updateComponent: SpecPolicy.OVERRIDE_BASE\n\n};\n\n/**\n * Mapping from class specification keys to special processing functions.\n *\n * Although these are declared like instance properties in the specification\n * when defining classes using `React.createClass`, they are actually static\n * and are accessible on the constructor instead of the prototype. Despite\n * being static, they must be defined outside of the \"statics\" key under\n * which all other static methods are defined.\n */\nvar RESERVED_SPEC_KEYS = {\n  displayName: function(Constructor, displayName) {\n    Constructor.displayName = displayName;\n  },\n  mixins: function(Constructor, mixins) {\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        mixSpecIntoComponent(Constructor, mixins[i]);\n      }\n    }\n  },\n  childContextTypes: function(Constructor, childContextTypes) {\n    if (false) {\n      validateTypeDef(\n        Constructor,\n        childContextTypes,\n        ReactPropTypeLocations.childContext\n      );\n    }\n    Constructor.childContextTypes = assign(\n      {},\n      Constructor.childContextTypes,\n      childContextTypes\n    );\n  },\n  contextTypes: function(Constructor, contextTypes) {\n    if (false) {\n      validateTypeDef(\n        Constructor,\n        contextTypes,\n        ReactPropTypeLocations.context\n      );\n    }\n    Constructor.contextTypes = assign(\n      {},\n      Constructor.contextTypes,\n      contextTypes\n    );\n  },\n  /**\n   * Special case getDefaultProps which should move into statics but requires\n   * automatic merging.\n   */\n  getDefaultProps: function(Constructor, getDefaultProps) {\n    if (Constructor.getDefaultProps) {\n      Constructor.getDefaultProps = createMergedResultFunction(\n        Constructor.getDefaultProps,\n        getDefaultProps\n      );\n    } else {\n      Constructor.getDefaultProps = getDefaultProps;\n    }\n  },\n  propTypes: function(Constructor, propTypes) {\n    if (false) {\n      validateTypeDef(\n        Constructor,\n        propTypes,\n        ReactPropTypeLocations.prop\n      );\n    }\n    Constructor.propTypes = assign(\n      {},\n      Constructor.propTypes,\n      propTypes\n    );\n  },\n  statics: function(Constructor, statics) {\n    mixStaticSpecIntoComponent(Constructor, statics);\n  }\n};\n\nfunction validateTypeDef(Constructor, typeDef, location) {\n  for (var propName in typeDef) {\n    if (typeDef.hasOwnProperty(propName)) {\n      // use a warning instead of an invariant so components\n      // don't show up in prod but not in __DEV__\n      (false ? warning(\n        typeof typeDef[propName] === 'function',\n        '%s: %s type `%s` is invalid; it must be a function, usually from ' +\n        'React.PropTypes.',\n        Constructor.displayName || 'ReactClass',\n        ReactPropTypeLocationNames[location],\n        propName\n      ) : null);\n    }\n  }\n}\n\nfunction validateMethodOverride(proto, name) {\n  var specPolicy = ReactClassInterface.hasOwnProperty(name) ?\n    ReactClassInterface[name] :\n    null;\n\n  // Disallow overriding of base class methods unless explicitly allowed.\n  if (ReactClassMixin.hasOwnProperty(name)) {\n    (false ? invariant(\n      specPolicy === SpecPolicy.OVERRIDE_BASE,\n      'ReactClassInterface: You are attempting to override ' +\n      '`%s` from your class specification. Ensure that your method names ' +\n      'do not overlap with React methods.',\n      name\n    ) : invariant(specPolicy === SpecPolicy.OVERRIDE_BASE));\n  }\n\n  // Disallow defining methods more than once unless explicitly allowed.\n  if (proto.hasOwnProperty(name)) {\n    (false ? invariant(\n      specPolicy === SpecPolicy.DEFINE_MANY ||\n      specPolicy === SpecPolicy.DEFINE_MANY_MERGED,\n      'ReactClassInterface: You are attempting to define ' +\n      '`%s` on your component more than once. This conflict may be due ' +\n      'to a mixin.',\n      name\n    ) : invariant(specPolicy === SpecPolicy.DEFINE_MANY ||\n    specPolicy === SpecPolicy.DEFINE_MANY_MERGED));\n  }\n}\n\n/**\n * Mixin helper which handles policy validation and reserved\n * specification keys when building React classses.\n */\nfunction mixSpecIntoComponent(Constructor, spec) {\n  if (!spec) {\n    return;\n  }\n\n  (false ? invariant(\n    typeof spec !== 'function',\n    'ReactClass: You\\'re attempting to ' +\n    'use a component class as a mixin. Instead, just use a regular object.'\n  ) : invariant(typeof spec !== 'function'));\n  (false ? invariant(\n    !ReactElement.isValidElement(spec),\n    'ReactClass: You\\'re attempting to ' +\n    'use a component as a mixin. Instead, just use a regular object.'\n  ) : invariant(!ReactElement.isValidElement(spec)));\n\n  var proto = Constructor.prototype;\n\n  // By handling mixins before any other properties, we ensure the same\n  // chaining order is applied to methods with DEFINE_MANY policy, whether\n  // mixins are listed before or after these methods in the spec.\n  if (spec.hasOwnProperty(MIXINS_KEY)) {\n    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);\n  }\n\n  for (var name in spec) {\n    if (!spec.hasOwnProperty(name)) {\n      continue;\n    }\n\n    if (name === MIXINS_KEY) {\n      // We have already handled mixins in a special case above\n      continue;\n    }\n\n    var property = spec[name];\n    validateMethodOverride(proto, name);\n\n    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {\n      RESERVED_SPEC_KEYS[name](Constructor, property);\n    } else {\n      // Setup methods on prototype:\n      // The following member methods should not be automatically bound:\n      // 1. Expected ReactClass methods (in the \"interface\").\n      // 2. Overridden methods (that were mixed in).\n      var isReactClassMethod =\n        ReactClassInterface.hasOwnProperty(name);\n      var isAlreadyDefined = proto.hasOwnProperty(name);\n      var markedDontBind = property && property.__reactDontBind;\n      var isFunction = typeof property === 'function';\n      var shouldAutoBind =\n        isFunction &&\n        !isReactClassMethod &&\n        !isAlreadyDefined &&\n        !markedDontBind;\n\n      if (shouldAutoBind) {\n        if (!proto.__reactAutoBindMap) {\n          proto.__reactAutoBindMap = {};\n        }\n        proto.__reactAutoBindMap[name] = property;\n        proto[name] = property;\n      } else {\n        if (isAlreadyDefined) {\n          var specPolicy = ReactClassInterface[name];\n\n          // These cases should already be caught by validateMethodOverride\n          (false ? invariant(\n            isReactClassMethod && (\n              (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)\n            ),\n            'ReactClass: Unexpected spec policy %s for key %s ' +\n            'when mixing in component specs.',\n            specPolicy,\n            name\n          ) : invariant(isReactClassMethod && (\n            (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)\n          )));\n\n          // For methods which are defined more than once, call the existing\n          // methods before calling the new property, merging if appropriate.\n          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {\n            proto[name] = createMergedResultFunction(proto[name], property);\n          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {\n            proto[name] = createChainedFunction(proto[name], property);\n          }\n        } else {\n          proto[name] = property;\n          if (false) {\n            // Add verbose displayName to the function, which helps when looking\n            // at profiling tools.\n            if (typeof property === 'function' && spec.displayName) {\n              proto[name].displayName = spec.displayName + '_' + name;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction mixStaticSpecIntoComponent(Constructor, statics) {\n  if (!statics) {\n    return;\n  }\n  for (var name in statics) {\n    var property = statics[name];\n    if (!statics.hasOwnProperty(name)) {\n      continue;\n    }\n\n    var isReserved = name in RESERVED_SPEC_KEYS;\n    (false ? invariant(\n      !isReserved,\n      'ReactClass: You are attempting to define a reserved ' +\n      'property, `%s`, that shouldn\\'t be on the \"statics\" key. Define it ' +\n      'as an instance property instead; it will still be accessible on the ' +\n      'constructor.',\n      name\n    ) : invariant(!isReserved));\n\n    var isInherited = name in Constructor;\n    (false ? invariant(\n      !isInherited,\n      'ReactClass: You are attempting to define ' +\n      '`%s` on your component more than once. This conflict may be ' +\n      'due to a mixin.',\n      name\n    ) : invariant(!isInherited));\n    Constructor[name] = property;\n  }\n}\n\n/**\n * Merge two objects, but throw if both contain the same key.\n *\n * @param {object} one The first object, which is mutated.\n * @param {object} two The second object\n * @return {object} one after it has been mutated to contain everything in two.\n */\nfunction mergeIntoWithNoDuplicateKeys(one, two) {\n  (false ? invariant(\n    one && two && typeof one === 'object' && typeof two === 'object',\n    'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.'\n  ) : invariant(one && two && typeof one === 'object' && typeof two === 'object'));\n\n  for (var key in two) {\n    if (two.hasOwnProperty(key)) {\n      (false ? invariant(\n        one[key] === undefined,\n        'mergeIntoWithNoDuplicateKeys(): ' +\n        'Tried to merge two objects with the same key: `%s`. This conflict ' +\n        'may be due to a mixin; in particular, this may be caused by two ' +\n        'getInitialState() or getDefaultProps() methods returning objects ' +\n        'with clashing keys.',\n        key\n      ) : invariant(one[key] === undefined));\n      one[key] = two[key];\n    }\n  }\n  return one;\n}\n\n/**\n * Creates a function that invokes two functions and merges their return values.\n *\n * @param {function} one Function to invoke first.\n * @param {function} two Function to invoke second.\n * @return {function} Function that invokes the two argument functions.\n * @private\n */\nfunction createMergedResultFunction(one, two) {\n  return function mergedResult() {\n    var a = one.apply(this, arguments);\n    var b = two.apply(this, arguments);\n    if (a == null) {\n      return b;\n    } else if (b == null) {\n      return a;\n    }\n    var c = {};\n    mergeIntoWithNoDuplicateKeys(c, a);\n    mergeIntoWithNoDuplicateKeys(c, b);\n    return c;\n  };\n}\n\n/**\n * Creates a function that invokes two functions and ignores their return vales.\n *\n * @param {function} one Function to invoke first.\n * @param {function} two Function to invoke second.\n * @return {function} Function that invokes the two argument functions.\n * @private\n */\nfunction createChainedFunction(one, two) {\n  return function chainedFunction() {\n    one.apply(this, arguments);\n    two.apply(this, arguments);\n  };\n}\n\n/**\n * Binds a method to the component.\n *\n * @param {object} component Component whose method is going to be bound.\n * @param {function} method Method to be bound.\n * @return {function} The bound method.\n */\nfunction bindAutoBindMethod(component, method) {\n  var boundMethod = method.bind(component);\n  if (false) {\n    boundMethod.__reactBoundContext = component;\n    boundMethod.__reactBoundMethod = method;\n    boundMethod.__reactBoundArguments = null;\n    var componentName = component.constructor.displayName;\n    var _bind = boundMethod.bind;\n    /* eslint-disable block-scoped-var, no-undef */\n    boundMethod.bind = function(newThis ) {for (var args=[],$__0=1,$__1=arguments.length;$__0<$__1;$__0++) args.push(arguments[$__0]);\n      // User is trying to bind() an autobound method; we effectively will\n      // ignore the value of \"this\" that the user is trying to use, so\n      // let's warn.\n      if (newThis !== component && newThis !== null) {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          false,\n          'bind(): React component methods may only be bound to the ' +\n          'component instance. See %s',\n          componentName\n        ) : null);\n      } else if (!args.length) {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          false,\n          'bind(): You are binding a component method to the component. ' +\n          'React does this for you automatically in a high-performance ' +\n          'way, so you can safely remove this call. See %s',\n          componentName\n        ) : null);\n        return boundMethod;\n      }\n      var reboundMethod = _bind.apply(boundMethod, arguments);\n      reboundMethod.__reactBoundContext = component;\n      reboundMethod.__reactBoundMethod = method;\n      reboundMethod.__reactBoundArguments = args;\n      return reboundMethod;\n      /* eslint-enable */\n    };\n  }\n  return boundMethod;\n}\n\n/**\n * Binds all auto-bound methods in a component.\n *\n * @param {object} component Component whose method is going to be bound.\n */\nfunction bindAutoBindMethods(component) {\n  for (var autoBindKey in component.__reactAutoBindMap) {\n    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {\n      var method = component.__reactAutoBindMap[autoBindKey];\n      component[autoBindKey] = bindAutoBindMethod(\n        component,\n        ReactErrorUtils.guard(\n          method,\n          component.constructor.displayName + '.' + autoBindKey\n        )\n      );\n    }\n  }\n}\n\nvar typeDeprecationDescriptor = {\n  enumerable: false,\n  get: function() {\n    var displayName = this.displayName || this.name || 'Component';\n    (false ? warning(\n      false,\n      '%s.type is deprecated. Use %s directly to access the class.',\n      displayName,\n      displayName\n    ) : null);\n    Object.defineProperty(this, 'type', {\n      value: this\n    });\n    return this;\n  }\n};\n\n/**\n * Add more to the ReactClass base class. These are all legacy features and\n * therefore not already part of the modern ReactComponent.\n */\nvar ReactClassMixin = {\n\n  /**\n   * TODO: This will be deprecated because state should always keep a consistent\n   * type signature and the only use case for this, is to avoid that.\n   */\n  replaceState: function(newState, callback) {\n    ReactUpdateQueue.enqueueReplaceState(this, newState);\n    if (callback) {\n      ReactUpdateQueue.enqueueCallback(this, callback);\n    }\n  },\n\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function() {\n    if (false) {\n      var owner = ReactCurrentOwner.current;\n      if (owner !== null) {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          owner._warnedAboutRefsInRender,\n          '%s is accessing isMounted inside its render() function. ' +\n          'render() should be a pure function of props and state. It should ' +\n          'never access something that requires stale data from the previous ' +\n          'render, such as refs. Move this logic to componentDidMount and ' +\n          'componentDidUpdate instead.',\n          owner.getName() || 'A component'\n        ) : null);\n        owner._warnedAboutRefsInRender = true;\n      }\n    }\n    var internalInstance = ReactInstanceMap.get(this);\n    return (\n      internalInstance &&\n      internalInstance !== ReactLifeCycle.currentlyMountingInstance\n    );\n  },\n\n  /**\n   * Sets a subset of the props.\n   *\n   * @param {object} partialProps Subset of the next props.\n   * @param {?function} callback Called after props are updated.\n   * @final\n   * @public\n   * @deprecated\n   */\n  setProps: function(partialProps, callback) {\n    ReactUpdateQueue.enqueueSetProps(this, partialProps);\n    if (callback) {\n      ReactUpdateQueue.enqueueCallback(this, callback);\n    }\n  },\n\n  /**\n   * Replace all the props.\n   *\n   * @param {object} newProps Subset of the next props.\n   * @param {?function} callback Called after props are updated.\n   * @final\n   * @public\n   * @deprecated\n   */\n  replaceProps: function(newProps, callback) {\n    ReactUpdateQueue.enqueueReplaceProps(this, newProps);\n    if (callback) {\n      ReactUpdateQueue.enqueueCallback(this, callback);\n    }\n  }\n};\n\nvar ReactClassComponent = function() {};\nassign(\n  ReactClassComponent.prototype,\n  ReactComponent.prototype,\n  ReactClassMixin\n);\n\n/**\n * Module for creating composite components.\n *\n * @class ReactClass\n */\nvar ReactClass = {\n\n  /**\n   * Creates a composite component class given a class specification.\n   *\n   * @param {object} spec Class specification (which must define `render`).\n   * @return {function} Component constructor function.\n   * @public\n   */\n  createClass: function(spec) {\n    var Constructor = function(props, context) {\n      // This constructor is overridden by mocks. The argument is used\n      // by mocks to assert on what gets mounted.\n\n      if (false) {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          this instanceof Constructor,\n          'Something is calling a React component directly. Use a factory or ' +\n          'JSX instead. See: https://fb.me/react-legacyfactory'\n        ) : null);\n      }\n\n      // Wire up auto-binding\n      if (this.__reactAutoBindMap) {\n        bindAutoBindMethods(this);\n      }\n\n      this.props = props;\n      this.context = context;\n      this.state = null;\n\n      // ReactClasses doesn't have constructors. Instead, they use the\n      // getInitialState and componentWillMount methods for initialization.\n\n      var initialState = this.getInitialState ? this.getInitialState() : null;\n      if (false) {\n        // We allow auto-mocks to proceed as if they're returning null.\n        if (typeof initialState === 'undefined' &&\n            this.getInitialState._isMockFunction) {\n          // This is probably bad practice. Consider warning here and\n          // deprecating this convenience.\n          initialState = null;\n        }\n      }\n      (false ? invariant(\n        typeof initialState === 'object' && !Array.isArray(initialState),\n        '%s.getInitialState(): must return an object or null',\n        Constructor.displayName || 'ReactCompositeComponent'\n      ) : invariant(typeof initialState === 'object' && !Array.isArray(initialState)));\n\n      this.state = initialState;\n    };\n    Constructor.prototype = new ReactClassComponent();\n    Constructor.prototype.constructor = Constructor;\n\n    injectedMixins.forEach(\n      mixSpecIntoComponent.bind(null, Constructor)\n    );\n\n    mixSpecIntoComponent(Constructor, spec);\n\n    // Initialize the defaultProps property after all mixins have been merged\n    if (Constructor.getDefaultProps) {\n      Constructor.defaultProps = Constructor.getDefaultProps();\n    }\n\n    if (false) {\n      // This is a tag to indicate that the use of these method names is ok,\n      // since it's used with createClass. If it's not, then it's likely a\n      // mistake so we'll warn you to use the static property, property\n      // initializer or constructor respectively.\n      if (Constructor.getDefaultProps) {\n        Constructor.getDefaultProps.isReactClassApproved = {};\n      }\n      if (Constructor.prototype.getInitialState) {\n        Constructor.prototype.getInitialState.isReactClassApproved = {};\n      }\n    }\n\n    (false ? invariant(\n      Constructor.prototype.render,\n      'createClass(...): Class specification must implement a `render` method.'\n    ) : invariant(Constructor.prototype.render));\n\n    if (false) {\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        !Constructor.prototype.componentShouldUpdate,\n        '%s has a method called ' +\n        'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +\n        'The name is phrased as a question because the function is ' +\n        'expected to return a value.',\n        spec.displayName || 'A component'\n      ) : null);\n    }\n\n    // Reduce time spent doing lookups by setting these on the prototype.\n    for (var methodName in ReactClassInterface) {\n      if (!Constructor.prototype[methodName]) {\n        Constructor.prototype[methodName] = null;\n      }\n    }\n\n    // Legacy hook\n    Constructor.type = Constructor;\n    if (false) {\n      try {\n        Object.defineProperty(Constructor, 'type', typeDeprecationDescriptor);\n      } catch (x) {\n        // IE will fail on defineProperty (es5-shim/sham too)\n      }\n    }\n\n    return Constructor;\n  },\n\n  injection: {\n    injectMixin: function(mixin) {\n      injectedMixins.push(mixin);\n    }\n  }\n\n};\n\nmodule.exports = ReactClass;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactClass.js\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactClass.js?")},/*!*************************************!*\
  !*** ./~/react/lib/ReactUpdates.js ***!
  \*************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdates\n */\n\n'use strict';\n\nvar CallbackQueue = __webpack_require__(/*! ./CallbackQueue */ 45);\nvar PooledClass = __webpack_require__(/*! ./PooledClass */ 12);\nvar ReactCurrentOwner = __webpack_require__(/*! ./ReactCurrentOwner */ 14);\nvar ReactPerf = __webpack_require__(/*! ./ReactPerf */ 17);\nvar ReactReconciler = __webpack_require__(/*! ./ReactReconciler */ 25);\nvar Transaction = __webpack_require__(/*! ./Transaction */ 41);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nvar dirtyComponents = [];\nvar asapCallbackQueue = CallbackQueue.getPooled();\nvar asapEnqueued = false;\n\nvar batchingStrategy = null;\n\nfunction ensureInjected() {\n  (false ? invariant(\n    ReactUpdates.ReactReconcileTransaction && batchingStrategy,\n    'ReactUpdates: must inject a reconcile transaction class and batching ' +\n    'strategy'\n  ) : invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy));\n}\n\nvar NESTED_UPDATES = {\n  initialize: function() {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function() {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  }\n};\n\nvar UPDATE_QUEUEING = {\n  initialize: function() {\n    this.callbackQueue.reset();\n  },\n  close: function() {\n    this.callbackQueue.notifyAll();\n  }\n};\n\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\n\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.callbackQueue = CallbackQueue.getPooled();\n  this.reconcileTransaction =\n    ReactUpdates.ReactReconcileTransaction.getPooled();\n}\n\nassign(\n  ReactUpdatesFlushTransaction.prototype,\n  Transaction.Mixin, {\n  getTransactionWrappers: function() {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  destructor: function() {\n    this.dirtyComponentsLength = null;\n    CallbackQueue.release(this.callbackQueue);\n    this.callbackQueue = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n\n  perform: function(method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.Mixin.perform.call(\n      this,\n      this.reconcileTransaction.perform,\n      this.reconcileTransaction,\n      method,\n      scope,\n      a\n    );\n  }\n});\n\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\n\nfunction batchedUpdates(callback, a, b, c, d) {\n  ensureInjected();\n  batchingStrategy.batchedUpdates(callback, a, b, c, d);\n}\n\n/**\n * Array comparator for ReactComponents by mount ordering.\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\nfunction mountOrderComparator(c1, c2) {\n  return c1._mountOrder - c2._mountOrder;\n}\n\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  (false ? invariant(\n    len === dirtyComponents.length,\n    'Expected flush transaction\\'s stored dirty-components length (%s) to ' +\n    'match dirty-components array length (%s).',\n    len,\n    dirtyComponents.length\n  ) : invariant(len === dirtyComponents.length));\n\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountOrderComparator);\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, it will still\n    // be here, but we assume that it has cleared its _pendingCallbacks and\n    // that performUpdateIfNecessary is a noop.\n    var component = dirtyComponents[i];\n\n    // If performUpdateIfNecessary happens to enqueue any new updates, we\n    // shouldn't execute the callbacks until the next render happens, so\n    // stash the callbacks first\n    var callbacks = component._pendingCallbacks;\n    component._pendingCallbacks = null;\n\n    ReactReconciler.performUpdateIfNecessary(\n      component,\n      transaction.reconcileTransaction\n    );\n\n    if (callbacks) {\n      for (var j = 0; j < callbacks.length; j++) {\n        transaction.callbackQueue.enqueue(\n          callbacks[j],\n          component.getPublicInstance()\n        );\n      }\n    }\n  }\n}\n\nvar flushBatchedUpdates = function() {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks and asap calls.\n  while (dirtyComponents.length || asapEnqueued) {\n    if (dirtyComponents.length) {\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\n      transaction.perform(runBatchedUpdates, null, transaction);\n      ReactUpdatesFlushTransaction.release(transaction);\n    }\n\n    if (asapEnqueued) {\n      asapEnqueued = false;\n      var queue = asapCallbackQueue;\n      asapCallbackQueue = CallbackQueue.getPooled();\n      queue.notifyAll();\n      CallbackQueue.release(queue);\n    }\n  }\n};\nflushBatchedUpdates = ReactPerf.measure(\n  'ReactUpdates',\n  'flushBatchedUpdates',\n  flushBatchedUpdates\n);\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setProps, setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n  (false ? warning(\n    ReactCurrentOwner.current == null,\n    'enqueueUpdate(): Render methods should be a pure function of props ' +\n    'and state; triggering nested component updates from render is not ' +\n    'allowed. If necessary, trigger nested updates in ' +\n    'componentDidUpdate.'\n  ) : null);\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n}\n\n/**\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\n * if no updates are currently being performed.\n */\nfunction asap(callback, context) {\n  (false ? invariant(\n    batchingStrategy.isBatchingUpdates,\n    'ReactUpdates.asap: Can\\'t enqueue an asap callback in a context where' +\n    'updates are not being batched.'\n  ) : invariant(batchingStrategy.isBatchingUpdates));\n  asapCallbackQueue.enqueue(callback, context);\n  asapEnqueued = true;\n}\n\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function(ReconcileTransaction) {\n    (false ? invariant(\n      ReconcileTransaction,\n      'ReactUpdates: must provide a reconcile transaction class'\n    ) : invariant(ReconcileTransaction));\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n\n  injectBatchingStrategy: function(_batchingStrategy) {\n    (false ? invariant(\n      _batchingStrategy,\n      'ReactUpdates: must provide a batching strategy'\n    ) : invariant(_batchingStrategy));\n    (false ? invariant(\n      typeof _batchingStrategy.batchedUpdates === 'function',\n      'ReactUpdates: must provide a batchedUpdates() function'\n    ) : invariant(typeof _batchingStrategy.batchedUpdates === 'function'));\n    (false ? invariant(\n      typeof _batchingStrategy.isBatchingUpdates === 'boolean',\n      'ReactUpdates: must provide an isBatchingUpdates boolean attribute'\n    ) : invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean'));\n    batchingStrategy = _batchingStrategy;\n  }\n};\n\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n  asap: asap\n};\n\nmodule.exports = ReactUpdates;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactUpdates.js\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactUpdates.js?")},/*!**************************************!*\
  !*** ./~/react/lib/emptyFunction.js ***!
  \**************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule emptyFunction\n */\n\nfunction makeEmptyFunction(arg) {\n  return function() {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nfunction emptyFunction() {}\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function() { return this; };\nemptyFunction.thatReturnsArgument = function(arg) { return arg; };\n\nmodule.exports = emptyFunction;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/emptyFunction.js\n ** module id = 10\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/emptyFunction.js?")},/*!******************************!*\
  !*** ./~/react/lib/keyOf.js ***!
  \******************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule keyOf\n */\n\n/**\n * Allows extraction of a minified key. Let's the build system minify keys\n * without loosing the ability to dynamically use key strings as values\n * themselves. Pass in an object with a single key/val pair and it will return\n * you the string key of that single record. Suppose you want to grab the\n * value for a key 'className' inside of an object. Key/val minification may\n * have aliased that key to be 'xa12'. keyOf({className: null}) will return\n * 'xa12' in that case. Resolve keys you want to use once at startup time, then\n * reuse those resolutions.\n */\nvar keyOf = function(oneKeyObj) {\n  var key;\n  for (key in oneKeyObj) {\n    if (!oneKeyObj.hasOwnProperty(key)) {\n      continue;\n    }\n    return key;\n  }\n  return null;\n};\n\n\nmodule.exports = keyOf;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/keyOf.js\n ** module id = 11\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/keyOf.js?")},/*!************************************!*\
  !*** ./~/react/lib/PooledClass.js ***!
  \************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule PooledClass\n */\n\n'use strict';\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\n/**\n * Static poolers. Several custom versions for each potential number of\n * arguments. A completely generic pooler is easy to implement, but would\n * require accessing the `arguments` object. In each of these, `this` refers to\n * the Class itself, not an instance. If any others are needed, simply add them\n * here, or in their own files.\n */\nvar oneArgumentPooler = function(copyFieldsFrom) {\n  var Klass = this;\n  if (Klass.instancePool.length) {\n    var instance = Klass.instancePool.pop();\n    Klass.call(instance, copyFieldsFrom);\n    return instance;\n  } else {\n    return new Klass(copyFieldsFrom);\n  }\n};\n\nvar twoArgumentPooler = function(a1, a2) {\n  var Klass = this;\n  if (Klass.instancePool.length) {\n    var instance = Klass.instancePool.pop();\n    Klass.call(instance, a1, a2);\n    return instance;\n  } else {\n    return new Klass(a1, a2);\n  }\n};\n\nvar threeArgumentPooler = function(a1, a2, a3) {\n  var Klass = this;\n  if (Klass.instancePool.length) {\n    var instance = Klass.instancePool.pop();\n    Klass.call(instance, a1, a2, a3);\n    return instance;\n  } else {\n    return new Klass(a1, a2, a3);\n  }\n};\n\nvar fiveArgumentPooler = function(a1, a2, a3, a4, a5) {\n  var Klass = this;\n  if (Klass.instancePool.length) {\n    var instance = Klass.instancePool.pop();\n    Klass.call(instance, a1, a2, a3, a4, a5);\n    return instance;\n  } else {\n    return new Klass(a1, a2, a3, a4, a5);\n  }\n};\n\nvar standardReleaser = function(instance) {\n  var Klass = this;\n  (false ? invariant(\n    instance instanceof Klass,\n    'Trying to release an instance into a pool of a different type.'\n  ) : invariant(instance instanceof Klass));\n  if (instance.destructor) {\n    instance.destructor();\n  }\n  if (Klass.instancePool.length < Klass.poolSize) {\n    Klass.instancePool.push(instance);\n  }\n};\n\nvar DEFAULT_POOL_SIZE = 10;\nvar DEFAULT_POOLER = oneArgumentPooler;\n\n/**\n * Augments `CopyConstructor` to be a poolable class, augmenting only the class\n * itself (statically) not adding any prototypical fields. Any CopyConstructor\n * you give this may have a `poolSize` property, and will look for a\n * prototypical `destructor` on instances (optional).\n *\n * @param {Function} CopyConstructor Constructor that can be used to reset.\n * @param {Function} pooler Customizable pooler.\n */\nvar addPoolingTo = function(CopyConstructor, pooler) {\n  var NewKlass = CopyConstructor;\n  NewKlass.instancePool = [];\n  NewKlass.getPooled = pooler || DEFAULT_POOLER;\n  if (!NewKlass.poolSize) {\n    NewKlass.poolSize = DEFAULT_POOL_SIZE;\n  }\n  NewKlass.release = standardReleaser;\n  return NewKlass;\n};\n\nvar PooledClass = {\n  addPoolingTo: addPoolingTo,\n  oneArgumentPooler: oneArgumentPooler,\n  twoArgumentPooler: twoArgumentPooler,\n  threeArgumentPooler: threeArgumentPooler,\n  fiveArgumentPooler: fiveArgumentPooler\n};\n\nmodule.exports = PooledClass;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/PooledClass.js\n ** module id = 12\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/PooledClass.js?")},/*!***************************************************!*\
  !*** ./~/react/lib/ReactBrowserComponentMixin.js ***!
  \***************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactBrowserComponentMixin\n */\n\n'use strict';\n\nvar findDOMNode = __webpack_require__(/*! ./findDOMNode */ 88);\n\nvar ReactBrowserComponentMixin = {\n  /**\n   * Returns the DOM node rendered by this component.\n   *\n   * @return {DOMElement} The root node of this component.\n   * @final\n   * @protected\n   */\n  getDOMNode: function() {\n    return findDOMNode(this);\n  }\n};\n\nmodule.exports = ReactBrowserComponentMixin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactBrowserComponentMixin.js\n ** module id = 13\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactBrowserComponentMixin.js?")},/*!******************************************!*\
  !*** ./~/react/lib/ReactCurrentOwner.js ***!
  \******************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactCurrentOwner\n */\n\n'use strict';\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n *\n * The depth indicate how many composite components are above this render level.\n */\nvar ReactCurrentOwner = {\n\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n\n};\n\nmodule.exports = ReactCurrentOwner;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactCurrentOwner.js\n ** module id = 14\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactCurrentOwner.js?")},/*!***********************************!*\
  !*** ./~/react/lib/ReactMount.js ***!
  \***********************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMount\n */\n\n'use strict';\n\nvar DOMProperty = __webpack_require__(/*! ./DOMProperty */ 19);\nvar ReactBrowserEventEmitter = __webpack_require__(/*! ./ReactBrowserEventEmitter */ 21);\nvar ReactCurrentOwner = __webpack_require__(/*! ./ReactCurrentOwner */ 14);\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\nvar ReactElementValidator = __webpack_require__(/*! ./ReactElementValidator */ 32);\nvar ReactEmptyComponent = __webpack_require__(/*! ./ReactEmptyComponent */ 53);\nvar ReactInstanceHandles = __webpack_require__(/*! ./ReactInstanceHandles */ 23);\nvar ReactInstanceMap = __webpack_require__(/*! ./ReactInstanceMap */ 24);\nvar ReactMarkupChecksum = __webpack_require__(/*! ./ReactMarkupChecksum */ 79);\nvar ReactPerf = __webpack_require__(/*! ./ReactPerf */ 17);\nvar ReactReconciler = __webpack_require__(/*! ./ReactReconciler */ 25);\nvar ReactUpdateQueue = __webpack_require__(/*! ./ReactUpdateQueue */ 56);\nvar ReactUpdates = __webpack_require__(/*! ./ReactUpdates */ 9);\n\nvar emptyObject = __webpack_require__(/*! ./emptyObject */ 42);\nvar containsNode = __webpack_require__(/*! ./containsNode */ 87);\nvar getReactRootElementInContainer = __webpack_require__(/*! ./getReactRootElementInContainer */ 192);\nvar instantiateReactComponent = __webpack_require__(/*! ./instantiateReactComponent */ 62);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\nvar setInnerHTML = __webpack_require__(/*! ./setInnerHTML */ 64);\nvar shouldUpdateReactComponent = __webpack_require__(/*! ./shouldUpdateReactComponent */ 65);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\n\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\nvar nodeCache = {};\n\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\n\n/** Mapping from reactRootID to React component instance. */\nvar instancesByReactRootID = {};\n\n/** Mapping from reactRootID to `container` nodes. */\nvar containersByReactRootID = {};\n\nif (false) {\n  /** __DEV__-only mapping from reactRootID to root elements. */\n  var rootElementsByReactRootID = {};\n}\n\n// Used to store breadth-first search state in findComponentRoot.\nvar findComponentRootReusableArray = [];\n\n/**\n * Finds the index of the first character\n * that's not common between the two given strings.\n *\n * @return {number} the index of the character where the strings diverge\n */\nfunction firstDifferenceIndex(string1, string2) {\n  var minLen = Math.min(string1.length, string2.length);\n  for (var i = 0; i < minLen; i++) {\n    if (string1.charAt(i) !== string2.charAt(i)) {\n      return i;\n    }\n  }\n  return string1.length === string2.length ? -1 : minLen;\n}\n\n/**\n * @param {DOMElement} container DOM element that may contain a React component.\n * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\n */\nfunction getReactRootID(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return rootElement && ReactMount.getID(rootElement);\n}\n\n/**\n * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form\n * element can return its control whose name or ID equals ATTR_NAME. All\n * DOM nodes support `getAttributeNode` but this can also get called on\n * other objects so just return '' if we're given something other than a\n * DOM node (such as window).\n *\n * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.\n * @return {string} ID of the supplied `domNode`.\n */\nfunction getID(node) {\n  var id = internalGetID(node);\n  if (id) {\n    if (nodeCache.hasOwnProperty(id)) {\n      var cached = nodeCache[id];\n      if (cached !== node) {\n        (false ? invariant(\n          !isValid(cached, id),\n          'ReactMount: Two valid but unequal nodes with the same `%s`: %s',\n          ATTR_NAME, id\n        ) : invariant(!isValid(cached, id)));\n\n        nodeCache[id] = node;\n      }\n    } else {\n      nodeCache[id] = node;\n    }\n  }\n\n  return id;\n}\n\nfunction internalGetID(node) {\n  // If node is something like a window, document, or text node, none of\n  // which support attributes or a .getAttribute method, gracefully return\n  // the empty string, as if the attribute were missing.\n  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';\n}\n\n/**\n * Sets the React-specific ID of the given node.\n *\n * @param {DOMElement} node The DOM node whose ID will be set.\n * @param {string} id The value of the ID attribute.\n */\nfunction setID(node, id) {\n  var oldID = internalGetID(node);\n  if (oldID !== id) {\n    delete nodeCache[oldID];\n  }\n  node.setAttribute(ATTR_NAME, id);\n  nodeCache[id] = node;\n}\n\n/**\n * Finds the node with the supplied React-generated DOM ID.\n *\n * @param {string} id A React-generated DOM ID.\n * @return {DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNode(id) {\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * Finds the node with the supplied public React instance.\n *\n * @param {*} instance A public React instance.\n * @return {?DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNodeFromInstance(instance) {\n  var id = ReactInstanceMap.get(instance)._rootNodeID;\n  if (ReactEmptyComponent.isNullComponentID(id)) {\n    return null;\n  }\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * A node is \"valid\" if it is contained by a currently mounted container.\n *\n * This means that the node does not have to be contained by a document in\n * order to be considered valid.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @param {string} id The expected ID of the node.\n * @return {boolean} Whether the node is contained by a mounted container.\n */\nfunction isValid(node, id) {\n  if (node) {\n    (false ? invariant(\n      internalGetID(node) === id,\n      'ReactMount: Unexpected modification of `%s`',\n      ATTR_NAME\n    ) : invariant(internalGetID(node) === id));\n\n    var container = ReactMount.findReactContainerForID(id);\n    if (container && containsNode(container, node)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Causes the cache to forget about one React-specific ID.\n *\n * @param {string} id The ID to forget.\n */\nfunction purgeID(id) {\n  delete nodeCache[id];\n}\n\nvar deepestNodeSoFar = null;\nfunction findDeepestCachedAncestorImpl(ancestorID) {\n  var ancestor = nodeCache[ancestorID];\n  if (ancestor && isValid(ancestor, ancestorID)) {\n    deepestNodeSoFar = ancestor;\n  } else {\n    // This node isn't populated in the cache, so presumably none of its\n    // descendants are. Break out of the loop.\n    return false;\n  }\n}\n\n/**\n * Return the deepest cached node whose ID is a prefix of `targetID`.\n */\nfunction findDeepestCachedAncestor(targetID) {\n  deepestNodeSoFar = null;\n  ReactInstanceHandles.traverseAncestors(\n    targetID,\n    findDeepestCachedAncestorImpl\n  );\n\n  var foundNode = deepestNodeSoFar;\n  deepestNodeSoFar = null;\n  return foundNode;\n}\n\n/**\n * Mounts this component and inserts it into the DOM.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {ReactReconcileTransaction} transaction\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction mountComponentIntoNode(\n    componentInstance,\n    rootID,\n    container,\n    transaction,\n    shouldReuseMarkup) {\n  var markup = ReactReconciler.mountComponent(\n    componentInstance, rootID, transaction, emptyObject\n  );\n  componentInstance._isTopLevel = true;\n  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup);\n}\n\n/**\n * Batched mount.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction batchedMountComponentIntoNode(\n    componentInstance,\n    rootID,\n    container,\n    shouldReuseMarkup) {\n  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();\n  transaction.perform(\n    mountComponentIntoNode,\n    null,\n    componentInstance,\n    rootID,\n    container,\n    transaction,\n    shouldReuseMarkup\n  );\n  ReactUpdates.ReactReconcileTransaction.release(transaction);\n}\n\n/**\n * Mounting is the process of initializing a React component by creating its\n * representative DOM elements and inserting them into a supplied `container`.\n * Any prior content inside `container` is destroyed in the process.\n *\n *   ReactMount.render(\n *     component,\n *     document.getElementById('container')\n *   );\n *\n *   <div id=\"container\">                   <-- Supplied `container`.\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\n *       // ...                                 component.\n *     </div>\n *   </div>\n *\n * Inside of `container`, the first element rendered is the \"reactRoot\".\n */\nvar ReactMount = {\n  /** Exposed for debugging purposes **/\n  _instancesByReactRootID: instancesByReactRootID,\n\n  /**\n   * This is a hook provided to support rendering React components while\n   * ensuring that the apparent scroll position of its `container` does not\n   * change.\n   *\n   * @param {DOMElement} container The `container` being rendered into.\n   * @param {function} renderCallback This must be called once to do the render.\n   */\n  scrollMonitor: function(container, renderCallback) {\n    renderCallback();\n  },\n\n  /**\n   * Take a component that's already mounted into the DOM and replace its props\n   * @param {ReactComponent} prevComponent component instance already in the DOM\n   * @param {ReactElement} nextElement component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {?function} callback function triggered on completion\n   */\n  _updateRootComponent: function(\n      prevComponent,\n      nextElement,\n      container,\n      callback) {\n    if (false) {\n      ReactElementValidator.checkAndWarnForMutatedProps(nextElement);\n    }\n\n    ReactMount.scrollMonitor(container, function() {\n      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);\n      if (callback) {\n        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);\n      }\n    });\n\n    if (false) {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[getReactRootID(container)] =\n        getReactRootElementInContainer(container);\n    }\n\n    return prevComponent;\n  },\n\n  /**\n   * Register a component into the instance map and starts scroll value\n   * monitoring\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @return {string} reactRoot ID prefix\n   */\n  _registerComponent: function(nextComponent, container) {\n    (false ? invariant(\n      container && (\n        (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n      ),\n      '_registerComponent(...): Target container is not a DOM element.'\n    ) : invariant(container && (\n      (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n    )));\n\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\n\n    var reactRootID = ReactMount.registerContainer(container);\n    instancesByReactRootID[reactRootID] = nextComponent;\n    return reactRootID;\n  },\n\n  /**\n   * Render a new component into the DOM.\n   * @param {ReactElement} nextElement element to render\n   * @param {DOMElement} container container to render into\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\n   * @return {ReactComponent} nextComponent\n   */\n  _renderNewRootComponent: function(\n    nextElement,\n    container,\n    shouldReuseMarkup\n  ) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case.\n    (false ? warning(\n      ReactCurrentOwner.current == null,\n      '_renderNewRootComponent(): Render methods should be a pure function ' +\n      'of props and state; triggering nested component updates from ' +\n      'render is not allowed. If necessary, trigger nested updates in ' +\n      'componentDidUpdate.'\n    ) : null);\n\n    var componentInstance = instantiateReactComponent(nextElement, null);\n    var reactRootID = ReactMount._registerComponent(\n      componentInstance,\n      container\n    );\n\n    // The initial render is synchronous but any updates that happen during\n    // rendering, in componentWillMount or componentDidMount, will be batched\n    // according to the current batching strategy.\n\n    ReactUpdates.batchedUpdates(\n      batchedMountComponentIntoNode,\n      componentInstance,\n      reactRootID,\n      container,\n      shouldReuseMarkup\n    );\n\n    if (false) {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[reactRootID] =\n        getReactRootElementInContainer(container);\n    }\n\n    return componentInstance;\n  },\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  render: function(nextElement, container, callback) {\n    (false ? invariant(\n      ReactElement.isValidElement(nextElement),\n      'React.render(): Invalid component element.%s',\n      (\n        typeof nextElement === 'string' ?\n          ' Instead of passing an element string, make sure to instantiate ' +\n          'it by passing it to React.createElement.' :\n        typeof nextElement === 'function' ?\n          ' Instead of passing a component class, make sure to instantiate ' +\n          'it by passing it to React.createElement.' :\n        // Check if it quacks like an element\n        nextElement != null && nextElement.props !== undefined ?\n          ' This may be caused by unintentionally loading two independent ' +\n          'copies of React.' :\n          ''\n      )\n    ) : invariant(ReactElement.isValidElement(nextElement)));\n\n    var prevComponent = instancesByReactRootID[getReactRootID(container)];\n\n    if (prevComponent) {\n      var prevElement = prevComponent._currentElement;\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        return ReactMount._updateRootComponent(\n          prevComponent,\n          nextElement,\n          container,\n          callback\n        ).getPublicInstance();\n      } else {\n        ReactMount.unmountComponentAtNode(container);\n      }\n    }\n\n    var reactRootElement = getReactRootElementInContainer(container);\n    var containerHasReactMarkup =\n      reactRootElement && ReactMount.isRenderedByReact(reactRootElement);\n\n    if (false) {\n      if (!containerHasReactMarkup || reactRootElement.nextSibling) {\n        var rootElementSibling = reactRootElement;\n        while (rootElementSibling) {\n          if (ReactMount.isRenderedByReact(rootElementSibling)) {\n            (\"production\" !== process.env.NODE_ENV ? warning(\n              false,\n              'render(): Target node has markup rendered by React, but there ' +\n              'are unrelated nodes as well. This is most commonly caused by ' +\n              'white-space inserted around server-rendered markup.'\n            ) : null);\n            break;\n          }\n\n          rootElementSibling = rootElementSibling.nextSibling;\n        }\n      }\n    }\n\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;\n\n    var component = ReactMount._renderNewRootComponent(\n      nextElement,\n      container,\n      shouldReuseMarkup\n    ).getPublicInstance();\n    if (callback) {\n      callback.call(component);\n    }\n    return component;\n  },\n\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into the supplied `container`.\n   *\n   * @param {function} constructor React component constructor.\n   * @param {?object} props Initial props of the component instance.\n   * @param {DOMElement} container DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  constructAndRenderComponent: function(constructor, props, container) {\n    var element = ReactElement.createElement(constructor, props);\n    return ReactMount.render(element, container);\n  },\n\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into a container node identified by supplied `id`.\n   *\n   * @param {function} componentConstructor React component constructor\n   * @param {?object} props Initial props of the component instance.\n   * @param {string} id ID of the DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in the container node.\n   */\n  constructAndRenderComponentByID: function(constructor, props, id) {\n    var domNode = document.getElementById(id);\n    (false ? invariant(\n      domNode,\n      'Tried to get element with id of \"%s\" but it is not present on the page.',\n      id\n    ) : invariant(domNode));\n    return ReactMount.constructAndRenderComponent(constructor, props, domNode);\n  },\n\n  /**\n   * Registers a container node into which React components will be rendered.\n   * This also creates the \"reactRoot\" ID that will be assigned to the element\n   * rendered within.\n   *\n   * @param {DOMElement} container DOM element to register as a container.\n   * @return {string} The \"reactRoot\" ID of elements rendered within.\n   */\n  registerContainer: function(container) {\n    var reactRootID = getReactRootID(container);\n    if (reactRootID) {\n      // If one exists, make sure it is a valid \"reactRoot\" ID.\n      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);\n    }\n    if (!reactRootID) {\n      // No valid \"reactRoot\" ID found, create one.\n      reactRootID = ReactInstanceHandles.createReactRootID();\n    }\n    containersByReactRootID[reactRootID] = container;\n    return reactRootID;\n  },\n\n  /**\n   * Unmounts and destroys the React component rendered in the `container`.\n   *\n   * @param {DOMElement} container DOM element containing a React component.\n   * @return {boolean} True if a component was found in and unmounted from\n   *                   `container`\n   */\n  unmountComponentAtNode: function(container) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\n    // render but we still don't expect to be in a render call here.)\n    (false ? warning(\n      ReactCurrentOwner.current == null,\n      'unmountComponentAtNode(): Render methods should be a pure function of ' +\n      'props and state; triggering nested component updates from render is ' +\n      'not allowed. If necessary, trigger nested updates in ' +\n      'componentDidUpdate.'\n    ) : null);\n\n    (false ? invariant(\n      container && (\n        (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n      ),\n      'unmountComponentAtNode(...): Target container is not a DOM element.'\n    ) : invariant(container && (\n      (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n    )));\n\n    var reactRootID = getReactRootID(container);\n    var component = instancesByReactRootID[reactRootID];\n    if (!component) {\n      return false;\n    }\n    ReactMount.unmountComponentFromNode(component, container);\n    delete instancesByReactRootID[reactRootID];\n    delete containersByReactRootID[reactRootID];\n    if (false) {\n      delete rootElementsByReactRootID[reactRootID];\n    }\n    return true;\n  },\n\n  /**\n   * Unmounts a component and removes it from the DOM.\n   *\n   * @param {ReactComponent} instance React component instance.\n   * @param {DOMElement} container DOM element to unmount from.\n   * @final\n   * @internal\n   * @see {ReactMount.unmountComponentAtNode}\n   */\n  unmountComponentFromNode: function(instance, container) {\n    ReactReconciler.unmountComponent(instance);\n\n    if (container.nodeType === DOC_NODE_TYPE) {\n      container = container.documentElement;\n    }\n\n    // http://jsperf.com/emptying-a-node\n    while (container.lastChild) {\n      container.removeChild(container.lastChild);\n    }\n  },\n\n  /**\n   * Finds the container DOM element that contains React component to which the\n   * supplied DOM `id` belongs.\n   *\n   * @param {string} id The ID of an element rendered by a React component.\n   * @return {?DOMElement} DOM element that contains the `id`.\n   */\n  findReactContainerForID: function(id) {\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\n    var container = containersByReactRootID[reactRootID];\n\n    if (false) {\n      var rootElement = rootElementsByReactRootID[reactRootID];\n      if (rootElement && rootElement.parentNode !== container) {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          // Call internalGetID here because getID calls isValid which calls\n          // findReactContainerForID (this function).\n          internalGetID(rootElement) === reactRootID,\n          'ReactMount: Root element ID differed from reactRootID.'\n        ) : invariant(// Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID));\n\n        var containerChild = container.firstChild;\n        if (containerChild &&\n            reactRootID === internalGetID(containerChild)) {\n          // If the container has a new child with the same ID as the old\n          // root element, then rootElementsByReactRootID[reactRootID] is\n          // just stale and needs to be updated. The case that deserves a\n          // warning is when the container is empty.\n          rootElementsByReactRootID[reactRootID] = containerChild;\n        } else {\n          (\"production\" !== process.env.NODE_ENV ? warning(\n            false,\n            'ReactMount: Root element has been removed from its original ' +\n            'container. New container:', rootElement.parentNode\n          ) : null);\n        }\n      }\n    }\n\n    return container;\n  },\n\n  /**\n   * Finds an element rendered by React with the supplied ID.\n   *\n   * @param {string} id ID of a DOM node in the React component.\n   * @return {DOMElement} Root DOM node of the React component.\n   */\n  findReactNodeByID: function(id) {\n    var reactRoot = ReactMount.findReactContainerForID(id);\n    return ReactMount.findComponentRoot(reactRoot, id);\n  },\n\n  /**\n   * True if the supplied `node` is rendered by React.\n   *\n   * @param {*} node DOM Element to check.\n   * @return {boolean} True if the DOM Element appears to be rendered by React.\n   * @internal\n   */\n  isRenderedByReact: function(node) {\n    if (node.nodeType !== 1) {\n      // Not a DOMElement, therefore not a React component\n      return false;\n    }\n    var id = ReactMount.getID(node);\n    return id ? id.charAt(0) === SEPARATOR : false;\n  },\n\n  /**\n   * Traverses up the ancestors of the supplied node to find a node that is a\n   * DOM representation of a React component.\n   *\n   * @param {*} node\n   * @return {?DOMEventTarget}\n   * @internal\n   */\n  getFirstReactDOM: function(node) {\n    var current = node;\n    while (current && current.parentNode !== current) {\n      if (ReactMount.isRenderedByReact(current)) {\n        return current;\n      }\n      current = current.parentNode;\n    }\n    return null;\n  },\n\n  /**\n   * Finds a node with the supplied `targetID` inside of the supplied\n   * `ancestorNode`.  Exploits the ID naming scheme to perform the search\n   * quickly.\n   *\n   * @param {DOMEventTarget} ancestorNode Search from this root.\n   * @pararm {string} targetID ID of the DOM representation of the component.\n   * @return {DOMEventTarget} DOM node with the supplied `targetID`.\n   * @internal\n   */\n  findComponentRoot: function(ancestorNode, targetID) {\n    var firstChildren = findComponentRootReusableArray;\n    var childIndex = 0;\n\n    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;\n\n    firstChildren[0] = deepestAncestor.firstChild;\n    firstChildren.length = 1;\n\n    while (childIndex < firstChildren.length) {\n      var child = firstChildren[childIndex++];\n      var targetChild;\n\n      while (child) {\n        var childID = ReactMount.getID(child);\n        if (childID) {\n          // Even if we find the node we're looking for, we finish looping\n          // through its siblings to ensure they're cached so that we don't have\n          // to revisit this node again. Otherwise, we make n^2 calls to getID\n          // when visiting the many children of a single node in order.\n\n          if (targetID === childID) {\n            targetChild = child;\n          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {\n            // If we find a child whose ID is an ancestor of the given ID,\n            // then we can be sure that we only want to search the subtree\n            // rooted at this child, so we can throw out the rest of the\n            // search state.\n            firstChildren.length = childIndex = 0;\n            firstChildren.push(child.firstChild);\n          }\n\n        } else {\n          // If this child had no ID, then there's a chance that it was\n          // injected automatically by the browser, as when a `<table>`\n          // element sprouts an extra `<tbody>` child as a side effect of\n          // `.innerHTML` parsing. Optimistically continue down this\n          // branch, but not before examining the other siblings.\n          firstChildren.push(child.firstChild);\n        }\n\n        child = child.nextSibling;\n      }\n\n      if (targetChild) {\n        // Emptying firstChildren/findComponentRootReusableArray is\n        // not necessary for correctness, but it helps the GC reclaim\n        // any nodes that were left at the end of the search.\n        firstChildren.length = 0;\n\n        return targetChild;\n      }\n    }\n\n    firstChildren.length = 0;\n\n    (false ? invariant(\n      false,\n      'findComponentRoot(..., %s): Unable to find element. This probably ' +\n      'means the DOM was unexpectedly mutated (e.g., by the browser), ' +\n      'usually due to forgetting a <tbody> when using tables, nesting tags ' +\n      'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' +\n      'parent. ' +\n      'Try inspecting the child nodes of the element with React ID `%s`.',\n      targetID,\n      ReactMount.getID(ancestorNode)\n    ) : invariant(false));\n  },\n\n  _mountImageIntoNode: function(markup, container, shouldReuseMarkup) {\n    (false ? invariant(\n      container && (\n        (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n      ),\n      'mountComponentIntoNode(...): Target container is not valid.'\n    ) : invariant(container && (\n      (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n    )));\n\n    if (shouldReuseMarkup) {\n      var rootElement = getReactRootElementInContainer(container);\n      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {\n        return;\n      } else {\n        var checksum = rootElement.getAttribute(\n          ReactMarkupChecksum.CHECKSUM_ATTR_NAME\n        );\n        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n\n        var rootMarkup = rootElement.outerHTML;\n        rootElement.setAttribute(\n          ReactMarkupChecksum.CHECKSUM_ATTR_NAME,\n          checksum\n        );\n\n        var diffIndex = firstDifferenceIndex(markup, rootMarkup);\n        var difference = ' (client) ' +\n          markup.substring(diffIndex - 20, diffIndex + 20) +\n          '\\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);\n\n        (false ? invariant(\n          container.nodeType !== DOC_NODE_TYPE,\n          'You\\'re trying to render a component to the document using ' +\n          'server rendering but the checksum was invalid. This usually ' +\n          'means you rendered a different component type or props on ' +\n          'the client from the one on the server, or your render() ' +\n          'methods are impure. React cannot handle this case due to ' +\n          'cross-browser quirks by rendering at the document root. You ' +\n          'should look for environment dependent code in your components ' +\n          'and ensure the props are the same client and server side:\\n%s',\n          difference\n        ) : invariant(container.nodeType !== DOC_NODE_TYPE));\n\n        if (false) {\n          (\"production\" !== process.env.NODE_ENV ? warning(\n            false,\n            'React attempted to reuse markup in a container but the ' +\n            'checksum was invalid. This generally means that you are ' +\n            'using server rendering and the markup generated on the ' +\n            'server was not what the client was expecting. React injected ' +\n            'new markup to compensate which works but you have lost many ' +\n            'of the benefits of server rendering. Instead, figure out ' +\n            'why the markup being generated is different on the client ' +\n            'or server:\\n%s',\n            difference\n          ) : null);\n        }\n      }\n    }\n\n    (false ? invariant(\n      container.nodeType !== DOC_NODE_TYPE,\n      'You\\'re trying to render a component to the document but ' +\n        'you didn\\'t use server rendering. We can\\'t do this ' +\n        'without using server rendering due to cross-browser quirks. ' +\n        'See React.renderToString() for server rendering.'\n    ) : invariant(container.nodeType !== DOC_NODE_TYPE));\n\n    setInnerHTML(container, markup);\n  },\n\n  /**\n   * React ID utilities.\n   */\n\n  getReactRootID: getReactRootID,\n\n  getID: getID,\n\n  setID: setID,\n\n  getNode: getNode,\n\n  getNodeFromInstance: getNodeFromInstance,\n\n  purgeID: purgeID\n};\n\nReactPerf.measureMethods(ReactMount, 'ReactMount', {\n  _renderNewRootComponent: '_renderNewRootComponent',\n  _mountImageIntoNode: '_mountImageIntoNode'\n});\n\nmodule.exports = ReactMount;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactMount.js\n ** module id = 15\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactMount.js?");
},/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.wks.js ***!
  \************************************************************/
function(module,exports,__webpack_require__){eval("var global = __webpack_require__(/*! ./$ */ 5).g\n  , store  = __webpack_require__(/*! ./$.shared */ 70)('wks');\nmodule.exports = function(name){\n  return store[name] || (store[name] =\n    global.Symbol && global.Symbol[name] || __webpack_require__(/*! ./$.uid */ 36).safe('Symbol.' + name));\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.wks.js\n ** module id = 16\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.wks.js?")},/*!**********************************!*\
  !*** ./~/react/lib/ReactPerf.js ***!
  \**********************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPerf\n * @typechecks static-only\n */\n\n'use strict';\n\n/**\n * ReactPerf is a general AOP system designed to measure performance. This\n * module only has the hooks: see ReactDefaultPerf for the analysis tool.\n */\nvar ReactPerf = {\n  /**\n   * Boolean to enable/disable measurement. Set to false by default to prevent\n   * accidental logging and perf loss.\n   */\n  enableMeasure: false,\n\n  /**\n   * Holds onto the measure function in use. By default, don't measure\n   * anything, but we'll override this if we inject a measure function.\n   */\n  storedMeasure: _noMeasure,\n\n  /**\n   * @param {object} object\n   * @param {string} objectName\n   * @param {object<string>} methodNames\n   */\n  measureMethods: function(object, objectName, methodNames) {\n    if (false) {\n      for (var key in methodNames) {\n        if (!methodNames.hasOwnProperty(key)) {\n          continue;\n        }\n        object[key] = ReactPerf.measure(\n          objectName,\n          methodNames[key],\n          object[key]\n        );\n      }\n    }\n  },\n\n  /**\n   * Use this to wrap methods you want to measure. Zero overhead in production.\n   *\n   * @param {string} objName\n   * @param {string} fnName\n   * @param {function} func\n   * @return {function}\n   */\n  measure: function(objName, fnName, func) {\n    if (false) {\n      var measuredFunc = null;\n      var wrapper = function() {\n        if (ReactPerf.enableMeasure) {\n          if (!measuredFunc) {\n            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);\n          }\n          return measuredFunc.apply(this, arguments);\n        }\n        return func.apply(this, arguments);\n      };\n      wrapper.displayName = objName + '_' + fnName;\n      return wrapper;\n    }\n    return func;\n  },\n\n  injection: {\n    /**\n     * @param {function} measure\n     */\n    injectMeasure: function(measure) {\n      ReactPerf.storedMeasure = measure;\n    }\n  }\n};\n\n/**\n * Simply passes through the measured function, without measuring it.\n *\n * @param {string} objName\n * @param {string} fnName\n * @param {function} func\n * @return {function}\n */\nfunction _noMeasure(objName, fnName, func) {\n  return func;\n}\n\nmodule.exports = ReactPerf;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactPerf.js\n ** module id = 17\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactPerf.js?")},/*!***************************************!*\
  !*** ./~/react/lib/SyntheticEvent.js ***!
  \***************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar PooledClass = __webpack_require__(/*! ./PooledClass */ 12);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar emptyFunction = __webpack_require__(/*! ./emptyFunction */ 10);\nvar getEventTarget = __webpack_require__(/*! ./getEventTarget */ 61);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: getEventTarget,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: emptyFunction.thatReturnsNull,\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function(event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n */\nfunction SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  this.dispatchConfig = dispatchConfig;\n  this.dispatchMarker = dispatchMarker;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      this[propName] = nativeEvent[propName];\n    }\n  }\n\n  var defaultPrevented = nativeEvent.defaultPrevented != null ?\n    nativeEvent.defaultPrevented :\n    nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;\n  }\n  this.isPropagationStopped = emptyFunction.thatReturnsFalse;\n}\n\nassign(SyntheticEvent.prototype, {\n\n  preventDefault: function() {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  },\n\n  stopPropagation: function() {\n    var event = this.nativeEvent;\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else {\n      event.cancelBubble = true;\n    }\n    this.isPropagationStopped = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function() {\n    this.isPersistent = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: emptyFunction.thatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function() {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      this[propName] = null;\n    }\n    this.dispatchConfig = null;\n    this.dispatchMarker = null;\n    this.nativeEvent = null;\n  }\n\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n *\n * @param {function} Class\n * @param {?object} Interface\n */\nSyntheticEvent.augmentClass = function(Class, Interface) {\n  var Super = this;\n\n  var prototype = Object.create(Super.prototype);\n  assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = assign({}, Super.Interface, Interface);\n  Class.augmentClass = Super.augmentClass;\n\n  PooledClass.addPoolingTo(Class, PooledClass.threeArgumentPooler);\n};\n\nPooledClass.addPoolingTo(SyntheticEvent, PooledClass.threeArgumentPooler);\n\nmodule.exports = SyntheticEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticEvent.js\n ** module id = 18\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticEvent.js?")},/*!************************************!*\
  !*** ./~/react/lib/DOMProperty.js ***!
  \************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DOMProperty\n * @typechecks static-only\n */\n\n/*jslint bitwise: true */\n\n'use strict';\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\nfunction checkMask(value, bitmask) {\n  return (value & bitmask) === bitmask;\n}\n\nvar DOMPropertyInjection = {\n  /**\n   * Mapping from normalized, camelcased property names to a configuration that\n   * specifies how the associated DOM property should be accessed or rendered.\n   */\n  MUST_USE_ATTRIBUTE: 0x1,\n  MUST_USE_PROPERTY: 0x2,\n  HAS_SIDE_EFFECTS: 0x4,\n  HAS_BOOLEAN_VALUE: 0x8,\n  HAS_NUMERIC_VALUE: 0x10,\n  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,\n  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,\n\n  /**\n   * Inject some specialized knowledge about the DOM. This takes a config object\n   * with the following properties:\n   *\n   * isCustomAttribute: function that given an attribute name will return true\n   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*\n   * attributes where it's impossible to enumerate all of the possible\n   * attribute names,\n   *\n   * Properties: object mapping DOM property name to one of the\n   * DOMPropertyInjection constants or null. If your attribute isn't in here,\n   * it won't get written to the DOM.\n   *\n   * DOMAttributeNames: object mapping React attribute name to the DOM\n   * attribute name. Attribute names not specified use the **lowercase**\n   * normalized name.\n   *\n   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.\n   * Property names not specified use the normalized name.\n   *\n   * DOMMutationMethods: Properties that require special mutation methods. If\n   * `value` is undefined, the mutation method should unset the property.\n   *\n   * @param {object} domPropertyConfig the config as described above.\n   */\n  injectDOMPropertyConfig: function(domPropertyConfig) {\n    var Properties = domPropertyConfig.Properties || {};\n    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};\n    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};\n    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};\n\n    if (domPropertyConfig.isCustomAttribute) {\n      DOMProperty._isCustomAttributeFunctions.push(\n        domPropertyConfig.isCustomAttribute\n      );\n    }\n\n    for (var propName in Properties) {\n      (false ? invariant(\n        !DOMProperty.isStandardName.hasOwnProperty(propName),\n        'injectDOMPropertyConfig(...): You\\'re trying to inject DOM property ' +\n        '\\'%s\\' which has already been injected. You may be accidentally ' +\n        'injecting the same DOM property config twice, or you may be ' +\n        'injecting two configs that have conflicting property names.',\n        propName\n      ) : invariant(!DOMProperty.isStandardName.hasOwnProperty(propName)));\n\n      DOMProperty.isStandardName[propName] = true;\n\n      var lowerCased = propName.toLowerCase();\n      DOMProperty.getPossibleStandardName[lowerCased] = propName;\n\n      if (DOMAttributeNames.hasOwnProperty(propName)) {\n        var attributeName = DOMAttributeNames[propName];\n        DOMProperty.getPossibleStandardName[attributeName] = propName;\n        DOMProperty.getAttributeName[propName] = attributeName;\n      } else {\n        DOMProperty.getAttributeName[propName] = lowerCased;\n      }\n\n      DOMProperty.getPropertyName[propName] =\n        DOMPropertyNames.hasOwnProperty(propName) ?\n          DOMPropertyNames[propName] :\n          propName;\n\n      if (DOMMutationMethods.hasOwnProperty(propName)) {\n        DOMProperty.getMutationMethod[propName] = DOMMutationMethods[propName];\n      } else {\n        DOMProperty.getMutationMethod[propName] = null;\n      }\n\n      var propConfig = Properties[propName];\n      DOMProperty.mustUseAttribute[propName] =\n        checkMask(propConfig, DOMPropertyInjection.MUST_USE_ATTRIBUTE);\n      DOMProperty.mustUseProperty[propName] =\n        checkMask(propConfig, DOMPropertyInjection.MUST_USE_PROPERTY);\n      DOMProperty.hasSideEffects[propName] =\n        checkMask(propConfig, DOMPropertyInjection.HAS_SIDE_EFFECTS);\n      DOMProperty.hasBooleanValue[propName] =\n        checkMask(propConfig, DOMPropertyInjection.HAS_BOOLEAN_VALUE);\n      DOMProperty.hasNumericValue[propName] =\n        checkMask(propConfig, DOMPropertyInjection.HAS_NUMERIC_VALUE);\n      DOMProperty.hasPositiveNumericValue[propName] =\n        checkMask(propConfig, DOMPropertyInjection.HAS_POSITIVE_NUMERIC_VALUE);\n      DOMProperty.hasOverloadedBooleanValue[propName] =\n        checkMask(propConfig, DOMPropertyInjection.HAS_OVERLOADED_BOOLEAN_VALUE);\n\n      (false ? invariant(\n        !DOMProperty.mustUseAttribute[propName] ||\n          !DOMProperty.mustUseProperty[propName],\n        'DOMProperty: Cannot require using both attribute and property: %s',\n        propName\n      ) : invariant(!DOMProperty.mustUseAttribute[propName] ||\n        !DOMProperty.mustUseProperty[propName]));\n      (false ? invariant(\n        DOMProperty.mustUseProperty[propName] ||\n          !DOMProperty.hasSideEffects[propName],\n        'DOMProperty: Properties that have side effects must use property: %s',\n        propName\n      ) : invariant(DOMProperty.mustUseProperty[propName] ||\n        !DOMProperty.hasSideEffects[propName]));\n      (false ? invariant(\n        !!DOMProperty.hasBooleanValue[propName] +\n          !!DOMProperty.hasNumericValue[propName] +\n          !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1,\n        'DOMProperty: Value can be one of boolean, overloaded boolean, or ' +\n        'numeric value, but not a combination: %s',\n        propName\n      ) : invariant(!!DOMProperty.hasBooleanValue[propName] +\n        !!DOMProperty.hasNumericValue[propName] +\n        !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1));\n    }\n  }\n};\nvar defaultValueCache = {};\n\n/**\n * DOMProperty exports lookup objects that can be used like functions:\n *\n *   > DOMProperty.isValid['id']\n *   true\n *   > DOMProperty.isValid['foobar']\n *   undefined\n *\n * Although this may be confusing, it performs better in general.\n *\n * @see http://jsperf.com/key-exists\n * @see http://jsperf.com/key-missing\n */\nvar DOMProperty = {\n\n  ID_ATTRIBUTE_NAME: 'data-reactid',\n\n  /**\n   * Checks whether a property name is a standard property.\n   * @type {Object}\n   */\n  isStandardName: {},\n\n  /**\n   * Mapping from lowercase property names to the properly cased version, used\n   * to warn in the case of missing properties.\n   * @type {Object}\n   */\n  getPossibleStandardName: {},\n\n  /**\n   * Mapping from normalized names to attribute names that differ. Attribute\n   * names are used when rendering markup or with `*Attribute()`.\n   * @type {Object}\n   */\n  getAttributeName: {},\n\n  /**\n   * Mapping from normalized names to properties on DOM node instances.\n   * (This includes properties that mutate due to external factors.)\n   * @type {Object}\n   */\n  getPropertyName: {},\n\n  /**\n   * Mapping from normalized names to mutation methods. This will only exist if\n   * mutation cannot be set simply by the property or `setAttribute()`.\n   * @type {Object}\n   */\n  getMutationMethod: {},\n\n  /**\n   * Whether the property must be accessed and mutated as an object property.\n   * @type {Object}\n   */\n  mustUseAttribute: {},\n\n  /**\n   * Whether the property must be accessed and mutated using `*Attribute()`.\n   * (This includes anything that fails `<propName> in <element>`.)\n   * @type {Object}\n   */\n  mustUseProperty: {},\n\n  /**\n   * Whether or not setting a value causes side effects such as triggering\n   * resources to be loaded or text selection changes. We must ensure that\n   * the value is only set if it has changed.\n   * @type {Object}\n   */\n  hasSideEffects: {},\n\n  /**\n   * Whether the property should be removed when set to a falsey value.\n   * @type {Object}\n   */\n  hasBooleanValue: {},\n\n  /**\n   * Whether the property must be numeric or parse as a\n   * numeric and should be removed when set to a falsey value.\n   * @type {Object}\n   */\n  hasNumericValue: {},\n\n  /**\n   * Whether the property must be positive numeric or parse as a positive\n   * numeric and should be removed when set to a falsey value.\n   * @type {Object}\n   */\n  hasPositiveNumericValue: {},\n\n  /**\n   * Whether the property can be used as a flag as well as with a value. Removed\n   * when strictly equal to false; present without a value when strictly equal\n   * to true; present with a value otherwise.\n   * @type {Object}\n   */\n  hasOverloadedBooleanValue: {},\n\n  /**\n   * All of the isCustomAttribute() functions that have been injected.\n   */\n  _isCustomAttributeFunctions: [],\n\n  /**\n   * Checks whether a property name is a custom attribute.\n   * @method\n   */\n  isCustomAttribute: function(attributeName) {\n    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {\n      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];\n      if (isCustomAttributeFn(attributeName)) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Returns the default property value for a DOM property (i.e., not an\n   * attribute). Most default values are '' or false, but not all. Worse yet,\n   * some (in particular, `type`) vary depending on the type of element.\n   *\n   * TODO: Is it better to grab all the possible properties when creating an\n   * element to avoid having to create the same element twice?\n   */\n  getDefaultValueForProperty: function(nodeName, prop) {\n    var nodeDefaults = defaultValueCache[nodeName];\n    var testElement;\n    if (!nodeDefaults) {\n      defaultValueCache[nodeName] = nodeDefaults = {};\n    }\n    if (!(prop in nodeDefaults)) {\n      testElement = document.createElement(nodeName);\n      nodeDefaults[prop] = testElement[prop];\n    }\n    return nodeDefaults[prop];\n  },\n\n  injection: DOMPropertyInjection\n};\n\nmodule.exports = DOMProperty;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/DOMProperty.js\n ** module id = 19\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/DOMProperty.js?")},/*!******************************!*\
  !*** ./~/react/lib/React.js ***!
  \******************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule React\n */\n\n/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/\n\n'use strict';\n\nvar EventPluginUtils = __webpack_require__(/*! ./EventPluginUtils */ 46);\nvar ReactChildren = __webpack_require__(/*! ./ReactChildren */ 74);\nvar ReactComponent = __webpack_require__(/*! ./ReactComponent */ 75);\nvar ReactClass = __webpack_require__(/*! ./ReactClass */ 8);\nvar ReactContext = __webpack_require__(/*! ./ReactContext */ 51);\nvar ReactCurrentOwner = __webpack_require__(/*! ./ReactCurrentOwner */ 14);\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\nvar ReactElementValidator = __webpack_require__(/*! ./ReactElementValidator */ 32);\nvar ReactDOM = __webpack_require__(/*! ./ReactDOM */ 141);\nvar ReactDOMTextComponent = __webpack_require__(/*! ./ReactDOMTextComponent */ 77);\nvar ReactDefaultInjection = __webpack_require__(/*! ./ReactDefaultInjection */ 152);\nvar ReactInstanceHandles = __webpack_require__(/*! ./ReactInstanceHandles */ 23);\nvar ReactMount = __webpack_require__(/*! ./ReactMount */ 15);\nvar ReactPerf = __webpack_require__(/*! ./ReactPerf */ 17);\nvar ReactPropTypes = __webpack_require__(/*! ./ReactPropTypes */ 81);\nvar ReactReconciler = __webpack_require__(/*! ./ReactReconciler */ 25);\nvar ReactServerRendering = __webpack_require__(/*! ./ReactServerRendering */ 163);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar findDOMNode = __webpack_require__(/*! ./findDOMNode */ 88);\nvar onlyChild = __webpack_require__(/*! ./onlyChild */ 96);\n\nReactDefaultInjection.inject();\n\nvar createElement = ReactElement.createElement;\nvar createFactory = ReactElement.createFactory;\nvar cloneElement = ReactElement.cloneElement;\n\nif (false) {\n  createElement = ReactElementValidator.createElement;\n  createFactory = ReactElementValidator.createFactory;\n  cloneElement = ReactElementValidator.cloneElement;\n}\n\nvar render = ReactPerf.measure('React', 'render', ReactMount.render);\n\nvar React = {\n  Children: {\n    map: ReactChildren.map,\n    forEach: ReactChildren.forEach,\n    count: ReactChildren.count,\n    only: onlyChild\n  },\n  Component: ReactComponent,\n  DOM: ReactDOM,\n  PropTypes: ReactPropTypes,\n  initializeTouchEvents: function(shouldUseTouch) {\n    EventPluginUtils.useTouchEvents = shouldUseTouch;\n  },\n  createClass: ReactClass.createClass,\n  createElement: createElement,\n  cloneElement: cloneElement,\n  createFactory: createFactory,\n  createMixin: function(mixin) {\n    // Currently a noop. Will be used to validate and trace mixins.\n    return mixin;\n  },\n  constructAndRenderComponent: ReactMount.constructAndRenderComponent,\n  constructAndRenderComponentByID: ReactMount.constructAndRenderComponentByID,\n  findDOMNode: findDOMNode,\n  render: render,\n  renderToString: ReactServerRendering.renderToString,\n  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,\n  unmountComponentAtNode: ReactMount.unmountComponentAtNode,\n  isValidElement: ReactElement.isValidElement,\n  withContext: ReactContext.withContext,\n\n  // Hook for JSX spread, don't use this for anything else.\n  __spread: assign\n};\n\n// Inject the runtime into a devtools global hook regardless of browser.\n// Allows for debugging when the hook is injected on the page.\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({\n    CurrentOwner: ReactCurrentOwner,\n    InstanceHandles: ReactInstanceHandles,\n    Mount: ReactMount,\n    Reconciler: ReactReconciler,\n    TextComponent: ReactDOMTextComponent\n  });\n}\n\nif (false) {\n  var ExecutionEnvironment = require(\"./ExecutionEnvironment\");\n  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {\n\n    // If we're in Chrome, look for the devtools marker and provide a download\n    // link if not installed.\n    if (navigator.userAgent.indexOf('Chrome') > -1) {\n      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n        console.debug(\n          'Download the React DevTools for a better development experience: ' +\n          'https://fb.me/react-devtools'\n        );\n      }\n    }\n\n    var expectedFeatures = [\n      // shims\n      Array.isArray,\n      Array.prototype.every,\n      Array.prototype.forEach,\n      Array.prototype.indexOf,\n      Array.prototype.map,\n      Date.now,\n      Function.prototype.bind,\n      Object.keys,\n      String.prototype.split,\n      String.prototype.trim,\n\n      // shams\n      Object.create,\n      Object.freeze\n    ];\n\n    for (var i = 0; i < expectedFeatures.length; i++) {\n      if (!expectedFeatures[i]) {\n        console.error(\n          'One or more ES5 shim/shams expected by React are not available: ' +\n          'https://fb.me/react-warning-polyfills'\n        );\n        break;\n      }\n    }\n  }\n}\n\nReact.version = '0.13.3';\n\nmodule.exports = React;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/React.js\n ** module id = 20\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/React.js?")},/*!*************************************************!*\
  !*** ./~/react/lib/ReactBrowserEventEmitter.js ***!
  \*************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactBrowserEventEmitter\n * @typechecks static-only\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(/*! ./EventConstants */ 7);\nvar EventPluginHub = __webpack_require__(/*! ./EventPluginHub */ 30);\nvar EventPluginRegistry = __webpack_require__(/*! ./EventPluginRegistry */ 73);\nvar ReactEventEmitterMixin = __webpack_require__(/*! ./ReactEventEmitterMixin */ 154);\nvar ViewportMetrics = __webpack_require__(/*! ./ViewportMetrics */ 85);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar isEventSupported = __webpack_require__(/*! ./isEventSupported */ 63);\n\n/**\n * Summary of `ReactBrowserEventEmitter` event handling:\n *\n *  - Top-level delegation is used to trap most native browser events. This\n *    may only occur in the main thread and is the responsibility of\n *    ReactEventListener, which is injected and can therefore support pluggable\n *    event sources. This is the only work that occurs in the main thread.\n *\n *  - We normalize and de-duplicate events to account for browser quirks. This\n *    may be done in the worker thread.\n *\n *  - Forward these native events (with the associated top-level type used to\n *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\n *    to extract any synthetic events.\n *\n *  - The `EventPluginHub` will then process each event by annotating them with\n *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n *\n *  - The `EventPluginHub` then dispatches the events.\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */\n\nvar alreadyListeningTo = {};\nvar isMonitoringScrollValue = false;\nvar reactTopListenersCounter = 0;\n\n// For events like 'submit' which don't consistently bubble (which we trap at a\n// lower node than `document`), binding at `document` would cause duplicate\n// events so we don't include them here\nvar topEventMapping = {\n  topBlur: 'blur',\n  topChange: 'change',\n  topClick: 'click',\n  topCompositionEnd: 'compositionend',\n  topCompositionStart: 'compositionstart',\n  topCompositionUpdate: 'compositionupdate',\n  topContextMenu: 'contextmenu',\n  topCopy: 'copy',\n  topCut: 'cut',\n  topDoubleClick: 'dblclick',\n  topDrag: 'drag',\n  topDragEnd: 'dragend',\n  topDragEnter: 'dragenter',\n  topDragExit: 'dragexit',\n  topDragLeave: 'dragleave',\n  topDragOver: 'dragover',\n  topDragStart: 'dragstart',\n  topDrop: 'drop',\n  topFocus: 'focus',\n  topInput: 'input',\n  topKeyDown: 'keydown',\n  topKeyPress: 'keypress',\n  topKeyUp: 'keyup',\n  topMouseDown: 'mousedown',\n  topMouseMove: 'mousemove',\n  topMouseOut: 'mouseout',\n  topMouseOver: 'mouseover',\n  topMouseUp: 'mouseup',\n  topPaste: 'paste',\n  topScroll: 'scroll',\n  topSelectionChange: 'selectionchange',\n  topTextInput: 'textInput',\n  topTouchCancel: 'touchcancel',\n  topTouchEnd: 'touchend',\n  topTouchMove: 'touchmove',\n  topTouchStart: 'touchstart',\n  topWheel: 'wheel'\n};\n\n/**\n * To ensure no conflicts with other potential React instances on the page\n */\nvar topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);\n\nfunction getListeningForDocument(mountAt) {\n  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`\n  // directly.\n  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {\n    mountAt[topListenersIDKey] = reactTopListenersCounter++;\n    alreadyListeningTo[mountAt[topListenersIDKey]] = {};\n  }\n  return alreadyListeningTo[mountAt[topListenersIDKey]];\n}\n\n/**\n * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For\n * example:\n *\n *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);\n *\n * This would allocate a \"registration\" of `('onClick', myFunction)` on 'myID'.\n *\n * @internal\n */\nvar ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {\n\n  /**\n   * Injectable event backend\n   */\n  ReactEventListener: null,\n\n  injection: {\n    /**\n     * @param {object} ReactEventListener\n     */\n    injectReactEventListener: function(ReactEventListener) {\n      ReactEventListener.setHandleTopLevel(\n        ReactBrowserEventEmitter.handleTopLevel\n      );\n      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;\n    }\n  },\n\n  /**\n   * Sets whether or not any created callbacks should be enabled.\n   *\n   * @param {boolean} enabled True if callbacks should be enabled.\n   */\n  setEnabled: function(enabled) {\n    if (ReactBrowserEventEmitter.ReactEventListener) {\n      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);\n    }\n  },\n\n  /**\n   * @return {boolean} True if callbacks are enabled.\n   */\n  isEnabled: function() {\n    return !!(\n      (ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled())\n    );\n  },\n\n  /**\n   * We listen for bubbled touch events on the document object.\n   *\n   * Firefox v8.01 (and possibly others) exhibited strange behavior when\n   * mounting `onmousemove` events at some node that was not the document\n   * element. The symptoms were that if your mouse is not moving over something\n   * contained within that mount point (for example on the background) the\n   * top-level listeners for `onmousemove` won't be called. However, if you\n   * register the `mousemove` on the document object, then it will of course\n   * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n   * top-level listeners to the document object only, at least for these\n   * movement types of events and possibly all events.\n   *\n   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n   *\n   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n   * they bubble to document.\n   *\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   * @param {object} contentDocumentHandle Document which owns the container\n   */\n  listenTo: function(registrationName, contentDocumentHandle) {\n    var mountAt = contentDocumentHandle;\n    var isListening = getListeningForDocument(mountAt);\n    var dependencies = EventPluginRegistry.\n      registrationNameDependencies[registrationName];\n\n    var topLevelTypes = EventConstants.topLevelTypes;\n    for (var i = 0, l = dependencies.length; i < l; i++) {\n      var dependency = dependencies[i];\n      if (!(\n            (isListening.hasOwnProperty(dependency) && isListening[dependency])\n          )) {\n        if (dependency === topLevelTypes.topWheel) {\n          if (isEventSupported('wheel')) {\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(\n              topLevelTypes.topWheel,\n              'wheel',\n              mountAt\n            );\n          } else if (isEventSupported('mousewheel')) {\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(\n              topLevelTypes.topWheel,\n              'mousewheel',\n              mountAt\n            );\n          } else {\n            // Firefox needs to capture a different mouse scroll event.\n            // @see http://www.quirksmode.org/dom/events/tests/scroll.html\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(\n              topLevelTypes.topWheel,\n              'DOMMouseScroll',\n              mountAt\n            );\n          }\n        } else if (dependency === topLevelTypes.topScroll) {\n\n          if (isEventSupported('scroll', true)) {\n            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(\n              topLevelTypes.topScroll,\n              'scroll',\n              mountAt\n            );\n          } else {\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(\n              topLevelTypes.topScroll,\n              'scroll',\n              ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE\n            );\n          }\n        } else if (dependency === topLevelTypes.topFocus ||\n            dependency === topLevelTypes.topBlur) {\n\n          if (isEventSupported('focus', true)) {\n            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(\n              topLevelTypes.topFocus,\n              'focus',\n              mountAt\n            );\n            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(\n              topLevelTypes.topBlur,\n              'blur',\n              mountAt\n            );\n          } else if (isEventSupported('focusin')) {\n            // IE has `focusin` and `focusout` events which bubble.\n            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(\n              topLevelTypes.topFocus,\n              'focusin',\n              mountAt\n            );\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(\n              topLevelTypes.topBlur,\n              'focusout',\n              mountAt\n            );\n          }\n\n          // to make sure blur and focus event listeners are only attached once\n          isListening[topLevelTypes.topBlur] = true;\n          isListening[topLevelTypes.topFocus] = true;\n        } else if (topEventMapping.hasOwnProperty(dependency)) {\n          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(\n            dependency,\n            topEventMapping[dependency],\n            mountAt\n          );\n        }\n\n        isListening[dependency] = true;\n      }\n    }\n  },\n\n  trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {\n    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(\n      topLevelType,\n      handlerBaseName,\n      handle\n    );\n  },\n\n  trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {\n    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(\n      topLevelType,\n      handlerBaseName,\n      handle\n    );\n  },\n\n  /**\n   * Listens to window scroll and resize events. We cache scroll values so that\n   * application code can access them without triggering reflows.\n   *\n   * NOTE: Scroll events do not bubble.\n   *\n   * @see http://www.quirksmode.org/dom/events/scroll.html\n   */\n  ensureScrollValueMonitoring: function() {\n    if (!isMonitoringScrollValue) {\n      var refresh = ViewportMetrics.refreshScrollValues;\n      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);\n      isMonitoringScrollValue = true;\n    }\n  },\n\n  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,\n\n  registrationNameModules: EventPluginHub.registrationNameModules,\n\n  putListener: EventPluginHub.putListener,\n\n  getListener: EventPluginHub.getListener,\n\n  deleteListener: EventPluginHub.deleteListener,\n\n  deleteAllListeners: EventPluginHub.deleteAllListeners\n\n});\n\nmodule.exports = ReactBrowserEventEmitter;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactBrowserEventEmitter.js\n ** module id = 21\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactBrowserEventEmitter.js?")},/*!**************************************!*\
  !*** ./~/react/lib/ReactFragment.js ***!
  \**************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n* @providesModule ReactFragment\n*/\n\n'use strict';\n\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\n\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\n/**\n * We used to allow keyed objects to serve as a collection of ReactElements,\n * or nested sets. This allowed us a way to explicitly key a set a fragment of\n * components. This is now being replaced with an opaque data structure.\n * The upgrade path is to call React.addons.createFragment({ key: value }) to\n * create a keyed fragment. The resulting data structure is opaque, for now.\n */\n\nif (false) {\n  var fragmentKey = '_reactFragment';\n  var didWarnKey = '_reactDidWarn';\n  var canWarnForReactFragment = false;\n\n  try {\n    // Feature test. Don't even try to issue this warning if we can't use\n    // enumerable: false.\n\n    var dummy = function() {\n      return 1;\n    };\n\n    Object.defineProperty(\n      {},\n      fragmentKey,\n      {enumerable: false, value: true}\n    );\n\n    Object.defineProperty(\n      {},\n      'key',\n      {enumerable: true, get: dummy}\n    );\n\n    canWarnForReactFragment = true;\n  } catch (x) { }\n\n  var proxyPropertyAccessWithWarning = function(obj, key) {\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      get: function() {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          this[didWarnKey],\n          'A ReactFragment is an opaque type. Accessing any of its ' +\n          'properties is deprecated. Pass it to one of the React.Children ' +\n          'helpers.'\n        ) : null);\n        this[didWarnKey] = true;\n        return this[fragmentKey][key];\n      },\n      set: function(value) {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          this[didWarnKey],\n          'A ReactFragment is an immutable opaque type. Mutating its ' +\n          'properties is deprecated.'\n        ) : null);\n        this[didWarnKey] = true;\n        this[fragmentKey][key] = value;\n      }\n    });\n  };\n\n  var issuedWarnings = {};\n\n  var didWarnForFragment = function(fragment) {\n    // We use the keys and the type of the value as a heuristic to dedupe the\n    // warning to avoid spamming too much.\n    var fragmentCacheKey = '';\n    for (var key in fragment) {\n      fragmentCacheKey += key + ':' + (typeof fragment[key]) + ',';\n    }\n    var alreadyWarnedOnce = !!issuedWarnings[fragmentCacheKey];\n    issuedWarnings[fragmentCacheKey] = true;\n    return alreadyWarnedOnce;\n  };\n}\n\nvar ReactFragment = {\n  // Wrap a keyed object in an opaque proxy that warns you if you access any\n  // of its properties.\n  create: function(object) {\n    if (false) {\n      if (typeof object !== 'object' || !object || Array.isArray(object)) {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          false,\n          'React.addons.createFragment only accepts a single object.',\n          object\n        ) : null);\n        return object;\n      }\n      if (ReactElement.isValidElement(object)) {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          false,\n          'React.addons.createFragment does not accept a ReactElement ' +\n          'without a wrapper object.'\n        ) : null);\n        return object;\n      }\n      if (canWarnForReactFragment) {\n        var proxy = {};\n        Object.defineProperty(proxy, fragmentKey, {\n          enumerable: false,\n          value: object\n        });\n        Object.defineProperty(proxy, didWarnKey, {\n          writable: true,\n          enumerable: false,\n          value: false\n        });\n        for (var key in object) {\n          proxyPropertyAccessWithWarning(proxy, key);\n        }\n        Object.preventExtensions(proxy);\n        return proxy;\n      }\n    }\n    return object;\n  },\n  // Extract the original keyed object from the fragment opaque type. Warn if\n  // a plain object is passed here.\n  extract: function(fragment) {\n    if (false) {\n      if (canWarnForReactFragment) {\n        if (!fragment[fragmentKey]) {\n          (\"production\" !== process.env.NODE_ENV ? warning(\n            didWarnForFragment(fragment),\n            'Any use of a keyed object should be wrapped in ' +\n            'React.addons.createFragment(object) before being passed as a ' +\n            'child.'\n          ) : null);\n          return fragment;\n        }\n        return fragment[fragmentKey];\n      }\n    }\n    return fragment;\n  },\n  // Check if this is a fragment and if so, extract the keyed object. If it\n  // is a fragment-like object, warn that it should be wrapped. Ignore if we\n  // can't determine what kind of object this is.\n  extractIfFragment: function(fragment) {\n    if (false) {\n      if (canWarnForReactFragment) {\n        // If it is the opaque type, return the keyed object.\n        if (fragment[fragmentKey]) {\n          return fragment[fragmentKey];\n        }\n        // Otherwise, check each property if it has an element, if it does\n        // it is probably meant as a fragment, so we can warn early. Defer,\n        // the warning to extract.\n        for (var key in fragment) {\n          if (fragment.hasOwnProperty(key) &&\n              ReactElement.isValidElement(fragment[key])) {\n            // This looks like a fragment object, we should provide an\n            // early warning.\n            return ReactFragment.extract(fragment);\n          }\n        }\n      }\n    }\n    return fragment;\n  }\n};\n\nmodule.exports = ReactFragment;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactFragment.js\n ** module id = 22\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactFragment.js?")},/*!*********************************************!*\
  !*** ./~/react/lib/ReactInstanceHandles.js ***!
  \*********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactInstanceHandles\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactRootIndex = __webpack_require__(/*! ./ReactRootIndex */ 83);\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\nvar SEPARATOR = '.';\nvar SEPARATOR_LENGTH = SEPARATOR.length;\n\n/**\n * Maximum depth of traversals before we consider the possibility of a bad ID.\n */\nvar MAX_TREE_DEPTH = 100;\n\n/**\n * Creates a DOM ID prefix to use when mounting React components.\n *\n * @param {number} index A unique integer\n * @return {string} React root ID.\n * @internal\n */\nfunction getReactRootIDString(index) {\n  return SEPARATOR + index.toString(36);\n}\n\n/**\n * Checks if a character in the supplied ID is a separator or the end.\n *\n * @param {string} id A React DOM ID.\n * @param {number} index Index of the character to check.\n * @return {boolean} True if the character is a separator or end of the ID.\n * @private\n */\nfunction isBoundary(id, index) {\n  return id.charAt(index) === SEPARATOR || index === id.length;\n}\n\n/**\n * Checks if the supplied string is a valid React DOM ID.\n *\n * @param {string} id A React DOM ID, maybe.\n * @return {boolean} True if the string is a valid React DOM ID.\n * @private\n */\nfunction isValidID(id) {\n  return id === '' || (\n    id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR\n  );\n}\n\n/**\n * Checks if the first ID is an ancestor of or equal to the second ID.\n *\n * @param {string} ancestorID\n * @param {string} descendantID\n * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.\n * @internal\n */\nfunction isAncestorIDOf(ancestorID, descendantID) {\n  return (\n    descendantID.indexOf(ancestorID) === 0 &&\n    isBoundary(descendantID, ancestorID.length)\n  );\n}\n\n/**\n * Gets the parent ID of the supplied React DOM ID, `id`.\n *\n * @param {string} id ID of a component.\n * @return {string} ID of the parent, or an empty string.\n * @private\n */\nfunction getParentID(id) {\n  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';\n}\n\n/**\n * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the\n * supplied `destinationID`. If they are equal, the ID is returned.\n *\n * @param {string} ancestorID ID of an ancestor node of `destinationID`.\n * @param {string} destinationID ID of the destination node.\n * @return {string} Next ID on the path from `ancestorID` to `destinationID`.\n * @private\n */\nfunction getNextDescendantID(ancestorID, destinationID) {\n  (false ? invariant(\n    isValidID(ancestorID) && isValidID(destinationID),\n    'getNextDescendantID(%s, %s): Received an invalid React DOM ID.',\n    ancestorID,\n    destinationID\n  ) : invariant(isValidID(ancestorID) && isValidID(destinationID)));\n  (false ? invariant(\n    isAncestorIDOf(ancestorID, destinationID),\n    'getNextDescendantID(...): React has made an invalid assumption about ' +\n    'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.',\n    ancestorID,\n    destinationID\n  ) : invariant(isAncestorIDOf(ancestorID, destinationID)));\n  if (ancestorID === destinationID) {\n    return ancestorID;\n  }\n  // Skip over the ancestor and the immediate separator. Traverse until we hit\n  // another separator or we reach the end of `destinationID`.\n  var start = ancestorID.length + SEPARATOR_LENGTH;\n  var i;\n  for (i = start; i < destinationID.length; i++) {\n    if (isBoundary(destinationID, i)) {\n      break;\n    }\n  }\n  return destinationID.substr(0, i);\n}\n\n/**\n * Gets the nearest common ancestor ID of two IDs.\n *\n * Using this ID scheme, the nearest common ancestor ID is the longest common\n * prefix of the two IDs that immediately preceded a \"marker\" in both strings.\n *\n * @param {string} oneID\n * @param {string} twoID\n * @return {string} Nearest common ancestor ID, or the empty string if none.\n * @private\n */\nfunction getFirstCommonAncestorID(oneID, twoID) {\n  var minLength = Math.min(oneID.length, twoID.length);\n  if (minLength === 0) {\n    return '';\n  }\n  var lastCommonMarkerIndex = 0;\n  // Use `<=` to traverse until the \"EOL\" of the shorter string.\n  for (var i = 0; i <= minLength; i++) {\n    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {\n      lastCommonMarkerIndex = i;\n    } else if (oneID.charAt(i) !== twoID.charAt(i)) {\n      break;\n    }\n  }\n  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);\n  (false ? invariant(\n    isValidID(longestCommonID),\n    'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s',\n    oneID,\n    twoID,\n    longestCommonID\n  ) : invariant(isValidID(longestCommonID)));\n  return longestCommonID;\n}\n\n/**\n * Traverses the parent path between two IDs (either up or down). The IDs must\n * not be the same, and there must exist a parent path between them. If the\n * callback returns `false`, traversal is stopped.\n *\n * @param {?string} start ID at which to start traversal.\n * @param {?string} stop ID at which to end traversal.\n * @param {function} cb Callback to invoke each ID with.\n * @param {?boolean} skipFirst Whether or not to skip the first node.\n * @param {?boolean} skipLast Whether or not to skip the last node.\n * @private\n */\nfunction traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {\n  start = start || '';\n  stop = stop || '';\n  (false ? invariant(\n    start !== stop,\n    'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.',\n    start\n  ) : invariant(start !== stop));\n  var traverseUp = isAncestorIDOf(stop, start);\n  (false ? invariant(\n    traverseUp || isAncestorIDOf(start, stop),\n    'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' +\n    'not have a parent path.',\n    start,\n    stop\n  ) : invariant(traverseUp || isAncestorIDOf(start, stop)));\n  // Traverse from `start` to `stop` one depth at a time.\n  var depth = 0;\n  var traverse = traverseUp ? getParentID : getNextDescendantID;\n  for (var id = start; /* until break */; id = traverse(id, stop)) {\n    var ret;\n    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {\n      ret = cb(id, traverseUp, arg);\n    }\n    if (ret === false || id === stop) {\n      // Only break //after// visiting `stop`.\n      break;\n    }\n    (false ? invariant(\n      depth++ < MAX_TREE_DEPTH,\n      'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' +\n      'traversing the React DOM ID tree. This may be due to malformed IDs: %s',\n      start, stop\n    ) : invariant(depth++ < MAX_TREE_DEPTH));\n  }\n}\n\n/**\n * Manages the IDs assigned to DOM representations of React components. This\n * uses a specific scheme in order to traverse the DOM efficiently (e.g. in\n * order to simulate events).\n *\n * @internal\n */\nvar ReactInstanceHandles = {\n\n  /**\n   * Constructs a React root ID\n   * @return {string} A React root ID.\n   */\n  createReactRootID: function() {\n    return getReactRootIDString(ReactRootIndex.createReactRootIndex());\n  },\n\n  /**\n   * Constructs a React ID by joining a root ID with a name.\n   *\n   * @param {string} rootID Root ID of a parent component.\n   * @param {string} name A component's name (as flattened children).\n   * @return {string} A React ID.\n   * @internal\n   */\n  createReactID: function(rootID, name) {\n    return rootID + name;\n  },\n\n  /**\n   * Gets the DOM ID of the React component that is the root of the tree that\n   * contains the React component with the supplied DOM ID.\n   *\n   * @param {string} id DOM ID of a React component.\n   * @return {?string} DOM ID of the React component that is the root.\n   * @internal\n   */\n  getReactRootIDFromNodeID: function(id) {\n    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {\n      var index = id.indexOf(SEPARATOR, 1);\n      return index > -1 ? id.substr(0, index) : id;\n    }\n    return null;\n  },\n\n  /**\n   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n   * should would receive a `mouseEnter` or `mouseLeave` event.\n   *\n   * NOTE: Does not invoke the callback on the nearest common ancestor because\n   * nothing \"entered\" or \"left\" that element.\n   *\n   * @param {string} leaveID ID being left.\n   * @param {string} enterID ID being entered.\n   * @param {function} cb Callback to invoke on each entered/left ID.\n   * @param {*} upArg Argument to invoke the callback with on left IDs.\n   * @param {*} downArg Argument to invoke the callback with on entered IDs.\n   * @internal\n   */\n  traverseEnterLeave: function(leaveID, enterID, cb, upArg, downArg) {\n    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);\n    if (ancestorID !== leaveID) {\n      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);\n    }\n    if (ancestorID !== enterID) {\n      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);\n    }\n  },\n\n  /**\n   * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n   *\n   * NOTE: This traversal happens on IDs without touching the DOM.\n   *\n   * @param {string} targetID ID of the target node.\n   * @param {function} cb Callback to invoke.\n   * @param {*} arg Argument to invoke the callback with.\n   * @internal\n   */\n  traverseTwoPhase: function(targetID, cb, arg) {\n    if (targetID) {\n      traverseParentPath('', targetID, cb, arg, true, false);\n      traverseParentPath(targetID, '', cb, arg, false, true);\n    }\n  },\n\n  /**\n   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For\n   * example, passing `.0.$row-0.1` would result in `cb` getting called\n   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.\n   *\n   * NOTE: This traversal happens on IDs without touching the DOM.\n   *\n   * @param {string} targetID ID of the target node.\n   * @param {function} cb Callback to invoke.\n   * @param {*} arg Argument to invoke the callback with.\n   * @internal\n   */\n  traverseAncestors: function(targetID, cb, arg) {\n    traverseParentPath('', targetID, cb, arg, true, false);\n  },\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _getFirstCommonAncestorID: getFirstCommonAncestorID,\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _getNextDescendantID: getNextDescendantID,\n\n  isAncestorIDOf: isAncestorIDOf,\n\n  SEPARATOR: SEPARATOR\n\n};\n\nmodule.exports = ReactInstanceHandles;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactInstanceHandles.js\n ** module id = 23\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactInstanceHandles.js?")},/*!*****************************************!*\
  !*** ./~/react/lib/ReactInstanceMap.js ***!
  \*****************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactInstanceMap\n */\n\n'use strict';\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n */\n\n// TODO: Replace this with ES6: var ReactInstanceMap = new Map();\nvar ReactInstanceMap = {\n\n  /**\n   * This API should be called `delete` but we'd have to make sure to always\n   * transform these to strings for IE support. When this transform is fully\n   * supported we can rename it.\n   */\n  remove: function(key) {\n    key._reactInternalInstance = undefined;\n  },\n\n  get: function(key) {\n    return key._reactInternalInstance;\n  },\n\n  has: function(key) {\n    return key._reactInternalInstance !== undefined;\n  },\n\n  set: function(key, value) {\n    key._reactInternalInstance = value;\n  }\n\n};\n\nmodule.exports = ReactInstanceMap;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactInstanceMap.js\n ** module id = 24\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactInstanceMap.js?")},/*!****************************************!*\
  !*** ./~/react/lib/ReactReconciler.js ***!
  \****************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactReconciler\n */\n\n'use strict';\n\nvar ReactRef = __webpack_require__(/*! ./ReactRef */ 162);\nvar ReactElementValidator = __webpack_require__(/*! ./ReactElementValidator */ 32);\n\n/**\n * Helper to call ReactRef.attachRefs with this composite component, split out\n * to avoid allocations in the transaction mount-ready queue.\n */\nfunction attachRefs() {\n  ReactRef.attachRefs(this, this._currentElement);\n}\n\nvar ReactReconciler = {\n\n  /**\n   * Initializes the component, renders markup, and registers event listeners.\n   *\n   * @param {ReactComponent} internalInstance\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {?string} Rendered markup to be inserted into the DOM.\n   * @final\n   * @internal\n   */\n  mountComponent: function(internalInstance, rootID, transaction, context) {\n    var markup = internalInstance.mountComponent(rootID, transaction, context);\n    if (false) {\n      ReactElementValidator.checkAndWarnForMutatedProps(\n        internalInstance._currentElement\n      );\n    }\n    transaction.getReactMountReady().enqueue(attachRefs, internalInstance);\n    return markup;\n  },\n\n  /**\n   * Releases any resources allocated by `mountComponent`.\n   *\n   * @final\n   * @internal\n   */\n  unmountComponent: function(internalInstance) {\n    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);\n    internalInstance.unmountComponent();\n  },\n\n  /**\n   * Update a component using a new element.\n   *\n   * @param {ReactComponent} internalInstance\n   * @param {ReactElement} nextElement\n   * @param {ReactReconcileTransaction} transaction\n   * @param {object} context\n   * @internal\n   */\n  receiveComponent: function(\n    internalInstance, nextElement, transaction, context\n  ) {\n    var prevElement = internalInstance._currentElement;\n\n    if (nextElement === prevElement && nextElement._owner != null) {\n      // Since elements are immutable after the owner is rendered,\n      // we can do a cheap identity compare here to determine if this is a\n      // superfluous reconcile. It's possible for state to be mutable but such\n      // change should trigger an update of the owner which would recreate\n      // the element. We explicitly check for the existence of an owner since\n      // it's possible for an element created outside a composite to be\n      // deeply mutated and reused.\n      return;\n    }\n\n    if (false) {\n      ReactElementValidator.checkAndWarnForMutatedProps(nextElement);\n    }\n\n    var refsChanged = ReactRef.shouldUpdateRefs(\n      prevElement,\n      nextElement\n    );\n\n    if (refsChanged) {\n      ReactRef.detachRefs(internalInstance, prevElement);\n    }\n\n    internalInstance.receiveComponent(nextElement, transaction, context);\n\n    if (refsChanged) {\n      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);\n    }\n  },\n\n  /**\n   * Flush any dirty changes in a component.\n   *\n   * @param {ReactComponent} internalInstance\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  performUpdateIfNecessary: function(\n    internalInstance,\n    transaction\n  ) {\n    internalInstance.performUpdateIfNecessary(transaction);\n  }\n\n};\n\nmodule.exports = ReactReconciler;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactReconciler.js\n ** module id = 25\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactReconciler.js?")},/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.assert.js ***!
  \***************************************************************/
function(module,exports,__webpack_require__){eval("var $ = __webpack_require__(/*! ./$ */ 5);\nfunction assert(condition, msg1, msg2){\n  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);\n}\nassert.def = $.assertDefined;\nassert.fn = function(it){\n  if(!$.isFunction(it))throw TypeError(it + ' is not a function!');\n  return it;\n};\nassert.obj = function(it){\n  if(!$.isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\nassert.inst = function(it, Constructor, name){\n  if(!(it instanceof Constructor))throw TypeError(name + \": use the 'new' operator!\");\n  return it;\n};\nmodule.exports = assert;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.assert.js\n ** module id = 26\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.assert.js?")},/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.cof.js ***!
  \************************************************************/
function(module,exports,__webpack_require__){eval("var $        = __webpack_require__(/*! ./$ */ 5)\n  , TAG      = __webpack_require__(/*! ./$.wks */ 16)('toStringTag')\n  , toString = {}.toString;\nfunction cof(it){\n  return toString.call(it).slice(8, -1);\n}\ncof.classof = function(it){\n  var O, T;\n  return it == undefined ? it === undefined ? 'Undefined' : 'Null'\n    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T : cof(O);\n};\ncof.set = function(it, tag, stat){\n  if(it && !$.has(it = stat ? it : it.prototype, TAG))$.hide(it, TAG, tag);\n};\nmodule.exports = cof;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.cof.js\n ** module id = 27\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.cof.js?")},/*!*************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.iter.js ***!
  \*************************************************************/
function(module,exports,__webpack_require__){eval("'use strict';\nvar $                 = __webpack_require__(/*! ./$ */ 5)\n  , cof               = __webpack_require__(/*! ./$.cof */ 27)\n  , classof           = cof.classof\n  , assert            = __webpack_require__(/*! ./$.assert */ 26)\n  , assertObject      = assert.obj\n  , SYMBOL_ITERATOR   = __webpack_require__(/*! ./$.wks */ 16)('iterator')\n  , FF_ITERATOR       = '@@iterator'\n  , Iterators         = __webpack_require__(/*! ./$.shared */ 70)('iterators')\n  , IteratorPrototype = {};\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nsetIterator(IteratorPrototype, $.that);\nfunction setIterator(O, value){\n  $.hide(O, SYMBOL_ITERATOR, value);\n  // Add iterator for FF iterator protocol\n  if(FF_ITERATOR in [])$.hide(O, FF_ITERATOR, value);\n}\n\nmodule.exports = {\n  // Safari has buggy iterators w/o `next`\n  BUGGY: 'keys' in [] && !('next' in [].keys()),\n  Iterators: Iterators,\n  step: function(done, value){\n    return {value: value, done: !!done};\n  },\n  is: function(it){\n    var O      = Object(it)\n      , Symbol = $.g.Symbol;\n    return (Symbol && Symbol.iterator || FF_ITERATOR) in O\n      || SYMBOL_ITERATOR in O\n      || $.has(Iterators, classof(O));\n  },\n  get: function(it){\n    var Symbol = $.g.Symbol\n      , getIter;\n    if(it != undefined){\n      getIter = it[Symbol && Symbol.iterator || FF_ITERATOR]\n        || it[SYMBOL_ITERATOR]\n        || Iterators[classof(it)];\n    }\n    assert($.isFunction(getIter), it, ' is not iterable!');\n    return assertObject(getIter.call(it));\n  },\n  set: setIterator,\n  create: function(Constructor, NAME, next, proto){\n    Constructor.prototype = $.create(proto || IteratorPrototype, {next: $.desc(1, next)});\n    cof.set(Constructor, NAME + ' Iterator');\n  }\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.iter.js\n ** module id = 28\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.iter.js?")},/*!**********************************************!*\
  !*** ./~/react/lib/DOMPropertyOperations.js ***!
  \**********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DOMPropertyOperations\n * @typechecks static-only\n */\n\n'use strict';\n\nvar DOMProperty = __webpack_require__(/*! ./DOMProperty */ 19);\n\nvar quoteAttributeValueForBrowser = __webpack_require__(/*! ./quoteAttributeValueForBrowser */ 200);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nfunction shouldIgnoreValue(name, value) {\n  return value == null ||\n    (DOMProperty.hasBooleanValue[name] && !value) ||\n    (DOMProperty.hasNumericValue[name] && isNaN(value)) ||\n    (DOMProperty.hasPositiveNumericValue[name] && (value < 1)) ||\n    (DOMProperty.hasOverloadedBooleanValue[name] && value === false);\n}\n\nif (false) {\n  var reactProps = {\n    children: true,\n    dangerouslySetInnerHTML: true,\n    key: true,\n    ref: true\n  };\n  var warnedProperties = {};\n\n  var warnUnknownProperty = function(name) {\n    if (reactProps.hasOwnProperty(name) && reactProps[name] ||\n        warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {\n      return;\n    }\n\n    warnedProperties[name] = true;\n    var lowerCasedName = name.toLowerCase();\n\n    // data-* attributes should be lowercase; suggest the lowercase version\n    var standardName = (\n      DOMProperty.isCustomAttribute(lowerCasedName) ?\n        lowerCasedName :\n      DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ?\n        DOMProperty.getPossibleStandardName[lowerCasedName] :\n        null\n    );\n\n    // For now, only warn when we have a suggested correction. This prevents\n    // logging too much when using transferPropsTo.\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      standardName == null,\n      'Unknown DOM property %s. Did you mean %s?',\n      name,\n      standardName\n    ) : null);\n\n  };\n}\n\n/**\n * Operations for dealing with DOM properties.\n */\nvar DOMPropertyOperations = {\n\n  /**\n   * Creates markup for the ID property.\n   *\n   * @param {string} id Unescaped ID.\n   * @return {string} Markup string.\n   */\n  createMarkupForID: function(id) {\n    return DOMProperty.ID_ATTRIBUTE_NAME + '=' +\n      quoteAttributeValueForBrowser(id);\n  },\n\n  /**\n   * Creates markup for a property.\n   *\n   * @param {string} name\n   * @param {*} value\n   * @return {?string} Markup string, or null if the property was invalid.\n   */\n  createMarkupForProperty: function(name, value) {\n    if (DOMProperty.isStandardName.hasOwnProperty(name) &&\n        DOMProperty.isStandardName[name]) {\n      if (shouldIgnoreValue(name, value)) {\n        return '';\n      }\n      var attributeName = DOMProperty.getAttributeName[name];\n      if (DOMProperty.hasBooleanValue[name] ||\n          (DOMProperty.hasOverloadedBooleanValue[name] && value === true)) {\n        return attributeName;\n      }\n      return attributeName + '=' + quoteAttributeValueForBrowser(value);\n    } else if (DOMProperty.isCustomAttribute(name)) {\n      if (value == null) {\n        return '';\n      }\n      return name + '=' + quoteAttributeValueForBrowser(value);\n    } else if (false) {\n      warnUnknownProperty(name);\n    }\n    return null;\n  },\n\n  /**\n   * Sets the value for a property on a node.\n   *\n   * @param {DOMElement} node\n   * @param {string} name\n   * @param {*} value\n   */\n  setValueForProperty: function(node, name, value) {\n    if (DOMProperty.isStandardName.hasOwnProperty(name) &&\n        DOMProperty.isStandardName[name]) {\n      var mutationMethod = DOMProperty.getMutationMethod[name];\n      if (mutationMethod) {\n        mutationMethod(node, value);\n      } else if (shouldIgnoreValue(name, value)) {\n        this.deleteValueForProperty(node, name);\n      } else if (DOMProperty.mustUseAttribute[name]) {\n        // `setAttribute` with objects becomes only `[object]` in IE8/9,\n        // ('' + value) makes it output the correct toString()-value.\n        node.setAttribute(DOMProperty.getAttributeName[name], '' + value);\n      } else {\n        var propName = DOMProperty.getPropertyName[name];\n        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the\n        // property type before comparing; only `value` does and is string.\n        if (!DOMProperty.hasSideEffects[name] ||\n            ('' + node[propName]) !== ('' + value)) {\n          // Contrary to `setAttribute`, object properties are properly\n          // `toString`ed by IE8/9.\n          node[propName] = value;\n        }\n      }\n    } else if (DOMProperty.isCustomAttribute(name)) {\n      if (value == null) {\n        node.removeAttribute(name);\n      } else {\n        node.setAttribute(name, '' + value);\n      }\n    } else if (false) {\n      warnUnknownProperty(name);\n    }\n  },\n\n  /**\n   * Deletes the value for a property on a node.\n   *\n   * @param {DOMElement} node\n   * @param {string} name\n   */\n  deleteValueForProperty: function(node, name) {\n    if (DOMProperty.isStandardName.hasOwnProperty(name) &&\n        DOMProperty.isStandardName[name]) {\n      var mutationMethod = DOMProperty.getMutationMethod[name];\n      if (mutationMethod) {\n        mutationMethod(node, undefined);\n      } else if (DOMProperty.mustUseAttribute[name]) {\n        node.removeAttribute(DOMProperty.getAttributeName[name]);\n      } else {\n        var propName = DOMProperty.getPropertyName[name];\n        var defaultValue = DOMProperty.getDefaultValueForProperty(\n          node.nodeName,\n          propName\n        );\n        if (!DOMProperty.hasSideEffects[name] ||\n            ('' + node[propName]) !== defaultValue) {\n          node[propName] = defaultValue;\n        }\n      }\n    } else if (DOMProperty.isCustomAttribute(name)) {\n      node.removeAttribute(name);\n    } else if (false) {\n      warnUnknownProperty(name);\n    }\n  }\n\n};\n\nmodule.exports = DOMPropertyOperations;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/DOMPropertyOperations.js\n ** module id = 29\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/DOMPropertyOperations.js?")},/*!***************************************!*\
  !*** ./~/react/lib/EventPluginHub.js ***!
  \***************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPluginHub\n */\n\n'use strict';\n\nvar EventPluginRegistry = __webpack_require__(/*! ./EventPluginRegistry */ 73);\nvar EventPluginUtils = __webpack_require__(/*! ./EventPluginUtils */ 46);\n\nvar accumulateInto = __webpack_require__(/*! ./accumulateInto */ 57);\nvar forEachAccumulated = __webpack_require__(/*! ./forEachAccumulated */ 58);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\n/**\n * Internal store for event listeners\n */\nvar listenerBank = {};\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @private\n */\nvar executeDispatchesAndRelease = function(event) {\n  if (event) {\n    var executeDispatch = EventPluginUtils.executeDispatch;\n    // Plugins can provide custom behavior when dispatching events.\n    var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);\n    if (PluginModule && PluginModule.executeDispatch) {\n      executeDispatch = PluginModule.executeDispatch;\n    }\n    EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\n\n/**\n * - `InstanceHandle`: [required] Module that performs logical traversals of DOM\n *   hierarchy given ids of the logical DOM elements involved.\n */\nvar InstanceHandle = null;\n\nfunction validateInstanceHandle() {\n  var valid =\n    InstanceHandle &&\n    InstanceHandle.traverseTwoPhase &&\n    InstanceHandle.traverseEnterLeave;\n  (false ? invariant(\n    valid,\n    'InstanceHandle not injected before use!'\n  ) : invariant(valid));\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\nvar EventPluginHub = {\n\n  /**\n   * Methods for injecting dependencies.\n   */\n  injection: {\n\n    /**\n     * @param {object} InjectedMount\n     * @public\n     */\n    injectMount: EventPluginUtils.injection.injectMount,\n\n    /**\n     * @param {object} InjectedInstanceHandle\n     * @public\n     */\n    injectInstanceHandle: function(InjectedInstanceHandle) {\n      InstanceHandle = InjectedInstanceHandle;\n      if (false) {\n        validateInstanceHandle();\n      }\n    },\n\n    getInstanceHandle: function() {\n      if (false) {\n        validateInstanceHandle();\n      }\n      return InstanceHandle;\n    },\n\n    /**\n     * @param {array} InjectedEventPluginOrder\n     * @public\n     */\n    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,\n\n    /**\n     * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n     */\n    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName\n\n  },\n\n  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,\n\n  registrationNameModules: EventPluginRegistry.registrationNameModules,\n\n  /**\n   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.\n   *\n   * @param {string} id ID of the DOM element.\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   * @param {?function} listener The callback to store.\n   */\n  putListener: function(id, registrationName, listener) {\n    (false ? invariant(\n      !listener || typeof listener === 'function',\n      'Expected %s listener to be a function, instead got type %s',\n      registrationName, typeof listener\n    ) : invariant(!listener || typeof listener === 'function'));\n\n    var bankForRegistrationName =\n      listenerBank[registrationName] || (listenerBank[registrationName] = {});\n    bankForRegistrationName[id] = listener;\n  },\n\n  /**\n   * @param {string} id ID of the DOM element.\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   * @return {?function} The stored callback.\n   */\n  getListener: function(id, registrationName) {\n    var bankForRegistrationName = listenerBank[registrationName];\n    return bankForRegistrationName && bankForRegistrationName[id];\n  },\n\n  /**\n   * Deletes a listener from the registration bank.\n   *\n   * @param {string} id ID of the DOM element.\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   */\n  deleteListener: function(id, registrationName) {\n    var bankForRegistrationName = listenerBank[registrationName];\n    if (bankForRegistrationName) {\n      delete bankForRegistrationName[id];\n    }\n  },\n\n  /**\n   * Deletes all listeners for the DOM element with the supplied ID.\n   *\n   * @param {string} id ID of the DOM element.\n   */\n  deleteAllListeners: function(id) {\n    for (var registrationName in listenerBank) {\n      delete listenerBank[registrationName][id];\n    }\n  },\n\n  /**\n   * Allows registered plugins an opportunity to extract events from top-level\n   * native browser events.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @internal\n   */\n  extractEvents: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n    var events;\n    var plugins = EventPluginRegistry.plugins;\n    for (var i = 0, l = plugins.length; i < l; i++) {\n      // Not every plugin in the ordering may be loaded at runtime.\n      var possiblePlugin = plugins[i];\n      if (possiblePlugin) {\n        var extractedEvents = possiblePlugin.extractEvents(\n          topLevelType,\n          topLevelTarget,\n          topLevelTargetID,\n          nativeEvent\n        );\n        if (extractedEvents) {\n          events = accumulateInto(events, extractedEvents);\n        }\n      }\n    }\n    return events;\n  },\n\n  /**\n   * Enqueues a synthetic event that should be dispatched when\n   * `processEventQueue` is invoked.\n   *\n   * @param {*} events An accumulation of synthetic events.\n   * @internal\n   */\n  enqueueEvents: function(events) {\n    if (events) {\n      eventQueue = accumulateInto(eventQueue, events);\n    }\n  },\n\n  /**\n   * Dispatches all synthetic events on the event queue.\n   *\n   * @internal\n   */\n  processEventQueue: function() {\n    // Set `eventQueue` to null before processing it so that we can tell if more\n    // events get enqueued while processing.\n    var processingEventQueue = eventQueue;\n    eventQueue = null;\n    forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);\n    (false ? invariant(\n      !eventQueue,\n      'processEventQueue(): Additional events were enqueued while processing ' +\n      'an event queue. Support for this has not yet been implemented.'\n    ) : invariant(!eventQueue));\n  },\n\n  /**\n   * These are needed for tests only. Do not use!\n   */\n  __purge: function() {\n    listenerBank = {};\n  },\n\n  __getListenerBank: function() {\n    return listenerBank;\n  }\n\n};\n\nmodule.exports = EventPluginHub;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EventPluginHub.js\n ** module id = 30\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EventPluginHub.js?")},/*!*****************************************!*\
  !*** ./~/react/lib/EventPropagators.js ***!
  \*****************************************/
function(module,exports,__webpack_require__){eval('/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPropagators\n */\n\n\'use strict\';\n\nvar EventConstants = __webpack_require__(/*! ./EventConstants */ 7);\nvar EventPluginHub = __webpack_require__(/*! ./EventPluginHub */ 30);\n\nvar accumulateInto = __webpack_require__(/*! ./accumulateInto */ 57);\nvar forEachAccumulated = __webpack_require__(/*! ./forEachAccumulated */ 58);\n\nvar PropagationPhases = EventConstants.PropagationPhases;\nvar getListener = EventPluginHub.getListener;\n\n/**\n * Some event types have a notion of different registration names for different\n * "phases" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(id, event, propagationPhase) {\n  var registrationName =\n    event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(id, registrationName);\n}\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event\'s members allows us to not have to create a wrapping\n * "dispatch" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(domID, upwards, event) {\n  if (false) {\n    if (!domID) {\n      throw new Error(\'Dispatching id must not be null\');\n    }\n  }\n  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;\n  var listener = listenerAtPhase(domID, event, phase);\n  if (listener) {\n    event._dispatchListeners =\n      accumulateInto(event._dispatchListeners, listener);\n    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We can not perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(\n      event.dispatchMarker,\n      accumulateDirectionalDispatches,\n      event\n    );\n  }\n}\n\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(id, ignoredDirection, event) {\n  if (event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(id, registrationName);\n    if (listener) {\n      event._dispatchListeners =\n        accumulateInto(event._dispatchListeners, listener);\n      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event.dispatchMarker, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {\n  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(\n    fromID,\n    toID,\n    accumulateDispatches,\n    leave,\n    enter\n  );\n}\n\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of "dispatch ready event objects" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing event a\n * single one.\n *\n * @constructor EventPropagators\n */\nvar EventPropagators = {\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n  accumulateDirectDispatches: accumulateDirectDispatches,\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches\n};\n\nmodule.exports = EventPropagators;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EventPropagators.js\n ** module id = 31\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EventPropagators.js?')},/*!**********************************************!*\
  !*** ./~/react/lib/ReactElementValidator.js ***!
  \**********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactElementValidator\n */\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\n\n'use strict';\n\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\nvar ReactFragment = __webpack_require__(/*! ./ReactFragment */ 22);\nvar ReactPropTypeLocations = __webpack_require__(/*! ./ReactPropTypeLocations */ 55);\nvar ReactPropTypeLocationNames = __webpack_require__(/*! ./ReactPropTypeLocationNames */ 39);\nvar ReactCurrentOwner = __webpack_require__(/*! ./ReactCurrentOwner */ 14);\nvar ReactNativeComponent = __webpack_require__(/*! ./ReactNativeComponent */ 38);\n\nvar getIteratorFn = __webpack_require__(/*! ./getIteratorFn */ 91);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = ReactCurrentOwner.current.getName();\n    if (name) {\n      return ' Check the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\nvar ownerHasKeyUseWarning = {};\n\nvar loggedTypeFailures = {};\n\nvar NUMERIC_PROPERTY_REGEX = /^\\d+$/;\n\n/**\n * Gets the instance's name for use in warnings.\n *\n * @internal\n * @return {?string} Display name or undefined\n */\nfunction getName(instance) {\n  var publicInstance = instance && instance.getPublicInstance();\n  if (!publicInstance) {\n    return undefined;\n  }\n  var constructor = publicInstance.constructor;\n  if (!constructor) {\n    return undefined;\n  }\n  return constructor.displayName || constructor.name || undefined;\n}\n\n/**\n * Gets the current owner's displayName for use in warnings.\n *\n * @internal\n * @return {?string} Display name or undefined\n */\nfunction getCurrentOwnerDisplayName() {\n  var current = ReactCurrentOwner.current;\n  return (\n    current && getName(current) || undefined\n  );\n}\n\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\nfunction validateExplicitKey(element, parentType) {\n  if (element._store.validated || element.key != null) {\n    return;\n  }\n  element._store.validated = true;\n\n  warnAndMonitorForKeyUse(\n    'Each child in an array or iterator should have a unique \"key\" prop.',\n    element,\n    parentType\n  );\n}\n\n/**\n * Warn if the key is being defined as an object property but has an incorrect\n * value.\n *\n * @internal\n * @param {string} name Property name of the key.\n * @param {ReactElement} element Component that requires a key.\n * @param {*} parentType element's parent's type.\n */\nfunction validatePropertyKey(name, element, parentType) {\n  if (!NUMERIC_PROPERTY_REGEX.test(name)) {\n    return;\n  }\n  warnAndMonitorForKeyUse(\n    'Child objects should have non-numeric keys so ordering is preserved.',\n    element,\n    parentType\n  );\n}\n\n/**\n * Shared warning and monitoring code for the key warnings.\n *\n * @internal\n * @param {string} message The base warning that gets output.\n * @param {ReactElement} element Component that requires a key.\n * @param {*} parentType element's parent's type.\n */\nfunction warnAndMonitorForKeyUse(message, element, parentType) {\n  var ownerName = getCurrentOwnerDisplayName();\n  var parentName = typeof parentType === 'string' ?\n    parentType : parentType.displayName || parentType.name;\n\n  var useName = ownerName || parentName;\n  var memoizer = ownerHasKeyUseWarning[message] || (\n    (ownerHasKeyUseWarning[message] = {})\n  );\n  if (memoizer.hasOwnProperty(useName)) {\n    return;\n  }\n  memoizer[useName] = true;\n\n  var parentOrOwnerAddendum =\n    ownerName ? (\" Check the render method of \" + ownerName + \".\") :\n    parentName ? (\" Check the React.render call using <\" + parentName + \">.\") :\n    '';\n\n  // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n  var childOwnerAddendum = '';\n  if (element &&\n      element._owner &&\n      element._owner !== ReactCurrentOwner.current) {\n    // Name of the component that originally created this child.\n    var childOwnerName = getName(element._owner);\n\n    childOwnerAddendum = (\" It was passed a child from \" + childOwnerName + \".\");\n  }\n\n  (false ? warning(\n    false,\n    message + '%s%s See https://fb.me/react-warning-keys for more information.',\n    parentOrOwnerAddendum,\n    childOwnerAddendum\n  ) : null);\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (Array.isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n      if (ReactElement.isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (ReactElement.isValidElement(node)) {\n    // This element was passed in a valid location.\n    node._store.validated = true;\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node);\n    // Entry iterators provide implicit keys.\n    if (iteratorFn) {\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (ReactElement.isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    } else if (typeof node === 'object') {\n      var fragment = ReactFragment.extractIfFragment(node);\n      for (var key in fragment) {\n        if (fragment.hasOwnProperty(key)) {\n          validatePropertyKey(key, fragment[key], parentType);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Assert that the props are valid\n *\n * @param {string} componentName Name of the component for error messages.\n * @param {object} propTypes Map of prop name to a ReactPropType\n * @param {object} props\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @private\n */\nfunction checkPropTypes(componentName, propTypes, props, location) {\n  for (var propName in propTypes) {\n    if (propTypes.hasOwnProperty(propName)) {\n      var error;\n      // Prop type validation may throw. In case they do, we don't want to\n      // fail the render phase where it didn't fail before. So we log it.\n      // After these have been cleaned up, we'll let them throw.\n      try {\n        // This is intentionally an invariant that gets caught. It's the same\n        // behavior as without this statement except with a better message.\n        (false ? invariant(\n          typeof propTypes[propName] === 'function',\n          '%s: %s type `%s` is invalid; it must be a function, usually from ' +\n          'React.PropTypes.',\n          componentName || 'React class',\n          ReactPropTypeLocationNames[location],\n          propName\n        ) : invariant(typeof propTypes[propName] === 'function'));\n        error = propTypes[propName](props, propName, componentName, location);\n      } catch (ex) {\n        error = ex;\n      }\n      if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n        // Only monitor this failure once because there tends to be a lot of the\n        // same error.\n        loggedTypeFailures[error.message] = true;\n\n        var addendum = getDeclarationErrorAddendum(this);\n        (false ? warning(false, 'Failed propType: %s%s', error.message, addendum) : null);\n      }\n    }\n  }\n}\n\nvar warnedPropsMutations = {};\n\n/**\n * Warn about mutating props when setting `propName` on `element`.\n *\n * @param {string} propName The string key within props that was set\n * @param {ReactElement} element\n */\nfunction warnForPropsMutation(propName, element) {\n  var type = element.type;\n  var elementName = typeof type === 'string' ? type : type.displayName;\n  var ownerName = element._owner ?\n    element._owner.getPublicInstance().constructor.displayName : null;\n\n  var warningKey = propName + '|' + elementName + '|' + ownerName;\n  if (warnedPropsMutations.hasOwnProperty(warningKey)) {\n    return;\n  }\n  warnedPropsMutations[warningKey] = true;\n\n  var elementInfo = '';\n  if (elementName) {\n    elementInfo = ' <' + elementName + ' />';\n  }\n  var ownerInfo = '';\n  if (ownerName) {\n    ownerInfo = ' The element was created by ' + ownerName + '.';\n  }\n\n  (false ? warning(\n    false,\n    'Don\\'t set .props.%s of the React component%s. Instead, specify the ' +\n    'correct value when initially creating the element or use ' +\n    'React.cloneElement to make a new element with updated props.%s',\n    propName,\n    elementInfo,\n    ownerInfo\n  ) : null);\n}\n\n// Inline Object.is polyfill\nfunction is(a, b) {\n  if (a !== a) {\n    // NaN\n    return b !== b;\n  }\n  if (a === 0 && b === 0) {\n    // +-0\n    return 1 / a === 1 / b;\n  }\n  return a === b;\n}\n\n/**\n * Given an element, check if its props have been mutated since element\n * creation (or the last call to this function). In particular, check if any\n * new props have been added, which we can't directly catch by defining warning\n * properties on the props object.\n *\n * @param {ReactElement} element\n */\nfunction checkAndWarnForMutatedProps(element) {\n  if (!element._store) {\n    // Element was created using `new ReactElement` directly or with\n    // `ReactElement.createElement`; skip mutation checking\n    return;\n  }\n\n  var originalProps = element._store.originalProps;\n  var props = element.props;\n\n  for (var propName in props) {\n    if (props.hasOwnProperty(propName)) {\n      if (!originalProps.hasOwnProperty(propName) ||\n          !is(originalProps[propName], props[propName])) {\n        warnForPropsMutation(propName, element);\n\n        // Copy over the new value so that the two props objects match again\n        originalProps[propName] = props[propName];\n      }\n    }\n  }\n}\n\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\nfunction validatePropTypes(element) {\n  if (element.type == null) {\n    // This has already warned. Don't throw.\n    return;\n  }\n  // Extract the component class from the element. Converts string types\n  // to a composite class which may have propTypes.\n  // TODO: Validating a string's propTypes is not decoupled from the\n  // rendering target which is problematic.\n  var componentClass = ReactNativeComponent.getComponentClassForElement(\n    element\n  );\n  var name = componentClass.displayName || componentClass.name;\n  if (componentClass.propTypes) {\n    checkPropTypes(\n      name,\n      componentClass.propTypes,\n      element.props,\n      ReactPropTypeLocations.prop\n    );\n  }\n  if (typeof componentClass.getDefaultProps === 'function') {\n    (false ? warning(\n      componentClass.getDefaultProps.isReactClassApproved,\n      'getDefaultProps is only used on classic React.createClass ' +\n      'definitions. Use a static property named `defaultProps` instead.'\n    ) : null);\n  }\n}\n\nvar ReactElementValidator = {\n\n  checkAndWarnForMutatedProps: checkAndWarnForMutatedProps,\n\n  createElement: function(type, props, children) {\n    // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n    (false ? warning(\n      type != null,\n      'React.createElement: type should not be null or undefined. It should ' +\n        'be a string (for DOM elements) or a ReactClass (for composite ' +\n        'components).'\n    ) : null);\n\n    var element = ReactElement.createElement.apply(this, arguments);\n\n    // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n    if (element == null) {\n      return element;\n    }\n\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n\n    validatePropTypes(element);\n\n    return element;\n  },\n\n  createFactory: function(type) {\n    var validatedFactory = ReactElementValidator.createElement.bind(\n      null,\n      type\n    );\n    // Legacy hook TODO: Warn if this is accessed\n    validatedFactory.type = type;\n\n    if (false) {\n      try {\n        Object.defineProperty(\n          validatedFactory,\n          'type',\n          {\n            enumerable: false,\n            get: function() {\n              (\"production\" !== process.env.NODE_ENV ? warning(\n                false,\n                'Factory.type is deprecated. Access the class directly ' +\n                'before passing it to createFactory.'\n              ) : null);\n              Object.defineProperty(this, 'type', {\n                value: type\n              });\n              return type;\n            }\n          }\n        );\n      } catch (x) {\n        // IE will fail on defineProperty (es5-shim/sham too)\n      }\n    }\n\n\n    return validatedFactory;\n  },\n\n  cloneElement: function(element, props, children) {\n    var newElement = ReactElement.cloneElement.apply(this, arguments);\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], newElement.type);\n    }\n    validatePropTypes(newElement);\n    return newElement;\n  }\n\n};\n\nmodule.exports = ReactElementValidator;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactElementValidator.js\n ** module id = 32\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactElementValidator.js?")},/*!*****************************************!*\
  !*** ./~/react/lib/SyntheticUIEvent.js ***!
  \*****************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticUIEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticEvent = __webpack_require__(/*! ./SyntheticEvent */ 18);\n\nvar getEventTarget = __webpack_require__(/*! ./getEventTarget */ 61);\n\n/**\n * @interface UIEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar UIEventInterface = {\n  view: function(event) {\n    if (event.view) {\n      return event.view;\n    }\n\n    var target = getEventTarget(event);\n    if (target != null && target.window === target) {\n      // target is a window object\n      return target;\n    }\n\n    var doc = target.ownerDocument;\n    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n    if (doc) {\n      return doc.defaultView || doc.parentWindow;\n    } else {\n      return window;\n    }\n  },\n  detail: function(event) {\n    return event.detail || 0;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);\n\nmodule.exports = SyntheticUIEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticUIEvent.js\n ** module id = 33\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticUIEvent.js?")},/*!**********************************!*\
  !*** ./~/react/lib/keyMirror.js ***!
  \**********************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule keyMirror\n * @typechecks static-only\n */\n\n'use strict';\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\n/**\n * Constructs an enumeration with keys equal to their value.\n *\n * For example:\n *\n *   var COLORS = keyMirror({blue: null, red: null});\n *   var myColor = COLORS.blue;\n *   var isColorValid = !!COLORS[myColor];\n *\n * The last line could not be performed if the values of the generated enum were\n * not equal to their keys.\n *\n *   Input:  {key1: val1, key2: val2}\n *   Output: {key1: key1, key2: key2}\n *\n * @param {object} obj\n * @return {object}\n */\nvar keyMirror = function(obj) {\n  var ret = {};\n  var key;\n  (false ? invariant(\n    obj instanceof Object && !Array.isArray(obj),\n    'keyMirror(...): Argument must be an object.'\n  ) : invariant(obj instanceof Object && !Array.isArray(obj)));\n  for (key in obj) {\n    if (!obj.hasOwnProperty(key)) {\n      continue;\n    }\n    ret[key] = key;\n  }\n  return ret;\n};\n\nmodule.exports = keyMirror;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/keyMirror.js\n ** module id = 34\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/keyMirror.js?")},/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.ctx.js ***!
  \************************************************************/
function(module,exports,__webpack_require__){eval("// Optional / simple context binding\nvar assertFunction = __webpack_require__(/*! ./$.assert */ 26).fn;\nmodule.exports = function(fn, that, length){\n  assertFunction(fn);\n  if(~length && that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  } return function(/* ...args */){\n      return fn.apply(that, arguments);\n    };\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.ctx.js\n ** module id = 35\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.ctx.js?")},/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.uid.js ***!
  \************************************************************/
function(module,exports,__webpack_require__){eval("var sid = 0;\nfunction uid(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++sid + Math.random()).toString(36));\n}\nuid.safe = __webpack_require__(/*! ./$ */ 5).g.Symbol || uid;\nmodule.exports = uid;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.uid.js\n ** module id = 36\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.uid.js?")},/*!***************************************!*\
  !*** ./~/react/lib/AutoFocusMixin.js ***!
  \***************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule AutoFocusMixin\n * @typechecks static-only\n */\n\n'use strict';\n\nvar focusNode = __webpack_require__(/*! ./focusNode */ 89);\n\nvar AutoFocusMixin = {\n  componentDidMount: function() {\n    if (this.props.autoFocus) {\n      focusNode(this.getDOMNode());\n    }\n  }\n};\n\nmodule.exports = AutoFocusMixin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/AutoFocusMixin.js\n ** module id = 37\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/AutoFocusMixin.js?")},/*!*********************************************!*\
  !*** ./~/react/lib/ReactNativeComponent.js ***!
  \*********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactNativeComponent\n */\n\n'use strict';\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\nvar autoGenerateWrapperClass = null;\nvar genericComponentClass = null;\n// This registry keeps track of wrapper classes around native tags\nvar tagToComponentClass = {};\nvar textComponentClass = null;\n\nvar ReactNativeComponentInjection = {\n  // This accepts a class that receives the tag string. This is a catch all\n  // that can render any kind of tag.\n  injectGenericComponentClass: function(componentClass) {\n    genericComponentClass = componentClass;\n  },\n  // This accepts a text component class that takes the text string to be\n  // rendered as props.\n  injectTextComponentClass: function(componentClass) {\n    textComponentClass = componentClass;\n  },\n  // This accepts a keyed object with classes as values. Each key represents a\n  // tag. That particular tag will use this class instead of the generic one.\n  injectComponentClasses: function(componentClasses) {\n    assign(tagToComponentClass, componentClasses);\n  },\n  // Temporary hack since we expect DOM refs to behave like composites,\n  // for this release.\n  injectAutoWrapper: function(wrapperFactory) {\n    autoGenerateWrapperClass = wrapperFactory;\n  }\n};\n\n/**\n * Get a composite component wrapper class for a specific tag.\n *\n * @param {ReactElement} element The tag for which to get the class.\n * @return {function} The React class constructor function.\n */\nfunction getComponentClassForElement(element) {\n  if (typeof element.type === 'function') {\n    return element.type;\n  }\n  var tag = element.type;\n  var componentClass = tagToComponentClass[tag];\n  if (componentClass == null) {\n    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);\n  }\n  return componentClass;\n}\n\n/**\n * Get a native internal component class for a specific tag.\n *\n * @param {ReactElement} element The element to create.\n * @return {function} The internal class constructor function.\n */\nfunction createInternalComponent(element) {\n  (false ? invariant(\n    genericComponentClass,\n    'There is no registered component for the tag %s',\n    element.type\n  ) : invariant(genericComponentClass));\n  return new genericComponentClass(element.type, element.props);\n}\n\n/**\n * @param {ReactText} text\n * @return {ReactComponent}\n */\nfunction createInstanceForText(text) {\n  return new textComponentClass(text);\n}\n\n/**\n * @param {ReactComponent} component\n * @return {boolean}\n */\nfunction isTextComponent(component) {\n  return component instanceof textComponentClass;\n}\n\nvar ReactNativeComponent = {\n  getComponentClassForElement: getComponentClassForElement,\n  createInternalComponent: createInternalComponent,\n  createInstanceForText: createInstanceForText,\n  isTextComponent: isTextComponent,\n  injection: ReactNativeComponentInjection\n};\n\nmodule.exports = ReactNativeComponent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactNativeComponent.js\n ** module id = 38\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactNativeComponent.js?")},/*!***************************************************!*\
  !*** ./~/react/lib/ReactPropTypeLocationNames.js ***!
  \***************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPropTypeLocationNames\n */\n\n'use strict';\n\nvar ReactPropTypeLocationNames = {};\n\nif (false) {\n  ReactPropTypeLocationNames = {\n    prop: 'prop',\n    context: 'context',\n    childContext: 'child context'\n  };\n}\n\nmodule.exports = ReactPropTypeLocationNames;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactPropTypeLocationNames.js\n ** module id = 39\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactPropTypeLocationNames.js?")},/*!********************************************!*\
  !*** ./~/react/lib/SyntheticMouseEvent.js ***!
  \********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticMouseEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticUIEvent = __webpack_require__(/*! ./SyntheticUIEvent */ 33);\nvar ViewportMetrics = __webpack_require__(/*! ./ViewportMetrics */ 85);\n\nvar getEventModifierState = __webpack_require__(/*! ./getEventModifierState */ 60);\n\n/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar MouseEventInterface = {\n  screenX: null,\n  screenY: null,\n  clientX: null,\n  clientY: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  getModifierState: getEventModifierState,\n  button: function(event) {\n    // Webkit, Firefox, IE9+\n    // which:  1 2 3\n    // button: 0 1 2 (standard)\n    var button = event.button;\n    if ('which' in event) {\n      return button;\n    }\n    // IE<9\n    // which:  undefined\n    // button: 0 0 0\n    // button: 1 4 2 (onmouseup)\n    return button === 2 ? 2 : button === 4 ? 1 : 0;\n  },\n  buttons: null,\n  relatedTarget: function(event) {\n    return event.relatedTarget || (\n      ((event.fromElement === event.srcElement ? event.toElement : event.fromElement))\n    );\n  },\n  // \"Proprietary\" Interface.\n  pageX: function(event) {\n    return 'pageX' in event ?\n      event.pageX :\n      event.clientX + ViewportMetrics.currentScrollLeft;\n  },\n  pageY: function(event) {\n    return 'pageY' in event ?\n      event.pageY :\n      event.clientY + ViewportMetrics.currentScrollTop;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);\n\nmodule.exports = SyntheticMouseEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticMouseEvent.js\n ** module id = 40\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticMouseEvent.js?")},/*!************************************!*\
  !*** ./~/react/lib/Transaction.js ***!
  \************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Transaction\n */\n\n'use strict';\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\n/**\n * `Transaction` creates a black box that is able to wrap any method such that\n * certain invariants are maintained before and after the method is invoked\n * (Even if an exception is thrown while invoking the wrapped method). Whoever\n * instantiates a transaction can provide enforcers of the invariants at\n * creation time. The `Transaction` class itself will supply one additional\n * automatic invariant for you - the invariant that any transaction instance\n * should not be run while it is already being run. You would typically create a\n * single instance of a `Transaction` for reuse multiple times, that potentially\n * is used to wrap several different methods. Wrappers are extremely simple -\n * they only require implementing two methods.\n *\n * <pre>\n *                       wrappers (injected at creation time)\n *                                      +        +\n *                                      |        |\n *                    +-----------------|--------|--------------+\n *                    |                 v        |              |\n *                    |      +---------------+   |              |\n *                    |   +--|    wrapper1   |---|----+         |\n *                    |   |  +---------------+   v    |         |\n *                    |   |          +-------------+  |         |\n *                    |   |     +----|   wrapper2  |--------+   |\n *                    |   |     |    +-------------+  |     |   |\n *                    |   |     |                     |     |   |\n *                    |   v     v                     v     v   | wrapper\n *                    | +---+ +---+   +---------+   +---+ +---+ | invariants\n * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained\n * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->\n *                    | |   | |   |   |         |   |   | |   | |\n *                    | |   | |   |   |         |   |   | |   | |\n *                    | |   | |   |   |         |   |   | |   | |\n *                    | +---+ +---+   +---------+   +---+ +---+ |\n *                    |  initialize                    close    |\n *                    +-----------------------------------------+\n * </pre>\n *\n * Use cases:\n * - Preserving the input selection ranges before/after reconciliation.\n *   Restoring selection even in the event of an unexpected error.\n * - Deactivating events while rearranging the DOM, preventing blurs/focuses,\n *   while guaranteeing that afterwards, the event system is reactivated.\n * - Flushing a queue of collected DOM mutations to the main UI thread after a\n *   reconciliation takes place in a worker thread.\n * - Invoking any collected `componentDidUpdate` callbacks after rendering new\n *   content.\n * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue\n *   to preserve the `scrollTop` (an automatic scroll aware DOM).\n * - (Future use case): Layout calculations before and after DOM updates.\n *\n * Transactional plugin API:\n * - A module that has an `initialize` method that returns any precomputation.\n * - and a `close` method that accepts the precomputation. `close` is invoked\n *   when the wrapped process is completed, or has failed.\n *\n * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules\n * that implement `initialize` and `close`.\n * @return {Transaction} Single transaction for reuse in thread.\n *\n * @class Transaction\n */\nvar Mixin = {\n  /**\n   * Sets up this instance so that it is prepared for collecting metrics. Does\n   * so such that this setup method may be used on an instance that is already\n   * initialized, in a way that does not consume additional memory upon reuse.\n   * That can be useful if you decide to make your subclass of this mixin a\n   * \"PooledClass\".\n   */\n  reinitializeTransaction: function() {\n    this.transactionWrappers = this.getTransactionWrappers();\n    if (!this.wrapperInitData) {\n      this.wrapperInitData = [];\n    } else {\n      this.wrapperInitData.length = 0;\n    }\n    this._isInTransaction = false;\n  },\n\n  _isInTransaction: false,\n\n  /**\n   * @abstract\n   * @return {Array<TransactionWrapper>} Array of transaction wrappers.\n   */\n  getTransactionWrappers: null,\n\n  isInTransaction: function() {\n    return !!this._isInTransaction;\n  },\n\n  /**\n   * Executes the function within a safety window. Use this for the top level\n   * methods that result in large amounts of computation/mutations that would\n   * need to be safety checked.\n   *\n   * @param {function} method Member of scope to call.\n   * @param {Object} scope Scope to invoke from.\n   * @param {Object?=} args... Arguments to pass to the method (optional).\n   *                           Helps prevent need to bind in many cases.\n   * @return Return value from `method`.\n   */\n  perform: function(method, scope, a, b, c, d, e, f) {\n    (false ? invariant(\n      !this.isInTransaction(),\n      'Transaction.perform(...): Cannot initialize a transaction when there ' +\n      'is already an outstanding transaction.'\n    ) : invariant(!this.isInTransaction()));\n    var errorThrown;\n    var ret;\n    try {\n      this._isInTransaction = true;\n      // Catching errors makes debugging more difficult, so we start with\n      // errorThrown set to true before setting it to false after calling\n      // close -- if it's still set to true in the finally block, it means\n      // one of these calls threw.\n      errorThrown = true;\n      this.initializeAll(0);\n      ret = method.call(scope, a, b, c, d, e, f);\n      errorThrown = false;\n    } finally {\n      try {\n        if (errorThrown) {\n          // If `method` throws, prefer to show that stack trace over any thrown\n          // by invoking `closeAll`.\n          try {\n            this.closeAll(0);\n          } catch (err) {\n          }\n        } else {\n          // Since `method` didn't throw, we don't want to silence the exception\n          // here.\n          this.closeAll(0);\n        }\n      } finally {\n        this._isInTransaction = false;\n      }\n    }\n    return ret;\n  },\n\n  initializeAll: function(startIndex) {\n    var transactionWrappers = this.transactionWrappers;\n    for (var i = startIndex; i < transactionWrappers.length; i++) {\n      var wrapper = transactionWrappers[i];\n      try {\n        // Catching errors makes debugging more difficult, so we start with the\n        // OBSERVED_ERROR state before overwriting it with the real return value\n        // of initialize -- if it's still set to OBSERVED_ERROR in the finally\n        // block, it means wrapper.initialize threw.\n        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;\n        this.wrapperInitData[i] = wrapper.initialize ?\n          wrapper.initialize.call(this) :\n          null;\n      } finally {\n        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {\n          // The initializer for wrapper i threw an error; initialize the\n          // remaining wrappers but silence any exceptions from them to ensure\n          // that the first error is the one to bubble up.\n          try {\n            this.initializeAll(i + 1);\n          } catch (err) {\n          }\n        }\n      }\n    }\n  },\n\n  /**\n   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into\n   * them the respective return values of `this.transactionWrappers.init[i]`\n   * (`close`rs that correspond to initializers that failed will not be\n   * invoked).\n   */\n  closeAll: function(startIndex) {\n    (false ? invariant(\n      this.isInTransaction(),\n      'Transaction.closeAll(): Cannot close transaction when none are open.'\n    ) : invariant(this.isInTransaction()));\n    var transactionWrappers = this.transactionWrappers;\n    for (var i = startIndex; i < transactionWrappers.length; i++) {\n      var wrapper = transactionWrappers[i];\n      var initData = this.wrapperInitData[i];\n      var errorThrown;\n      try {\n        // Catching errors makes debugging more difficult, so we start with\n        // errorThrown set to true before setting it to false after calling\n        // close -- if it's still set to true in the finally block, it means\n        // wrapper.close threw.\n        errorThrown = true;\n        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {\n          wrapper.close.call(this, initData);\n        }\n        errorThrown = false;\n      } finally {\n        if (errorThrown) {\n          // The closer for wrapper i threw an error; close the remaining\n          // wrappers but silence any exceptions from them to ensure that the\n          // first error is the one to bubble up.\n          try {\n            this.closeAll(i + 1);\n          } catch (e) {\n          }\n        }\n      }\n    }\n    this.wrapperInitData.length = 0;\n  }\n};\n\nvar Transaction = {\n\n  Mixin: Mixin,\n\n  /**\n   * Token to look for to determine if an error occured.\n   */\n  OBSERVED_ERROR: {}\n\n};\n\nmodule.exports = Transaction;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/Transaction.js\n ** module id = 41\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/Transaction.js?")},/*!************************************!*\
  !*** ./~/react/lib/emptyObject.js ***!
  \************************************/
function(module,exports,__webpack_require__){eval('/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule emptyObject\n */\n\n"use strict";\n\nvar emptyObject = {};\n\nif (false) {\n  Object.freeze(emptyObject);\n}\n\nmodule.exports = emptyObject;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/emptyObject.js\n ** module id = 42\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/emptyObject.js?')},/*!****************************************************!*\
  !*** ./~/react/lib/escapeTextContentForBrowser.js ***!
  \****************************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule escapeTextContentForBrowser\n */\n\n'use strict';\n\nvar ESCAPE_LOOKUP = {\n  '&': '&amp;',\n  '>': '&gt;',\n  '<': '&lt;',\n  '\"': '&quot;',\n  '\\'': '&#x27;'\n};\n\nvar ESCAPE_REGEX = /[&><\"']/g;\n\nfunction escaper(match) {\n  return ESCAPE_LOOKUP[match];\n}\n\n/**\n * Escapes text to prevent scripting attacks.\n *\n * @param {*} text Text value to escape.\n * @return {string} An escaped string.\n */\nfunction escapeTextContentForBrowser(text) {\n  return ('' + text).replace(ESCAPE_REGEX, escaper);\n}\n\nmodule.exports = escapeTextContentForBrowser;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/escapeTextContentForBrowser.js\n ** module id = 43\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/escapeTextContentForBrowser.js?")},/*!**************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.redef.js ***!
  \**************************************************************/
function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(/*! ./$ */ 5).hide;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.redef.js\n ** module id = 44\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.redef.js?")},/*!**************************************!*\
  !*** ./~/react/lib/CallbackQueue.js ***!
  \**************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule CallbackQueue\n */\n\n'use strict';\n\nvar PooledClass = __webpack_require__(/*! ./PooledClass */ 12);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\n/**\n * A specialized pseudo-event module to help keep track of components waiting to\n * be notified when their DOM representations are available for use.\n *\n * This implements `PooledClass`, so you should never need to instantiate this.\n * Instead, use `CallbackQueue.getPooled()`.\n *\n * @class ReactMountReady\n * @implements PooledClass\n * @internal\n */\nfunction CallbackQueue() {\n  this._callbacks = null;\n  this._contexts = null;\n}\n\nassign(CallbackQueue.prototype, {\n\n  /**\n   * Enqueues a callback to be invoked when `notifyAll` is invoked.\n   *\n   * @param {function} callback Invoked when `notifyAll` is invoked.\n   * @param {?object} context Context to call `callback` with.\n   * @internal\n   */\n  enqueue: function(callback, context) {\n    this._callbacks = this._callbacks || [];\n    this._contexts = this._contexts || [];\n    this._callbacks.push(callback);\n    this._contexts.push(context);\n  },\n\n  /**\n   * Invokes all enqueued callbacks and clears the queue. This is invoked after\n   * the DOM representation of a component has been created or updated.\n   *\n   * @internal\n   */\n  notifyAll: function() {\n    var callbacks = this._callbacks;\n    var contexts = this._contexts;\n    if (callbacks) {\n      (false ? invariant(\n        callbacks.length === contexts.length,\n        'Mismatched list of contexts in callback queue'\n      ) : invariant(callbacks.length === contexts.length));\n      this._callbacks = null;\n      this._contexts = null;\n      for (var i = 0, l = callbacks.length; i < l; i++) {\n        callbacks[i].call(contexts[i]);\n      }\n      callbacks.length = 0;\n      contexts.length = 0;\n    }\n  },\n\n  /**\n   * Resets the internal queue.\n   *\n   * @internal\n   */\n  reset: function() {\n    this._callbacks = null;\n    this._contexts = null;\n  },\n\n  /**\n   * `PooledClass` looks for this.\n   */\n  destructor: function() {\n    this.reset();\n  }\n\n});\n\nPooledClass.addPoolingTo(CallbackQueue);\n\nmodule.exports = CallbackQueue;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/CallbackQueue.js\n ** module id = 45\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/CallbackQueue.js?")},/*!*****************************************!*\
  !*** ./~/react/lib/EventPluginUtils.js ***!
  \*****************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPluginUtils\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(/*! ./EventConstants */ 7);\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\n/**\n * Injected dependencies:\n */\n\n/**\n * - `Mount`: [required] Module that can convert between React dom IDs and\n *   actual node references.\n */\nvar injection = {\n  Mount: null,\n  injectMount: function(InjectedMount) {\n    injection.Mount = InjectedMount;\n    if (false) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        InjectedMount && InjectedMount.getNode,\n        'EventPluginUtils.injection.injectMount(...): Injected Mount module ' +\n        'is missing getNode.'\n      ) : invariant(InjectedMount && InjectedMount.getNode));\n    }\n  }\n};\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\nfunction isEndish(topLevelType) {\n  return topLevelType === topLevelTypes.topMouseUp ||\n         topLevelType === topLevelTypes.topTouchEnd ||\n         topLevelType === topLevelTypes.topTouchCancel;\n}\n\nfunction isMoveish(topLevelType) {\n  return topLevelType === topLevelTypes.topMouseMove ||\n         topLevelType === topLevelTypes.topTouchMove;\n}\nfunction isStartish(topLevelType) {\n  return topLevelType === topLevelTypes.topMouseDown ||\n         topLevelType === topLevelTypes.topTouchStart;\n}\n\n\nvar validateEventDispatches;\nif (false) {\n  validateEventDispatches = function(event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchIDs = event._dispatchIDs;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var idsIsArr = Array.isArray(dispatchIDs);\n    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;\n    var listenersLen = listenersIsArr ?\n      dispatchListeners.length :\n      dispatchListeners ? 1 : 0;\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      idsIsArr === listenersIsArr && IDsLen === listenersLen,\n      'EventPluginUtils: Invalid `event`.'\n    ) : invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen));\n  };\n}\n\n/**\n * Invokes `cb(event, listener, id)`. Avoids using call if no scope is\n * provided. The `(listener,id)` pair effectively forms the \"dispatch\" but are\n * kept separate to conserve memory.\n */\nfunction forEachEventDispatch(event, cb) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchIDs = event._dispatchIDs;\n  if (false) {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and IDs are two parallel arrays that are always in sync.\n      cb(event, dispatchListeners[i], dispatchIDs[i]);\n    }\n  } else if (dispatchListeners) {\n    cb(event, dispatchListeners, dispatchIDs);\n  }\n}\n\n/**\n * Default implementation of PluginModule.executeDispatch().\n * @param {SyntheticEvent} SyntheticEvent to handle\n * @param {function} Application-level callback\n * @param {string} domID DOM id to pass to the callback.\n */\nfunction executeDispatch(event, listener, domID) {\n  event.currentTarget = injection.Mount.getNode(domID);\n  var returnValue = listener(event, domID);\n  event.currentTarget = null;\n  return returnValue;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, cb) {\n  forEachEventDispatch(event, cb);\n  event._dispatchListeners = null;\n  event._dispatchIDs = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return id of the first dispatch execution who's listener returns true, or\n * null if no listener returned true.\n */\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchIDs = event._dispatchIDs;\n  if (false) {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and IDs are two parallel arrays that are always in sync.\n      if (dispatchListeners[i](event, dispatchIDs[i])) {\n        return dispatchIDs[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchIDs)) {\n      return dispatchIDs;\n    }\n  }\n  return null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\nfunction executeDispatchesInOrderStopAtTrue(event) {\n  var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchIDs = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return The return value of executing the single dispatch.\n */\nfunction executeDirectDispatch(event) {\n  if (false) {\n    validateEventDispatches(event);\n  }\n  var dispatchListener = event._dispatchListeners;\n  var dispatchID = event._dispatchIDs;\n  (false ? invariant(\n    !Array.isArray(dispatchListener),\n    'executeDirectDispatch(...): Invalid `event`.'\n  ) : invariant(!Array.isArray(dispatchListener)));\n  var res = dispatchListener ?\n    dispatchListener(event, dispatchID) :\n    null;\n  event._dispatchListeners = null;\n  event._dispatchIDs = null;\n  return res;\n}\n\n/**\n * @param {SyntheticEvent} event\n * @return {bool} True iff number of dispatches accumulated is greater than 0.\n */\nfunction hasDispatches(event) {\n  return !!event._dispatchListeners;\n}\n\n/**\n * General utilities that are useful in creating custom Event Plugins.\n */\nvar EventPluginUtils = {\n  isEndish: isEndish,\n  isMoveish: isMoveish,\n  isStartish: isStartish,\n\n  executeDirectDispatch: executeDirectDispatch,\n  executeDispatch: executeDispatch,\n  executeDispatchesInOrder: executeDispatchesInOrder,\n  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,\n  hasDispatches: hasDispatches,\n  injection: injection,\n  useTouchEvents: false\n};\n\nmodule.exports = EventPluginUtils;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EventPluginUtils.js\n ** module id = 46\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EventPluginUtils.js?")},/*!*****************************************!*\
  !*** ./~/react/lib/LinkedValueUtils.js ***!
  \*****************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule LinkedValueUtils\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactPropTypes = __webpack_require__(/*! ./ReactPropTypes */ 81);\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\nvar hasReadOnlyValue = {\n  'button': true,\n  'checkbox': true,\n  'image': true,\n  'hidden': true,\n  'radio': true,\n  'reset': true,\n  'submit': true\n};\n\nfunction _assertSingleLink(input) {\n  (false ? invariant(\n    input.props.checkedLink == null || input.props.valueLink == null,\n    'Cannot provide a checkedLink and a valueLink. If you want to use ' +\n    'checkedLink, you probably don\\'t want to use valueLink and vice versa.'\n  ) : invariant(input.props.checkedLink == null || input.props.valueLink == null));\n}\nfunction _assertValueLink(input) {\n  _assertSingleLink(input);\n  (false ? invariant(\n    input.props.value == null && input.props.onChange == null,\n    'Cannot provide a valueLink and a value or onChange event. If you want ' +\n    'to use value or onChange, you probably don\\'t want to use valueLink.'\n  ) : invariant(input.props.value == null && input.props.onChange == null));\n}\n\nfunction _assertCheckedLink(input) {\n  _assertSingleLink(input);\n  (false ? invariant(\n    input.props.checked == null && input.props.onChange == null,\n    'Cannot provide a checkedLink and a checked property or onChange event. ' +\n    'If you want to use checked or onChange, you probably don\\'t want to ' +\n    'use checkedLink'\n  ) : invariant(input.props.checked == null && input.props.onChange == null));\n}\n\n/**\n * @param {SyntheticEvent} e change event to handle\n */\nfunction _handleLinkedValueChange(e) {\n  /*jshint validthis:true */\n  this.props.valueLink.requestChange(e.target.value);\n}\n\n/**\n  * @param {SyntheticEvent} e change event to handle\n  */\nfunction _handleLinkedCheckChange(e) {\n  /*jshint validthis:true */\n  this.props.checkedLink.requestChange(e.target.checked);\n}\n\n/**\n * Provide a linked `value` attribute for controlled forms. You should not use\n * this outside of the ReactDOM controlled form components.\n */\nvar LinkedValueUtils = {\n  Mixin: {\n    propTypes: {\n      value: function(props, propName, componentName) {\n        if (!props[propName] ||\n            hasReadOnlyValue[props.type] ||\n            props.onChange ||\n            props.readOnly ||\n            props.disabled) {\n          return null;\n        }\n        return new Error(\n          'You provided a `value` prop to a form field without an ' +\n          '`onChange` handler. This will render a read-only field. If ' +\n          'the field should be mutable use `defaultValue`. Otherwise, ' +\n          'set either `onChange` or `readOnly`.'\n        );\n      },\n      checked: function(props, propName, componentName) {\n        if (!props[propName] ||\n            props.onChange ||\n            props.readOnly ||\n            props.disabled) {\n          return null;\n        }\n        return new Error(\n          'You provided a `checked` prop to a form field without an ' +\n          '`onChange` handler. This will render a read-only field. If ' +\n          'the field should be mutable use `defaultChecked`. Otherwise, ' +\n          'set either `onChange` or `readOnly`.'\n        );\n      },\n      onChange: ReactPropTypes.func\n    }\n  },\n\n  /**\n   * @param {ReactComponent} input Form component\n   * @return {*} current value of the input either from value prop or link.\n   */\n  getValue: function(input) {\n    if (input.props.valueLink) {\n      _assertValueLink(input);\n      return input.props.valueLink.value;\n    }\n    return input.props.value;\n  },\n\n  /**\n   * @param {ReactComponent} input Form component\n   * @return {*} current checked status of the input either from checked prop\n   *             or link.\n   */\n  getChecked: function(input) {\n    if (input.props.checkedLink) {\n      _assertCheckedLink(input);\n      return input.props.checkedLink.value;\n    }\n    return input.props.checked;\n  },\n\n  /**\n   * @param {ReactComponent} input Form component\n   * @return {function} change callback either from onChange prop or link.\n   */\n  getOnChange: function(input) {\n    if (input.props.valueLink) {\n      _assertValueLink(input);\n      return _handleLinkedValueChange;\n    } else if (input.props.checkedLink) {\n      _assertCheckedLink(input);\n      return _handleLinkedCheckChange;\n    }\n    return input.props.onChange;\n  }\n};\n\nmodule.exports = LinkedValueUtils;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/LinkedValueUtils.js\n ** module id = 47\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/LinkedValueUtils.js?")},/*!********************************************!*\
  !*** ./~/react/lib/LocalEventTrapMixin.js ***!
  \********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule LocalEventTrapMixin\n */\n\n'use strict';\n\nvar ReactBrowserEventEmitter = __webpack_require__(/*! ./ReactBrowserEventEmitter */ 21);\n\nvar accumulateInto = __webpack_require__(/*! ./accumulateInto */ 57);\nvar forEachAccumulated = __webpack_require__(/*! ./forEachAccumulated */ 58);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\nfunction remove(event) {\n  event.remove();\n}\n\nvar LocalEventTrapMixin = {\n  trapBubbledEvent:function(topLevelType, handlerBaseName) {\n    (false ? invariant(this.isMounted(), 'Must be mounted to trap events') : invariant(this.isMounted()));\n    // If a component renders to null or if another component fatals and causes\n    // the state of the tree to be corrupted, `node` here can be null.\n    var node = this.getDOMNode();\n    (false ? invariant(\n      node,\n      'LocalEventTrapMixin.trapBubbledEvent(...): Requires node to be rendered.'\n    ) : invariant(node));\n    var listener = ReactBrowserEventEmitter.trapBubbledEvent(\n      topLevelType,\n      handlerBaseName,\n      node\n    );\n    this._localEventListeners =\n      accumulateInto(this._localEventListeners, listener);\n  },\n\n  // trapCapturedEvent would look nearly identical. We don't implement that\n  // method because it isn't currently needed.\n\n  componentWillUnmount:function() {\n    if (this._localEventListeners) {\n      forEachAccumulated(this._localEventListeners, remove);\n    }\n  }\n};\n\nmodule.exports = LocalEventTrapMixin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/LocalEventTrapMixin.js\n ** module id = 48\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/LocalEventTrapMixin.js?")},/*!*********************************************************!*\
  !*** ./~/react/lib/ReactComponentBrowserEnvironment.js ***!
  \*********************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactComponentBrowserEnvironment\n */\n\n/*jslint evil: true */\n\n'use strict';\n\nvar ReactDOMIDOperations = __webpack_require__(/*! ./ReactDOMIDOperations */ 76);\nvar ReactMount = __webpack_require__(/*! ./ReactMount */ 15);\n\n/**\n * Abstracts away all functionality of the reconciler that requires knowledge of\n * the browser context. TODO: These callers should be refactored to avoid the\n * need for this injection.\n */\nvar ReactComponentBrowserEnvironment = {\n\n  processChildrenUpdates:\n    ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,\n\n  replaceNodeWithMarkupByID:\n    ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,\n\n  /**\n   * If a particular environment requires that some resources be cleaned up,\n   * specify this in the injected Mixin. In the DOM, we would likely want to\n   * purge any cached node ID lookups.\n   *\n   * @private\n   */\n  unmountIDFromEnvironment: function(rootNodeID) {\n    ReactMount.purgeID(rootNodeID);\n  }\n\n};\n\nmodule.exports = ReactComponentBrowserEnvironment;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactComponentBrowserEnvironment.js\n ** module id = 49\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactComponentBrowserEnvironment.js?")},/*!**************************************************!*\
  !*** ./~/react/lib/ReactComponentEnvironment.js ***!
  \**************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactComponentEnvironment\n */\n\n'use strict';\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\nvar injected = false;\n\nvar ReactComponentEnvironment = {\n\n  /**\n   * Optionally injectable environment dependent cleanup hook. (server vs.\n   * browser etc). Example: A browser system caches DOM nodes based on component\n   * ID and must remove that cache entry when this instance is unmounted.\n   */\n  unmountIDFromEnvironment: null,\n\n  /**\n   * Optionally injectable hook for swapping out mount images in the middle of\n   * the tree.\n   */\n  replaceNodeWithMarkupByID: null,\n\n  /**\n   * Optionally injectable hook for processing a queue of child updates. Will\n   * later move into MultiChildComponents.\n   */\n  processChildrenUpdates: null,\n\n  injection: {\n    injectEnvironment: function(environment) {\n      (false ? invariant(\n        !injected,\n        'ReactCompositeComponent: injectEnvironment() can only be called once.'\n      ) : invariant(!injected));\n      ReactComponentEnvironment.unmountIDFromEnvironment =\n        environment.unmountIDFromEnvironment;\n      ReactComponentEnvironment.replaceNodeWithMarkupByID =\n        environment.replaceNodeWithMarkupByID;\n      ReactComponentEnvironment.processChildrenUpdates =\n        environment.processChildrenUpdates;\n      injected = true;\n    }\n  }\n\n};\n\nmodule.exports = ReactComponentEnvironment;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactComponentEnvironment.js\n ** module id = 50\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactComponentEnvironment.js?")},/*!*************************************!*\
  !*** ./~/react/lib/ReactContext.js ***!
  \*************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactContext\n */\n\n'use strict';\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar emptyObject = __webpack_require__(/*! ./emptyObject */ 42);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nvar didWarn = false;\n\n/**\n * Keeps track of the current context.\n *\n * The context is automatically passed down the component ownership hierarchy\n * and is accessible via `this.context` on ReactCompositeComponents.\n */\nvar ReactContext = {\n\n  /**\n   * @internal\n   * @type {object}\n   */\n  current: emptyObject,\n\n  /**\n   * Temporarily extends the current context while executing scopedCallback.\n   *\n   * A typical use case might look like\n   *\n   *  render: function() {\n   *    var children = ReactContext.withContext({foo: 'foo'}, () => (\n   *\n   *    ));\n   *    return <div>{children}</div>;\n   *  }\n   *\n   * @param {object} newContext New context to merge into the existing context\n   * @param {function} scopedCallback Callback to run with the new context\n   * @return {ReactComponent|array<ReactComponent>}\n   */\n  withContext: function(newContext, scopedCallback) {\n    if (false) {\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        didWarn,\n        'withContext is deprecated and will be removed in a future version. ' +\n        'Use a wrapper component with getChildContext instead.'\n      ) : null);\n\n      didWarn = true;\n    }\n\n    var result;\n    var previousContext = ReactContext.current;\n    ReactContext.current = assign({}, previousContext, newContext);\n    try {\n      result = scopedCallback();\n    } finally {\n      ReactContext.current = previousContext;\n    }\n    return result;\n  }\n\n};\n\nmodule.exports = ReactContext;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactContext.js\n ** module id = 51\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactContext.js?")},/*!******************************************!*\
  !*** ./~/react/lib/ReactDOMComponent.js ***!
  \******************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMComponent\n * @typechecks static-only\n */\n\n/* global hasOwnProperty:true */\n\n'use strict';\n\nvar CSSPropertyOperations = __webpack_require__(/*! ./CSSPropertyOperations */ 72);\nvar DOMProperty = __webpack_require__(/*! ./DOMProperty */ 19);\nvar DOMPropertyOperations = __webpack_require__(/*! ./DOMPropertyOperations */ 29);\nvar ReactBrowserEventEmitter = __webpack_require__(/*! ./ReactBrowserEventEmitter */ 21);\nvar ReactComponentBrowserEnvironment =\n  __webpack_require__(/*! ./ReactComponentBrowserEnvironment */ 49);\nvar ReactMount = __webpack_require__(/*! ./ReactMount */ 15);\nvar ReactMultiChild = __webpack_require__(/*! ./ReactMultiChild */ 158);\nvar ReactPerf = __webpack_require__(/*! ./ReactPerf */ 17);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar escapeTextContentForBrowser = __webpack_require__(/*! ./escapeTextContentForBrowser */ 43);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\nvar isEventSupported = __webpack_require__(/*! ./isEventSupported */ 63);\nvar keyOf = __webpack_require__(/*! ./keyOf */ 11);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nvar deleteListener = ReactBrowserEventEmitter.deleteListener;\nvar listenTo = ReactBrowserEventEmitter.listenTo;\nvar registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;\n\n// For quickly matching children type, to test if can be treated as content.\nvar CONTENT_TYPES = {'string': true, 'number': true};\n\nvar STYLE = keyOf({style: null});\n\nvar ELEMENT_NODE_TYPE = 1;\n\n/**\n * Optionally injectable operations for mutating the DOM\n */\nvar BackendIDOperations = null;\n\n/**\n * @param {?object} props\n */\nfunction assertValidProps(props) {\n  if (!props) {\n    return;\n  }\n  // Note the use of `==` which checks for null or undefined.\n  if (props.dangerouslySetInnerHTML != null) {\n    (false ? invariant(\n      props.children == null,\n      'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'\n    ) : invariant(props.children == null));\n    (false ? invariant(\n      typeof props.dangerouslySetInnerHTML === 'object' &&\n      '__html' in props.dangerouslySetInnerHTML,\n      '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' +\n      'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' +\n      'for more information.'\n    ) : invariant(typeof props.dangerouslySetInnerHTML === 'object' &&\n    '__html' in props.dangerouslySetInnerHTML));\n  }\n  if (false) {\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      props.innerHTML == null,\n      'Directly setting property `innerHTML` is not permitted. ' +\n      'For more information, lookup documentation on `dangerouslySetInnerHTML`.'\n    ) : null);\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      !props.contentEditable || props.children == null,\n      'A component is `contentEditable` and contains `children` managed by ' +\n      'React. It is now your responsibility to guarantee that none of ' +\n      'those nodes are unexpectedly modified or duplicated. This is ' +\n      'probably not intentional.'\n    ) : null);\n  }\n  (false ? invariant(\n    props.style == null || typeof props.style === 'object',\n    'The `style` prop expects a mapping from style properties to values, ' +\n    'not a string. For example, style={{marginRight: spacing + \\'em\\'}} when ' +\n    'using JSX.'\n  ) : invariant(props.style == null || typeof props.style === 'object'));\n}\n\nfunction putListener(id, registrationName, listener, transaction) {\n  if (false) {\n    // IE8 has no API for event capturing and the `onScroll` event doesn't\n    // bubble.\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      registrationName !== 'onScroll' || isEventSupported('scroll', true),\n      'This browser doesn\\'t support the `onScroll` event'\n    ) : null);\n  }\n  var container = ReactMount.findReactContainerForID(id);\n  if (container) {\n    var doc = container.nodeType === ELEMENT_NODE_TYPE ?\n      container.ownerDocument :\n      container;\n    listenTo(registrationName, doc);\n  }\n  transaction.getPutListenerQueue().enqueuePutListener(\n    id,\n    registrationName,\n    listener\n  );\n}\n\n// For HTML, certain tags should omit their close tag. We keep a whitelist for\n// those special cased tags.\n\nvar omittedCloseTags = {\n  'area': true,\n  'base': true,\n  'br': true,\n  'col': true,\n  'embed': true,\n  'hr': true,\n  'img': true,\n  'input': true,\n  'keygen': true,\n  'link': true,\n  'meta': true,\n  'param': true,\n  'source': true,\n  'track': true,\n  'wbr': true\n  // NOTE: menuitem's close tag should be omitted, but that causes problems.\n};\n\n// We accept any tag to be rendered but since this gets injected into abitrary\n// HTML, we want to make sure that it's a safe tag.\n// http://www.w3.org/TR/REC-xml/#NT-Name\n\nvar VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/; // Simplified subset\nvar validatedTagCache = {};\nvar hasOwnProperty = {}.hasOwnProperty;\n\nfunction validateDangerousTag(tag) {\n  if (!hasOwnProperty.call(validatedTagCache, tag)) {\n    (false ? invariant(VALID_TAG_REGEX.test(tag), 'Invalid tag: %s', tag) : invariant(VALID_TAG_REGEX.test(tag)));\n    validatedTagCache[tag] = true;\n  }\n}\n\n/**\n * Creates a new React class that is idempotent and capable of containing other\n * React components. It accepts event listeners and DOM properties that are\n * valid according to `DOMProperty`.\n *\n *  - Event listeners: `onClick`, `onMouseDown`, etc.\n *  - DOM properties: `className`, `name`, `title`, etc.\n *\n * The `style` property functions differently from the DOM API. It accepts an\n * object mapping of style properties to values.\n *\n * @constructor ReactDOMComponent\n * @extends ReactMultiChild\n */\nfunction ReactDOMComponent(tag) {\n  validateDangerousTag(tag);\n  this._tag = tag;\n  this._renderedChildren = null;\n  this._previousStyleCopy = null;\n  this._rootNodeID = null;\n}\n\nReactDOMComponent.displayName = 'ReactDOMComponent';\n\nReactDOMComponent.Mixin = {\n\n  construct: function(element) {\n    this._currentElement = element;\n  },\n\n  /**\n   * Generates root tag markup then recurses. This method has side effects and\n   * is not idempotent.\n   *\n   * @internal\n   * @param {string} rootID The root DOM ID for this node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {string} The computed markup.\n   */\n  mountComponent: function(rootID, transaction, context) {\n    this._rootNodeID = rootID;\n    assertValidProps(this._currentElement.props);\n    var closeTag = omittedCloseTags[this._tag] ? '' : '</' + this._tag + '>';\n    return (\n      this._createOpenTagMarkupAndPutListeners(transaction) +\n      this._createContentMarkup(transaction, context) +\n      closeTag\n    );\n  },\n\n  /**\n   * Creates markup for the open tag and all attributes.\n   *\n   * This method has side effects because events get registered.\n   *\n   * Iterating over object properties is faster than iterating over arrays.\n   * @see http://jsperf.com/obj-vs-arr-iteration\n   *\n   * @private\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {string} Markup of opening tag.\n   */\n  _createOpenTagMarkupAndPutListeners: function(transaction) {\n    var props = this._currentElement.props;\n    var ret = '<' + this._tag;\n\n    for (var propKey in props) {\n      if (!props.hasOwnProperty(propKey)) {\n        continue;\n      }\n      var propValue = props[propKey];\n      if (propValue == null) {\n        continue;\n      }\n      if (registrationNameModules.hasOwnProperty(propKey)) {\n        putListener(this._rootNodeID, propKey, propValue, transaction);\n      } else {\n        if (propKey === STYLE) {\n          if (propValue) {\n            propValue = this._previousStyleCopy = assign({}, props.style);\n          }\n          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);\n        }\n        var markup =\n          DOMPropertyOperations.createMarkupForProperty(propKey, propValue);\n        if (markup) {\n          ret += ' ' + markup;\n        }\n      }\n    }\n\n    // For static pages, no need to put React ID and checksum. Saves lots of\n    // bytes.\n    if (transaction.renderToStaticMarkup) {\n      return ret + '>';\n    }\n\n    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);\n    return ret + ' ' + markupForID + '>';\n  },\n\n  /**\n   * Creates markup for the content between the tags.\n   *\n   * @private\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {object} context\n   * @return {string} Content markup.\n   */\n  _createContentMarkup: function(transaction, context) {\n    var prefix = '';\n    if (this._tag === 'listing' ||\n        this._tag === 'pre' ||\n        this._tag === 'textarea') {\n      // Add an initial newline because browsers ignore the first newline in\n      // a <listing>, <pre>, or <textarea> as an \"authoring convenience\" -- see\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody.\n      prefix = '\\n';\n    }\n\n    var props = this._currentElement.props;\n\n    // Intentional use of != to avoid catching zero/false.\n    var innerHTML = props.dangerouslySetInnerHTML;\n    if (innerHTML != null) {\n      if (innerHTML.__html != null) {\n        return prefix + innerHTML.__html;\n      }\n    } else {\n      var contentToUse =\n        CONTENT_TYPES[typeof props.children] ? props.children : null;\n      var childrenToUse = contentToUse != null ? null : props.children;\n      if (contentToUse != null) {\n        return prefix + escapeTextContentForBrowser(contentToUse);\n      } else if (childrenToUse != null) {\n        var mountImages = this.mountChildren(\n          childrenToUse,\n          transaction,\n          context\n        );\n        return prefix + mountImages.join('');\n      }\n    }\n    return prefix;\n  },\n\n  receiveComponent: function(nextElement, transaction, context) {\n    var prevElement = this._currentElement;\n    this._currentElement = nextElement;\n    this.updateComponent(transaction, prevElement, nextElement, context);\n  },\n\n  /**\n   * Updates a native DOM component after it has already been allocated and\n   * attached to the DOM. Reconciles the root DOM node, then recurses.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @param {ReactElement} prevElement\n   * @param {ReactElement} nextElement\n   * @internal\n   * @overridable\n   */\n  updateComponent: function(transaction, prevElement, nextElement, context) {\n    assertValidProps(this._currentElement.props);\n    this._updateDOMProperties(prevElement.props, transaction);\n    this._updateDOMChildren(prevElement.props, transaction, context);\n  },\n\n  /**\n   * Reconciles the properties by detecting differences in property values and\n   * updating the DOM as necessary. This function is probably the single most\n   * critical path for performance optimization.\n   *\n   * TODO: Benchmark whether checking for changed values in memory actually\n   *       improves performance (especially statically positioned elements).\n   * TODO: Benchmark the effects of putting this at the top since 99% of props\n   *       do not change for a given reconciliation.\n   * TODO: Benchmark areas that can be improved with caching.\n   *\n   * @private\n   * @param {object} lastProps\n   * @param {ReactReconcileTransaction} transaction\n   */\n  _updateDOMProperties: function(lastProps, transaction) {\n    var nextProps = this._currentElement.props;\n    var propKey;\n    var styleName;\n    var styleUpdates;\n    for (propKey in lastProps) {\n      if (nextProps.hasOwnProperty(propKey) ||\n         !lastProps.hasOwnProperty(propKey)) {\n        continue;\n      }\n      if (propKey === STYLE) {\n        var lastStyle = this._previousStyleCopy;\n        for (styleName in lastStyle) {\n          if (lastStyle.hasOwnProperty(styleName)) {\n            styleUpdates = styleUpdates || {};\n            styleUpdates[styleName] = '';\n          }\n        }\n        this._previousStyleCopy = null;\n      } else if (registrationNameModules.hasOwnProperty(propKey)) {\n        deleteListener(this._rootNodeID, propKey);\n      } else if (\n          DOMProperty.isStandardName[propKey] ||\n          DOMProperty.isCustomAttribute(propKey)) {\n        BackendIDOperations.deletePropertyByID(\n          this._rootNodeID,\n          propKey\n        );\n      }\n    }\n    for (propKey in nextProps) {\n      var nextProp = nextProps[propKey];\n      var lastProp = propKey === STYLE ?\n        this._previousStyleCopy :\n        lastProps[propKey];\n      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {\n        continue;\n      }\n      if (propKey === STYLE) {\n        if (nextProp) {\n          nextProp = this._previousStyleCopy = assign({}, nextProp);\n        } else {\n          this._previousStyleCopy = null;\n        }\n        if (lastProp) {\n          // Unset styles on `lastProp` but not on `nextProp`.\n          for (styleName in lastProp) {\n            if (lastProp.hasOwnProperty(styleName) &&\n                (!nextProp || !nextProp.hasOwnProperty(styleName))) {\n              styleUpdates = styleUpdates || {};\n              styleUpdates[styleName] = '';\n            }\n          }\n          // Update styles that changed since `lastProp`.\n          for (styleName in nextProp) {\n            if (nextProp.hasOwnProperty(styleName) &&\n                lastProp[styleName] !== nextProp[styleName]) {\n              styleUpdates = styleUpdates || {};\n              styleUpdates[styleName] = nextProp[styleName];\n            }\n          }\n        } else {\n          // Relies on `updateStylesByID` not mutating `styleUpdates`.\n          styleUpdates = nextProp;\n        }\n      } else if (registrationNameModules.hasOwnProperty(propKey)) {\n        putListener(this._rootNodeID, propKey, nextProp, transaction);\n      } else if (\n          DOMProperty.isStandardName[propKey] ||\n          DOMProperty.isCustomAttribute(propKey)) {\n        BackendIDOperations.updatePropertyByID(\n          this._rootNodeID,\n          propKey,\n          nextProp\n        );\n      }\n    }\n    if (styleUpdates) {\n      BackendIDOperations.updateStylesByID(\n        this._rootNodeID,\n        styleUpdates\n      );\n    }\n  },\n\n  /**\n   * Reconciles the children with the various properties that affect the\n   * children content.\n   *\n   * @param {object} lastProps\n   * @param {ReactReconcileTransaction} transaction\n   */\n  _updateDOMChildren: function(lastProps, transaction, context) {\n    var nextProps = this._currentElement.props;\n\n    var lastContent =\n      CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;\n    var nextContent =\n      CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;\n\n    var lastHtml =\n      lastProps.dangerouslySetInnerHTML &&\n      lastProps.dangerouslySetInnerHTML.__html;\n    var nextHtml =\n      nextProps.dangerouslySetInnerHTML &&\n      nextProps.dangerouslySetInnerHTML.__html;\n\n    // Note the use of `!=` which checks for null or undefined.\n    var lastChildren = lastContent != null ? null : lastProps.children;\n    var nextChildren = nextContent != null ? null : nextProps.children;\n\n    // If we're switching from children to content/html or vice versa, remove\n    // the old content\n    var lastHasContentOrHtml = lastContent != null || lastHtml != null;\n    var nextHasContentOrHtml = nextContent != null || nextHtml != null;\n    if (lastChildren != null && nextChildren == null) {\n      this.updateChildren(null, transaction, context);\n    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {\n      this.updateTextContent('');\n    }\n\n    if (nextContent != null) {\n      if (lastContent !== nextContent) {\n        this.updateTextContent('' + nextContent);\n      }\n    } else if (nextHtml != null) {\n      if (lastHtml !== nextHtml) {\n        BackendIDOperations.updateInnerHTMLByID(\n          this._rootNodeID,\n          nextHtml\n        );\n      }\n    } else if (nextChildren != null) {\n      this.updateChildren(nextChildren, transaction, context);\n    }\n  },\n\n  /**\n   * Destroys all event registrations for this instance. Does not remove from\n   * the DOM. That must be done by the parent.\n   *\n   * @internal\n   */\n  unmountComponent: function() {\n    this.unmountChildren();\n    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);\n    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);\n    this._rootNodeID = null;\n  }\n\n};\n\nReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {\n  mountComponent: 'mountComponent',\n  updateComponent: 'updateComponent'\n});\n\nassign(\n  ReactDOMComponent.prototype,\n  ReactDOMComponent.Mixin,\n  ReactMultiChild.Mixin\n);\n\nReactDOMComponent.injection = {\n  injectIDOperations: function(IDOperations) {\n    ReactDOMComponent.BackendIDOperations = BackendIDOperations = IDOperations;\n  }\n};\n\nmodule.exports = ReactDOMComponent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMComponent.js\n ** module id = 52\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMComponent.js?")},/*!********************************************!*\
  !*** ./~/react/lib/ReactEmptyComponent.js ***!
  \********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactEmptyComponent\n */\n\n'use strict';\n\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\nvar ReactInstanceMap = __webpack_require__(/*! ./ReactInstanceMap */ 24);\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\nvar component;\n// This registry keeps track of the React IDs of the components that rendered to\n// `null` (in reality a placeholder such as `noscript`)\nvar nullComponentIDsRegistry = {};\n\nvar ReactEmptyComponentInjection = {\n  injectEmptyComponent: function(emptyComponent) {\n    component = ReactElement.createFactory(emptyComponent);\n  }\n};\n\nvar ReactEmptyComponentType = function() {};\nReactEmptyComponentType.prototype.componentDidMount = function() {\n  var internalInstance = ReactInstanceMap.get(this);\n  // TODO: Make sure we run these methods in the correct order, we shouldn't\n  // need this check. We're going to assume if we're here it means we ran\n  // componentWillUnmount already so there is no internal instance (it gets\n  // removed as part of the unmounting process).\n  if (!internalInstance) {\n    return;\n  }\n  registerNullComponentID(internalInstance._rootNodeID);\n};\nReactEmptyComponentType.prototype.componentWillUnmount = function() {\n  var internalInstance = ReactInstanceMap.get(this);\n  // TODO: Get rid of this check. See TODO in componentDidMount.\n  if (!internalInstance) {\n    return;\n  }\n  deregisterNullComponentID(internalInstance._rootNodeID);\n};\nReactEmptyComponentType.prototype.render = function() {\n  (false ? invariant(\n    component,\n    'Trying to return null from a render, but no null placeholder component ' +\n    'was injected.'\n  ) : invariant(component));\n  return component();\n};\n\nvar emptyElement = ReactElement.createElement(ReactEmptyComponentType);\n\n/**\n * Mark the component as having rendered to null.\n * @param {string} id Component's `_rootNodeID`.\n */\nfunction registerNullComponentID(id) {\n  nullComponentIDsRegistry[id] = true;\n}\n\n/**\n * Unmark the component as having rendered to null: it renders to something now.\n * @param {string} id Component's `_rootNodeID`.\n */\nfunction deregisterNullComponentID(id) {\n  delete nullComponentIDsRegistry[id];\n}\n\n/**\n * @param {string} id Component's `_rootNodeID`.\n * @return {boolean} True if the component is rendered to null.\n */\nfunction isNullComponentID(id) {\n  return !!nullComponentIDsRegistry[id];\n}\n\nvar ReactEmptyComponent = {\n  emptyElement: emptyElement,\n  injection: ReactEmptyComponentInjection,\n  isNullComponentID: isNullComponentID\n};\n\nmodule.exports = ReactEmptyComponent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactEmptyComponent.js\n ** module id = 53\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactEmptyComponent.js?")},/*!***************************************!*\
  !*** ./~/react/lib/ReactLifeCycle.js ***!
  \***************************************/
function(module,exports){eval("/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactLifeCycle\n */\n\n'use strict';\n\n/**\n * This module manages the bookkeeping when a component is in the process\n * of being mounted or being unmounted. This is used as a way to enforce\n * invariants (or warnings) when it is not recommended to call\n * setState/forceUpdate.\n *\n * currentlyMountingInstance: During the construction phase, it is not possible\n * to trigger an update since the instance is not fully mounted yet. However, we\n * currently allow this as a convenience for mutating the initial state.\n *\n * currentlyUnmountingInstance: During the unmounting phase, the instance is\n * still mounted and can therefore schedule an update. However, this is not\n * recommended and probably an error since it's about to be unmounted.\n * Therefore we still want to trigger in an error for that case.\n */\n\nvar ReactLifeCycle = {\n  currentlyMountingInstance: null,\n  currentlyUnmountingInstance: null\n};\n\nmodule.exports = ReactLifeCycle;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactLifeCycle.js\n ** module id = 54\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactLifeCycle.js?")},/*!***********************************************!*\
  !*** ./~/react/lib/ReactPropTypeLocations.js ***!
  \***********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPropTypeLocations\n */\n\n'use strict';\n\nvar keyMirror = __webpack_require__(/*! ./keyMirror */ 34);\n\nvar ReactPropTypeLocations = keyMirror({\n  prop: null,\n  context: null,\n  childContext: null\n});\n\nmodule.exports = ReactPropTypeLocations;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactPropTypeLocations.js\n ** module id = 55\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactPropTypeLocations.js?")},/*!*****************************************!*\
  !*** ./~/react/lib/ReactUpdateQueue.js ***!
  \*****************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdateQueue\n */\n\n'use strict';\n\nvar ReactLifeCycle = __webpack_require__(/*! ./ReactLifeCycle */ 54);\nvar ReactCurrentOwner = __webpack_require__(/*! ./ReactCurrentOwner */ 14);\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\nvar ReactInstanceMap = __webpack_require__(/*! ./ReactInstanceMap */ 24);\nvar ReactUpdates = __webpack_require__(/*! ./ReactUpdates */ 9);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nfunction enqueueUpdate(internalInstance) {\n  if (internalInstance !== ReactLifeCycle.currentlyMountingInstance) {\n    // If we're in a componentWillMount handler, don't enqueue a rerender\n    // because ReactUpdates assumes we're in a browser context (which is\n    // wrong for server rendering) and we're about to do a render anyway.\n    // See bug in #1740.\n    ReactUpdates.enqueueUpdate(internalInstance);\n  }\n}\n\nfunction getInternalInstanceReadyForUpdate(publicInstance, callerName) {\n  (false ? invariant(\n    ReactCurrentOwner.current == null,\n    '%s(...): Cannot update during an existing state transition ' +\n    '(such as within `render`). Render methods should be a pure function ' +\n    'of props and state.',\n    callerName\n  ) : invariant(ReactCurrentOwner.current == null));\n\n  var internalInstance = ReactInstanceMap.get(publicInstance);\n  if (!internalInstance) {\n    if (false) {\n      // Only warn when we have a callerName. Otherwise we should be silent.\n      // We're probably calling from enqueueCallback. We don't want to warn\n      // there because we already warned for the corresponding lifecycle method.\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        !callerName,\n        '%s(...): Can only update a mounted or mounting component. ' +\n        'This usually means you called %s() on an unmounted ' +\n        'component. This is a no-op.',\n        callerName,\n        callerName\n      ) : null);\n    }\n    return null;\n  }\n\n  if (internalInstance === ReactLifeCycle.currentlyUnmountingInstance) {\n    return null;\n  }\n\n  return internalInstance;\n}\n\n/**\n * ReactUpdateQueue allows for state updates to be scheduled into a later\n * reconciliation step.\n */\nvar ReactUpdateQueue = {\n\n  /**\n   * Enqueue a callback that will be executed after all the pending updates\n   * have processed.\n   *\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\n   * @param {?function} callback Called after state is updated.\n   * @internal\n   */\n  enqueueCallback: function(publicInstance, callback) {\n    (false ? invariant(\n      typeof callback === 'function',\n      'enqueueCallback(...): You called `setProps`, `replaceProps`, ' +\n      '`setState`, `replaceState`, or `forceUpdate` with a callback that ' +\n      'isn\\'t callable.'\n    ) : invariant(typeof callback === 'function'));\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);\n\n    // Previously we would throw an error if we didn't have an internal\n    // instance. Since we want to make it a no-op instead, we mirror the same\n    // behavior we have in other enqueue* methods.\n    // We also need to ignore callbacks in componentWillMount. See\n    // enqueueUpdates.\n    if (!internalInstance ||\n        internalInstance === ReactLifeCycle.currentlyMountingInstance) {\n      return null;\n    }\n\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n    // TODO: The callback here is ignored when setState is called from\n    // componentWillMount. Either fix it or disallow doing so completely in\n    // favor of getInitialState. Alternatively, we can disallow\n    // componentWillMount during server-side rendering.\n    enqueueUpdate(internalInstance);\n  },\n\n  enqueueCallbackInternal: function(internalInstance, callback) {\n    (false ? invariant(\n      typeof callback === 'function',\n      'enqueueCallback(...): You called `setProps`, `replaceProps`, ' +\n      '`setState`, `replaceState`, or `forceUpdate` with a callback that ' +\n      'isn\\'t callable.'\n    ) : invariant(typeof callback === 'function'));\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldUpdateComponent`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @internal\n   */\n  enqueueForceUpdate: function(publicInstance) {\n    var internalInstance = getInternalInstanceReadyForUpdate(\n      publicInstance,\n      'forceUpdate'\n    );\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingForceUpdate = true;\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @internal\n   */\n  enqueueReplaceState: function(publicInstance, completeState) {\n    var internalInstance = getInternalInstanceReadyForUpdate(\n      publicInstance,\n      'replaceState'\n    );\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingStateQueue = [completeState];\n    internalInstance._pendingReplaceState = true;\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @internal\n   */\n  enqueueSetState: function(publicInstance, partialState) {\n    var internalInstance = getInternalInstanceReadyForUpdate(\n      publicInstance,\n      'setState'\n    );\n\n    if (!internalInstance) {\n      return;\n    }\n\n    var queue =\n      internalInstance._pendingStateQueue ||\n      (internalInstance._pendingStateQueue = []);\n    queue.push(partialState);\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialProps Subset of the next props.\n   * @internal\n   */\n  enqueueSetProps: function(publicInstance, partialProps) {\n    var internalInstance = getInternalInstanceReadyForUpdate(\n      publicInstance,\n      'setProps'\n    );\n\n    if (!internalInstance) {\n      return;\n    }\n\n    (false ? invariant(\n      internalInstance._isTopLevel,\n      'setProps(...): You called `setProps` on a ' +\n      'component with a parent. This is an anti-pattern since props will ' +\n      'get reactively updated when rendered. Instead, change the owner\\'s ' +\n      '`render` method to pass the correct value as props to the component ' +\n      'where it is created.'\n    ) : invariant(internalInstance._isTopLevel));\n\n    // Merge with the pending element if it exists, otherwise with existing\n    // element props.\n    var element = internalInstance._pendingElement ||\n                  internalInstance._currentElement;\n    var props = assign({}, element.props, partialProps);\n    internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(\n      element,\n      props\n    );\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Replaces all of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} props New props.\n   * @internal\n   */\n  enqueueReplaceProps: function(publicInstance, props) {\n    var internalInstance = getInternalInstanceReadyForUpdate(\n      publicInstance,\n      'replaceProps'\n    );\n\n    if (!internalInstance) {\n      return;\n    }\n\n    (false ? invariant(\n      internalInstance._isTopLevel,\n      'replaceProps(...): You called `replaceProps` on a ' +\n      'component with a parent. This is an anti-pattern since props will ' +\n      'get reactively updated when rendered. Instead, change the owner\\'s ' +\n      '`render` method to pass the correct value as props to the component ' +\n      'where it is created.'\n    ) : invariant(internalInstance._isTopLevel));\n\n    // Merge with the pending element if it exists, otherwise with existing\n    // element props.\n    var element = internalInstance._pendingElement ||\n                  internalInstance._currentElement;\n    internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(\n      element,\n      props\n    );\n\n    enqueueUpdate(internalInstance);\n  },\n\n  enqueueElementInternal: function(internalInstance, newElement) {\n    internalInstance._pendingElement = newElement;\n    enqueueUpdate(internalInstance);\n  }\n\n};\n\nmodule.exports = ReactUpdateQueue;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactUpdateQueue.js\n ** module id = 56\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactUpdateQueue.js?")},/*!***************************************!*\
  !*** ./~/react/lib/accumulateInto.js ***!
  \***************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule accumulateInto\n */\n\n'use strict';\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\n/**\n *\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  (false ? invariant(\n    next != null,\n    'accumulateInto(...): Accumulated items must not be null or undefined.'\n  ) : invariant(next != null));\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  var currentIsArray = Array.isArray(current);\n  var nextIsArray = Array.isArray(next);\n\n  if (currentIsArray && nextIsArray) {\n    current.push.apply(current, next);\n    return current;\n  }\n\n  if (currentIsArray) {\n    current.push(next);\n    return current;\n  }\n\n  if (nextIsArray) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\nmodule.exports = accumulateInto;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/accumulateInto.js\n ** module id = 57\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/accumulateInto.js?")},/*!*******************************************!*\
  !*** ./~/react/lib/forEachAccumulated.js ***!
  \*******************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule forEachAccumulated\n */\n\n'use strict';\n\n/**\n * @param {array} an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n */\nvar forEachAccumulated = function(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n};\n\nmodule.exports = forEachAccumulated;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/forEachAccumulated.js\n ** module id = 58\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/forEachAccumulated.js?")},/*!*****************************************!*\
  !*** ./~/react/lib/getEventCharCode.js ***!
  \*****************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getEventCharCode\n * @typechecks static-only\n */\n\n'use strict';\n\n/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `charCode` property.\n */\nfunction getEventCharCode(nativeEvent) {\n  var charCode;\n  var keyCode = nativeEvent.keyCode;\n\n  if ('charCode' in nativeEvent) {\n    charCode = nativeEvent.charCode;\n\n    // FF does not set `charCode` for the Enter-key, check against `keyCode`.\n    if (charCode === 0 && keyCode === 13) {\n      charCode = 13;\n    }\n  } else {\n    // IE8 does not implement `charCode`, but `keyCode` has the correct value.\n    charCode = keyCode;\n  }\n\n  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n  // Must not discard the (non-)printable Enter-key.\n  if (charCode >= 32 || charCode === 13) {\n    return charCode;\n  }\n\n  return 0;\n}\n\nmodule.exports = getEventCharCode;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getEventCharCode.js\n ** module id = 59\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getEventCharCode.js?")},/*!**********************************************!*\
  !*** ./~/react/lib/getEventModifierState.js ***!
  \**********************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getEventModifierState\n * @typechecks static-only\n */\n\n'use strict';\n\n/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */\n\nvar modifierKeyToProp = {\n  'Alt': 'altKey',\n  'Control': 'ctrlKey',\n  'Meta': 'metaKey',\n  'Shift': 'shiftKey'\n};\n\n// IE8 does not implement getModifierState so we simply map it to the only\n// modifier keys exposed by the event itself, does not support Lock-keys.\n// Currently, all major browsers except Chrome seems to support Lock-keys.\nfunction modifierStateGetter(keyArg) {\n  /*jshint validthis:true */\n  var syntheticEvent = this;\n  var nativeEvent = syntheticEvent.nativeEvent;\n  if (nativeEvent.getModifierState) {\n    return nativeEvent.getModifierState(keyArg);\n  }\n  var keyProp = modifierKeyToProp[keyArg];\n  return keyProp ? !!nativeEvent[keyProp] : false;\n}\n\nfunction getEventModifierState(nativeEvent) {\n  return modifierStateGetter;\n}\n\nmodule.exports = getEventModifierState;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getEventModifierState.js\n ** module id = 60\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getEventModifierState.js?")},/*!***************************************!*\
  !*** ./~/react/lib/getEventTarget.js ***!
  \***************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getEventTarget\n * @typechecks static-only\n */\n\n'use strict';\n\n/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */\nfunction getEventTarget(nativeEvent) {\n  var target = nativeEvent.target || nativeEvent.srcElement || window;\n  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n  // @see http://www.quirksmode.org/js/events_properties.html\n  return target.nodeType === 3 ? target.parentNode : target;\n}\n\nmodule.exports = getEventTarget;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getEventTarget.js\n ** module id = 61\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getEventTarget.js?")},/*!**************************************************!*\
  !*** ./~/react/lib/instantiateReactComponent.js ***!
  \**************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule instantiateReactComponent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactCompositeComponent = __webpack_require__(/*! ./ReactCompositeComponent */ 140);\nvar ReactEmptyComponent = __webpack_require__(/*! ./ReactEmptyComponent */ 53);\nvar ReactNativeComponent = __webpack_require__(/*! ./ReactNativeComponent */ 38);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\n// To avoid a cyclic dependency, we create the final class in this module\nvar ReactCompositeComponentWrapper = function() { };\nassign(\n  ReactCompositeComponentWrapper.prototype,\n  ReactCompositeComponent.Mixin,\n  {\n    _instantiateReactComponent: instantiateReactComponent\n  }\n);\n\n/**\n * Check if the type reference is a known internal type. I.e. not a user\n * provided composite type.\n *\n * @param {function} type\n * @return {boolean} Returns true if this is a valid internal type.\n */\nfunction isInternalComponentType(type) {\n  return (\n    typeof type === 'function' &&\n    typeof type.prototype !== 'undefined' &&\n    typeof type.prototype.mountComponent === 'function' &&\n    typeof type.prototype.receiveComponent === 'function'\n  );\n}\n\n/**\n * Given a ReactNode, create an instance that will actually be mounted.\n *\n * @param {ReactNode} node\n * @param {*} parentCompositeType The composite type that resolved this.\n * @return {object} A new instance of the element's constructor.\n * @protected\n */\nfunction instantiateReactComponent(node, parentCompositeType) {\n  var instance;\n\n  if (node === null || node === false) {\n    node = ReactEmptyComponent.emptyElement;\n  }\n\n  if (typeof node === 'object') {\n    var element = node;\n    if (false) {\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        element && (typeof element.type === 'function' ||\n                    typeof element.type === 'string'),\n        'Only functions or strings can be mounted as React components.'\n      ) : null);\n    }\n\n    // Special case string values\n    if (parentCompositeType === element.type &&\n        typeof element.type === 'string') {\n      // Avoid recursion if the wrapper renders itself.\n      instance = ReactNativeComponent.createInternalComponent(element);\n      // All native components are currently wrapped in a composite so we're\n      // safe to assume that this is what we should instantiate.\n    } else if (isInternalComponentType(element.type)) {\n      // This is temporarily available for custom components that are not string\n      // represenations. I.e. ART. Once those are updated to use the string\n      // representation, we can drop this code path.\n      instance = new element.type(element);\n    } else {\n      instance = new ReactCompositeComponentWrapper();\n    }\n  } else if (typeof node === 'string' || typeof node === 'number') {\n    instance = ReactNativeComponent.createInstanceForText(node);\n  } else {\n    (false ? invariant(\n      false,\n      'Encountered invalid React node of type %s',\n      typeof node\n    ) : invariant(false));\n  }\n\n  if (false) {\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      typeof instance.construct === 'function' &&\n      typeof instance.mountComponent === 'function' &&\n      typeof instance.receiveComponent === 'function' &&\n      typeof instance.unmountComponent === 'function',\n      'Only React Components can be mounted.'\n    ) : null);\n  }\n\n  // Sets up the instance. This can probably just move into the constructor now.\n  instance.construct(node);\n\n  // These two fields are used by the DOM and ART diffing algorithms\n  // respectively. Instead of using expandos on components, we should be\n  // storing the state needed by the diffing algorithms elsewhere.\n  instance._mountIndex = 0;\n  instance._mountImage = null;\n\n  if (false) {\n    instance._isOwnerNecessary = false;\n    instance._warnedAboutRefsInRender = false;\n  }\n\n  // Internal instances should fully constructed at this point, so they should\n  // not get any new fields added to them at this point.\n  if (false) {\n    if (Object.preventExtensions) {\n      Object.preventExtensions(instance);\n    }\n  }\n\n  return instance;\n}\n\nmodule.exports = instantiateReactComponent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/instantiateReactComponent.js\n ** module id = 62\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/instantiateReactComponent.js?")},/*!*****************************************!*\
  !*** ./~/react/lib/isEventSupported.js ***!
  \*****************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isEventSupported\n */\n\n'use strict';\n\nvar ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ 6);\n\nvar useHasFeature;\nif (ExecutionEnvironment.canUseDOM) {\n  useHasFeature =\n    document.implementation &&\n    document.implementation.hasFeature &&\n    // always returns true in newer browsers as per the standard.\n    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n    document.implementation.hasFeature('', '') !== true;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @param {?boolean} capture Check if the capture phase is supported.\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix, capture) {\n  if (!ExecutionEnvironment.canUseDOM ||\n      capture && !('addEventListener' in document)) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in document;\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nmodule.exports = isEventSupported;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/isEventSupported.js\n ** module id = 63\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/isEventSupported.js?")},/*!*************************************!*\
  !*** ./~/react/lib/setInnerHTML.js ***!
  \*************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule setInnerHTML\n */\n\n/* globals MSApp */\n\n'use strict';\n\nvar ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ 6);\n\nvar WHITESPACE_TEST = /^[ \\r\\n\\t\\f]/;\nvar NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \\r\\n\\t\\f\\/>]/;\n\n/**\n * Set the innerHTML property of a node, ensuring that whitespace is preserved\n * even in IE8.\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */\nvar setInnerHTML = function(node, html) {\n  node.innerHTML = html;\n};\n\n// Win8 apps: Allow all html to be inserted\nif (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {\n  setInnerHTML = function(node, html) {\n    MSApp.execUnsafeLocalFunction(function() {\n      node.innerHTML = html;\n    });\n  };\n}\n\nif (ExecutionEnvironment.canUseDOM) {\n  // IE8: When updating a just created node with innerHTML only leading\n  // whitespace is removed. When updating an existing node with innerHTML\n  // whitespace in root TextNodes is also collapsed.\n  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html\n\n  // Feature detection; only IE8 is known to behave improperly like this.\n  var testElement = document.createElement('div');\n  testElement.innerHTML = ' ';\n  if (testElement.innerHTML === '') {\n    setInnerHTML = function(node, html) {\n      // Magic theory: IE8 supposedly differentiates between added and updated\n      // nodes when processing innerHTML, innerHTML on updated nodes suffers\n      // from worse whitespace behavior. Re-adding a node like this triggers\n      // the initial and more favorable whitespace behavior.\n      // TODO: What to do on a detached node?\n      if (node.parentNode) {\n        node.parentNode.replaceChild(node, node);\n      }\n\n      // We also implement a workaround for non-visible tags disappearing into\n      // thin air on IE8, this only happens if there is no visible text\n      // in-front of the non-visible tags. Piggyback on the whitespace fix\n      // and simply check if any non-visible tags appear in the source.\n      if (WHITESPACE_TEST.test(html) ||\n          html[0] === '<' && NONVISIBLE_TEST.test(html)) {\n        // Recover leading whitespace by temporarily prepending any character.\n        // \\uFEFF has the potential advantage of being zero-width/invisible.\n        node.innerHTML = '\\uFEFF' + html;\n\n        // deleteData leaves an empty `TextNode` which offsets the index of all\n        // children. Definitely want to avoid this.\n        var textNode = node.firstChild;\n        if (textNode.data.length === 1) {\n          node.removeChild(textNode);\n        } else {\n          textNode.deleteData(0, 1);\n        }\n      } else {\n        node.innerHTML = html;\n      }\n    };\n  }\n}\n\nmodule.exports = setInnerHTML;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/setInnerHTML.js\n ** module id = 64\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/setInnerHTML.js?")},/*!***************************************************!*\
  !*** ./~/react/lib/shouldUpdateReactComponent.js ***!
  \***************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule shouldUpdateReactComponent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\n/**\n * Given a `prevElement` and `nextElement`, determines if the existing\n * instance should be updated as opposed to being destroyed or replaced by a new\n * instance. Both arguments are elements. This ensures that this logic can\n * operate on stateless trees without any backing instance.\n *\n * @param {?object} prevElement\n * @param {?object} nextElement\n * @return {boolean} True if the existing instance should be updated.\n * @protected\n */\nfunction shouldUpdateReactComponent(prevElement, nextElement) {\n  if (prevElement != null && nextElement != null) {\n    var prevType = typeof prevElement;\n    var nextType = typeof nextElement;\n    if (prevType === 'string' || prevType === 'number') {\n      return (nextType === 'string' || nextType === 'number');\n    } else {\n      if (nextType === 'object' &&\n          prevElement.type === nextElement.type &&\n          prevElement.key === nextElement.key) {\n        var ownersMatch = prevElement._owner === nextElement._owner;\n        var prevName = null;\n        var nextName = null;\n        var nextDisplayName = null;\n        if (false) {\n          if (!ownersMatch) {\n            if (prevElement._owner != null &&\n                prevElement._owner.getPublicInstance() != null &&\n                prevElement._owner.getPublicInstance().constructor != null) {\n              prevName =\n                prevElement._owner.getPublicInstance().constructor.displayName;\n            }\n            if (nextElement._owner != null &&\n                nextElement._owner.getPublicInstance() != null &&\n                nextElement._owner.getPublicInstance().constructor != null) {\n              nextName =\n                nextElement._owner.getPublicInstance().constructor.displayName;\n            }\n            if (nextElement.type != null &&\n                nextElement.type.displayName != null) {\n              nextDisplayName = nextElement.type.displayName;\n            }\n            if (nextElement.type != null && typeof nextElement.type === 'string') {\n              nextDisplayName = nextElement.type;\n            }\n            if (typeof nextElement.type !== 'string' ||\n                nextElement.type === 'input' ||\n                nextElement.type === 'textarea') {\n              if ((prevElement._owner != null &&\n                  prevElement._owner._isOwnerNecessary === false) ||\n                  (nextElement._owner != null &&\n                  nextElement._owner._isOwnerNecessary === false)) {\n                if (prevElement._owner != null) {\n                  prevElement._owner._isOwnerNecessary = true;\n                }\n                if (nextElement._owner != null) {\n                  nextElement._owner._isOwnerNecessary = true;\n                }\n                (\"production\" !== process.env.NODE_ENV ? warning(\n                  false,\n                  '<%s /> is being rendered by both %s and %s using the same ' +\n                  'key (%s) in the same place. Currently, this means that ' +\n                  'they don\\'t preserve state. This behavior should be very ' +\n                  'rare so we\\'re considering deprecating it. Please contact ' +\n                  'the React team and explain your use case so that we can ' +\n                  'take that into consideration.',\n                  nextDisplayName || 'Unknown Component',\n                  prevName || '[Unknown]',\n                  nextName || '[Unknown]',\n                  prevElement.key\n                ) : null);\n              }\n            }\n          }\n        }\n        return ownersMatch;\n      }\n    }\n  }\n  return false;\n}\n\nmodule.exports = shouldUpdateReactComponent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/shouldUpdateReactComponent.js\n ** module id = 65\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/shouldUpdateReactComponent.js?")},/*!**************************!*\
  !*** ./~/react/react.js ***!
  \**************************/
function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(/*! ./lib/React */ 20);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/react.js\n ** module id = 66\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/react.js?")},/*!************************************************************!*\
  !*** ./~/babel-runtime/helpers/interop-require-default.js ***!
  \************************************************************/
function(module,exports){eval('"use strict";\n\nexports["default"] = function (obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n};\n\nexports.__esModule = true;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/interop-require-default.js\n ** module id = 67\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/helpers/interop-require-default.js?')},/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.def.js ***!
  \************************************************************/
function(module,exports,__webpack_require__){eval("var $          = __webpack_require__(/*! ./$ */ 5)\n  , global     = $.g\n  , core       = $.core\n  , isFunction = $.isFunction;\nfunction ctx(fn, that){\n  return function(){\n    return fn.apply(that, arguments);\n  };\n}\n// type bitmap\n$def.F = 1;  // forced\n$def.G = 2;  // global\n$def.S = 4;  // static\n$def.P = 8;  // proto\n$def.B = 16; // bind\n$def.W = 32; // wrap\nfunction $def(type, name, source){\n  var key, own, out, exp\n    , isGlobal = type & $def.G\n    , isProto  = type & $def.P\n    , target   = isGlobal ? global : type & $def.S\n        ? global[name] : (global[name] || {}).prototype\n    , exports  = isGlobal ? core : core[name] || (core[name] = {});\n  if(isGlobal)source = name;\n  for(key in source){\n    // contains in native\n    own = !(type & $def.F) && target && key in target;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    if(isGlobal && !isFunction(target[key]))exp = source[key];\n    // bind timers to global for call from export context\n    else if(type & $def.B && own)exp = ctx(out, global);\n    // wrap global constructors for prevent change them in library\n    else if(type & $def.W && target[key] == out)!function(C){\n      exp = function(param){\n        return this instanceof C ? new C(param) : C(param);\n      };\n      exp.prototype = C.prototype;\n    }(out);\n    else exp = isProto && isFunction(out) ? ctx(Function.call, out) : out;\n    // export\n    exports[key] = exp;\n    if(isProto)(exports.prototype || (exports.prototype = {}))[key] = out;\n  }\n}\nmodule.exports = $def;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.def.js\n ** module id = 68\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.def.js?")},/*!********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.iter-define.js ***!
  \********************************************************************/
function(module,exports,__webpack_require__){eval("var $def            = __webpack_require__(/*! ./$.def */ 68)\n  , $redef          = __webpack_require__(/*! ./$.redef */ 44)\n  , $               = __webpack_require__(/*! ./$ */ 5)\n  , cof             = __webpack_require__(/*! ./$.cof */ 27)\n  , $iter           = __webpack_require__(/*! ./$.iter */ 28)\n  , SYMBOL_ITERATOR = __webpack_require__(/*! ./$.wks */ 16)('iterator')\n  , FF_ITERATOR     = '@@iterator'\n  , KEYS            = 'keys'\n  , VALUES          = 'values'\n  , Iterators       = $iter.Iterators;\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCE){\n  $iter.create(Constructor, NAME, next);\n  function createMethod(kind){\n    function $$(that){\n      return new Constructor(that, kind);\n    }\n    switch(kind){\n      case KEYS: return function keys(){ return $$(this); };\n      case VALUES: return function values(){ return $$(this); };\n    } return function entries(){ return $$(this); };\n  }\n  var TAG      = NAME + ' Iterator'\n    , proto    = Base.prototype\n    , _native  = proto[SYMBOL_ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , _default = _native || createMethod(DEFAULT)\n    , methods, key;\n  // Fix native\n  if(_native){\n    var IteratorPrototype = $.getProto(_default.call(new Base));\n    // Set @@toStringTag to native iterators\n    cof.set(IteratorPrototype, TAG, true);\n    // FF fix\n    if($.FW && $.has(proto, FF_ITERATOR))$iter.set(IteratorPrototype, $.that);\n  }\n  // Define iterator\n  if($.FW || FORCE)$iter.set(proto, _default);\n  // Plug for library\n  Iterators[NAME] = _default;\n  Iterators[TAG]  = $.that;\n  if(DEFAULT){\n    methods = {\n      keys:    IS_SET            ? _default : createMethod(KEYS),\n      values:  DEFAULT == VALUES ? _default : createMethod(VALUES),\n      entries: DEFAULT != VALUES ? _default : createMethod('entries')\n    };\n    if(FORCE)for(key in methods){\n      if(!(key in proto))$redef(proto, key, methods[key]);\n    } else $def($def.P + $def.F * $iter.BUGGY, NAME, methods);\n  }\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.iter-define.js\n ** module id = 69\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.iter-define.js?")},/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.shared.js ***!
  \***************************************************************/
function(module,exports,__webpack_require__){eval("var $      = __webpack_require__(/*! ./$ */ 5)\r\n  , SHARED = '__core-js_shared__'\r\n  , store  = $.g[SHARED] || ($.g[SHARED] = {});\r\nmodule.exports = function(key){\r\n  return store[key] || (store[key] = {});\r\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.shared.js\n ** module id = 70\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.shared.js?")},/*!************************************!*\
  !*** ./~/react/lib/CSSProperty.js ***!
  \************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule CSSProperty\n */\n\n'use strict';\n\n/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */\nvar isUnitlessNumber = {\n  boxFlex: true,\n  boxFlexGroup: true,\n  columnCount: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n\n  // SVG-related properties\n  fillOpacity: true,\n  strokeDashoffset: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n\n/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */\nfunction prefixKey(prefix, key) {\n  return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n}\n\n/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */\nvar prefixes = ['Webkit', 'ms', 'Moz', 'O'];\n\n// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function(prop) {\n  prefixes.forEach(function(prefix) {\n    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n  });\n});\n\n/**\n * Most style properties can be unset by doing .style[prop] = '' but IE8\n * doesn't like doing that with shorthand properties so for the properties that\n * IE8 breaks on, which are listed here, we instead unset each of the\n * individual properties. See http://bugs.jquery.com/ticket/12385.\n * The 4-value 'clock' properties like margin, padding, border-width seem to\n * behave without any problems. Curiously, list-style works too without any\n * special prodding.\n */\nvar shorthandPropertyExpansions = {\n  background: {\n    backgroundImage: true,\n    backgroundPosition: true,\n    backgroundRepeat: true,\n    backgroundColor: true\n  },\n  border: {\n    borderWidth: true,\n    borderStyle: true,\n    borderColor: true\n  },\n  borderBottom: {\n    borderBottomWidth: true,\n    borderBottomStyle: true,\n    borderBottomColor: true\n  },\n  borderLeft: {\n    borderLeftWidth: true,\n    borderLeftStyle: true,\n    borderLeftColor: true\n  },\n  borderRight: {\n    borderRightWidth: true,\n    borderRightStyle: true,\n    borderRightColor: true\n  },\n  borderTop: {\n    borderTopWidth: true,\n    borderTopStyle: true,\n    borderTopColor: true\n  },\n  font: {\n    fontStyle: true,\n    fontVariant: true,\n    fontWeight: true,\n    fontSize: true,\n    lineHeight: true,\n    fontFamily: true\n  }\n};\n\nvar CSSProperty = {\n  isUnitlessNumber: isUnitlessNumber,\n  shorthandPropertyExpansions: shorthandPropertyExpansions\n};\n\nmodule.exports = CSSProperty;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/CSSProperty.js\n ** module id = 71\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/CSSProperty.js?")},/*!**********************************************!*\
  !*** ./~/react/lib/CSSPropertyOperations.js ***!
  \**********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule CSSPropertyOperations\n * @typechecks static-only\n */\n\n'use strict';\n\nvar CSSProperty = __webpack_require__(/*! ./CSSProperty */ 71);\nvar ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ 6);\n\nvar camelizeStyleName = __webpack_require__(/*! ./camelizeStyleName */ 183);\nvar dangerousStyleValue = __webpack_require__(/*! ./dangerousStyleValue */ 188);\nvar hyphenateStyleName = __webpack_require__(/*! ./hyphenateStyleName */ 195);\nvar memoizeStringOnly = __webpack_require__(/*! ./memoizeStringOnly */ 199);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nvar processStyleName = memoizeStringOnly(function(styleName) {\n  return hyphenateStyleName(styleName);\n});\n\nvar styleFloatAccessor = 'cssFloat';\nif (ExecutionEnvironment.canUseDOM) {\n  // IE8 only supports accessing cssFloat (standard) as styleFloat\n  if (document.documentElement.style.cssFloat === undefined) {\n    styleFloatAccessor = 'styleFloat';\n  }\n}\n\nif (false) {\n  // 'msTransform' is correct, but the other prefixes should be capitalized\n  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n\n  // style values shouldn't contain a semicolon\n  var badStyleValueWithSemicolonPattern = /;\\s*$/;\n\n  var warnedStyleNames = {};\n  var warnedStyleValues = {};\n\n  var warnHyphenatedStyleName = function(name) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      false,\n      'Unsupported style property %s. Did you mean %s?',\n      name,\n      camelizeStyleName(name)\n    ) : null);\n  };\n\n  var warnBadVendoredStyleName = function(name) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      false,\n      'Unsupported vendor-prefixed style property %s. Did you mean %s?',\n      name,\n      name.charAt(0).toUpperCase() + name.slice(1)\n    ) : null);\n  };\n\n  var warnStyleValueWithSemicolon = function(name, value) {\n    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n      return;\n    }\n\n    warnedStyleValues[value] = true;\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      false,\n      'Style property values shouldn\\'t contain a semicolon. ' +\n      'Try \"%s: %s\" instead.',\n      name,\n      value.replace(badStyleValueWithSemicolonPattern, '')\n    ) : null);\n  };\n\n  /**\n   * @param {string} name\n   * @param {*} value\n   */\n  var warnValidStyle = function(name, value) {\n    if (name.indexOf('-') > -1) {\n      warnHyphenatedStyleName(name);\n    } else if (badVendoredStyleNamePattern.test(name)) {\n      warnBadVendoredStyleName(name);\n    } else if (badStyleValueWithSemicolonPattern.test(value)) {\n      warnStyleValueWithSemicolon(name, value);\n    }\n  };\n}\n\n/**\n * Operations for dealing with CSS properties.\n */\nvar CSSPropertyOperations = {\n\n  /**\n   * Serializes a mapping of style properties for use as inline styles:\n   *\n   *   > createMarkupForStyles({width: '200px', height: 0})\n   *   \"width:200px;height:0;\"\n   *\n   * Undefined values are ignored so that declarative programming is easier.\n   * The result should be HTML-escaped before insertion into the DOM.\n   *\n   * @param {object} styles\n   * @return {?string}\n   */\n  createMarkupForStyles: function(styles) {\n    var serialized = '';\n    for (var styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n      var styleValue = styles[styleName];\n      if (false) {\n        warnValidStyle(styleName, styleValue);\n      }\n      if (styleValue != null) {\n        serialized += processStyleName(styleName) + ':';\n        serialized += dangerousStyleValue(styleName, styleValue) + ';';\n      }\n    }\n    return serialized || null;\n  },\n\n  /**\n   * Sets the value for multiple styles on a node.  If a value is specified as\n   * '' (empty string), the corresponding style property will be unset.\n   *\n   * @param {DOMElement} node\n   * @param {object} styles\n   */\n  setValueForStyles: function(node, styles) {\n    var style = node.style;\n    for (var styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n      if (false) {\n        warnValidStyle(styleName, styles[styleName]);\n      }\n      var styleValue = dangerousStyleValue(styleName, styles[styleName]);\n      if (styleName === 'float') {\n        styleName = styleFloatAccessor;\n      }\n      if (styleValue) {\n        style[styleName] = styleValue;\n      } else {\n        var expansion = CSSProperty.shorthandPropertyExpansions[styleName];\n        if (expansion) {\n          // Shorthand property that IE8 won't like unsetting, so unset each\n          // component to placate it\n          for (var individualStyleName in expansion) {\n            style[individualStyleName] = '';\n          }\n        } else {\n          style[styleName] = '';\n        }\n      }\n    }\n  }\n\n};\n\nmodule.exports = CSSPropertyOperations;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/CSSPropertyOperations.js\n ** module id = 72\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/CSSPropertyOperations.js?")},/*!********************************************!*\
  !*** ./~/react/lib/EventPluginRegistry.js ***!
  \********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPluginRegistry\n * @typechecks static-only\n */\n\n'use strict';\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\n/**\n * Injectable ordering of event plugins.\n */\nvar EventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!EventPluginOrder) {\n    // Wait until an `EventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var PluginModule = namesToPlugins[pluginName];\n    var pluginIndex = EventPluginOrder.indexOf(pluginName);\n    (false ? invariant(\n      pluginIndex > -1,\n      'EventPluginRegistry: Cannot inject event plugins that do not exist in ' +\n      'the plugin ordering, `%s`.',\n      pluginName\n    ) : invariant(pluginIndex > -1));\n    if (EventPluginRegistry.plugins[pluginIndex]) {\n      continue;\n    }\n    (false ? invariant(\n      PluginModule.extractEvents,\n      'EventPluginRegistry: Event plugins must implement an `extractEvents` ' +\n      'method, but `%s` does not.',\n      pluginName\n    ) : invariant(PluginModule.extractEvents));\n    EventPluginRegistry.plugins[pluginIndex] = PluginModule;\n    var publishedEvents = PluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      (false ? invariant(\n        publishEventForPlugin(\n          publishedEvents[eventName],\n          PluginModule,\n          eventName\n        ),\n        'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',\n        eventName,\n        pluginName\n      ) : invariant(publishEventForPlugin(\n        publishedEvents[eventName],\n        PluginModule,\n        eventName\n      )));\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, PluginModule, eventName) {\n  (false ? invariant(\n    !EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName),\n    'EventPluginHub: More than one plugin attempted to publish the same ' +\n    'event name, `%s`.',\n    eventName\n  ) : invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName)));\n  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(\n          phasedRegistrationName,\n          PluginModule,\n          eventName\n        );\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(\n      dispatchConfig.registrationName,\n      PluginModule,\n      eventName\n    );\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events and\n * can be used with `EventPluginHub.putListener` to register listeners.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, PluginModule, eventName) {\n  (false ? invariant(\n    !EventPluginRegistry.registrationNameModules[registrationName],\n    'EventPluginHub: More than one plugin attempted to publish the same ' +\n    'registration name, `%s`.',\n    registrationName\n  ) : invariant(!EventPluginRegistry.registrationNameModules[registrationName]));\n  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;\n  EventPluginRegistry.registrationNameDependencies[registrationName] =\n    PluginModule.eventTypes[eventName].dependencies;\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\nvar EventPluginRegistry = {\n\n  /**\n   * Ordered list of injected plugins.\n   */\n  plugins: [],\n\n  /**\n   * Mapping from event name to dispatch config\n   */\n  eventNameDispatchConfigs: {},\n\n  /**\n   * Mapping from registration name to plugin module\n   */\n  registrationNameModules: {},\n\n  /**\n   * Mapping from registration name to event name\n   */\n  registrationNameDependencies: {},\n\n  /**\n   * Injects an ordering of plugins (by plugin name). This allows the ordering\n   * to be decoupled from injection of the actual plugins so that ordering is\n   * always deterministic regardless of packaging, on-the-fly injection, etc.\n   *\n   * @param {array} InjectedEventPluginOrder\n   * @internal\n   * @see {EventPluginHub.injection.injectEventPluginOrder}\n   */\n  injectEventPluginOrder: function(InjectedEventPluginOrder) {\n    (false ? invariant(\n      !EventPluginOrder,\n      'EventPluginRegistry: Cannot inject event plugin ordering more than ' +\n      'once. You are likely trying to load more than one copy of React.'\n    ) : invariant(!EventPluginOrder));\n    // Clone the ordering so it cannot be dynamically mutated.\n    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);\n    recomputePluginOrdering();\n  },\n\n  /**\n   * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n   * in the ordering injected by `injectEventPluginOrder`.\n   *\n   * Plugins can be injected as part of page initialization or on-the-fly.\n   *\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   * @internal\n   * @see {EventPluginHub.injection.injectEventPluginsByName}\n   */\n  injectEventPluginsByName: function(injectedNamesToPlugins) {\n    var isOrderingDirty = false;\n    for (var pluginName in injectedNamesToPlugins) {\n      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n        continue;\n      }\n      var PluginModule = injectedNamesToPlugins[pluginName];\n      if (!namesToPlugins.hasOwnProperty(pluginName) ||\n          namesToPlugins[pluginName] !== PluginModule) {\n        (false ? invariant(\n          !namesToPlugins[pluginName],\n          'EventPluginRegistry: Cannot inject two different event plugins ' +\n          'using the same name, `%s`.',\n          pluginName\n        ) : invariant(!namesToPlugins[pluginName]));\n        namesToPlugins[pluginName] = PluginModule;\n        isOrderingDirty = true;\n      }\n    }\n    if (isOrderingDirty) {\n      recomputePluginOrdering();\n    }\n  },\n\n  /**\n   * Looks up the plugin for the supplied event.\n   *\n   * @param {object} event A synthetic event.\n   * @return {?object} The plugin that created the supplied event.\n   * @internal\n   */\n  getPluginModuleForEvent: function(event) {\n    var dispatchConfig = event.dispatchConfig;\n    if (dispatchConfig.registrationName) {\n      return EventPluginRegistry.registrationNameModules[\n        dispatchConfig.registrationName\n      ] || null;\n    }\n    for (var phase in dispatchConfig.phasedRegistrationNames) {\n      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {\n        continue;\n      }\n      var PluginModule = EventPluginRegistry.registrationNameModules[\n        dispatchConfig.phasedRegistrationNames[phase]\n      ];\n      if (PluginModule) {\n        return PluginModule;\n      }\n    }\n    return null;\n  },\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _resetEventPlugins: function() {\n    EventPluginOrder = null;\n    for (var pluginName in namesToPlugins) {\n      if (namesToPlugins.hasOwnProperty(pluginName)) {\n        delete namesToPlugins[pluginName];\n      }\n    }\n    EventPluginRegistry.plugins.length = 0;\n\n    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;\n    for (var eventName in eventNameDispatchConfigs) {\n      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {\n        delete eventNameDispatchConfigs[eventName];\n      }\n    }\n\n    var registrationNameModules = EventPluginRegistry.registrationNameModules;\n    for (var registrationName in registrationNameModules) {\n      if (registrationNameModules.hasOwnProperty(registrationName)) {\n        delete registrationNameModules[registrationName];\n      }\n    }\n  }\n\n};\n\nmodule.exports = EventPluginRegistry;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EventPluginRegistry.js\n ** module id = 73\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EventPluginRegistry.js?")},/*!**************************************!*\
  !*** ./~/react/lib/ReactChildren.js ***!
  \**************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactChildren\n */\n\n'use strict';\n\nvar PooledClass = __webpack_require__(/*! ./PooledClass */ 12);\nvar ReactFragment = __webpack_require__(/*! ./ReactFragment */ 22);\n\nvar traverseAllChildren = __webpack_require__(/*! ./traverseAllChildren */ 98);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nvar twoArgumentPooler = PooledClass.twoArgumentPooler;\nvar threeArgumentPooler = PooledClass.threeArgumentPooler;\n\n/**\n * PooledClass representing the bookkeeping associated with performing a child\n * traversal. Allows avoiding binding callbacks.\n *\n * @constructor ForEachBookKeeping\n * @param {!function} forEachFunction Function to perform traversal with.\n * @param {?*} forEachContext Context to perform context with.\n */\nfunction ForEachBookKeeping(forEachFunction, forEachContext) {\n  this.forEachFunction = forEachFunction;\n  this.forEachContext = forEachContext;\n}\nPooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);\n\nfunction forEachSingleChild(traverseContext, child, name, i) {\n  var forEachBookKeeping = traverseContext;\n  forEachBookKeeping.forEachFunction.call(\n    forEachBookKeeping.forEachContext, child, i);\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc.\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n\n  var traverseContext =\n    ForEachBookKeeping.getPooled(forEachFunc, forEachContext);\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  ForEachBookKeeping.release(traverseContext);\n}\n\n/**\n * PooledClass representing the bookkeeping associated with performing a child\n * mapping. Allows avoiding binding callbacks.\n *\n * @constructor MapBookKeeping\n * @param {!*} mapResult Object containing the ordered map of results.\n * @param {!function} mapFunction Function to perform mapping with.\n * @param {?*} mapContext Context to perform mapping with.\n */\nfunction MapBookKeeping(mapResult, mapFunction, mapContext) {\n  this.mapResult = mapResult;\n  this.mapFunction = mapFunction;\n  this.mapContext = mapContext;\n}\nPooledClass.addPoolingTo(MapBookKeeping, threeArgumentPooler);\n\nfunction mapSingleChildIntoContext(traverseContext, child, name, i) {\n  var mapBookKeeping = traverseContext;\n  var mapResult = mapBookKeeping.mapResult;\n\n  var keyUnique = !mapResult.hasOwnProperty(name);\n  if (false) {\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      keyUnique,\n      'ReactChildren.map(...): Encountered two children with the same key, ' +\n      '`%s`. Child keys must be unique; when two children share a key, only ' +\n      'the first child will be used.',\n      name\n    ) : null);\n  }\n\n  if (keyUnique) {\n    var mappedChild =\n      mapBookKeeping.mapFunction.call(mapBookKeeping.mapContext, child, i);\n    mapResult[name] = mappedChild;\n  }\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * TODO: This may likely break any calls to `ReactChildren.map` that were\n * previously relying on the fact that we guarded against null children.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} mapFunction.\n * @param {*} mapContext Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n\n  var mapResult = {};\n  var traverseContext = MapBookKeeping.getPooled(mapResult, func, context);\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  MapBookKeeping.release(traverseContext);\n  return ReactFragment.create(mapResult);\n}\n\nfunction forEachSingleChildDummy(traverseContext, child, name, i) {\n  return null;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children, context) {\n  return traverseAllChildren(children, forEachSingleChildDummy, null);\n}\n\nvar ReactChildren = {\n  forEach: forEachChildren,\n  map: mapChildren,\n  count: countChildren\n};\n\nmodule.exports = ReactChildren;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactChildren.js\n ** module id = 74\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactChildren.js?")},/*!***************************************!*\
  !*** ./~/react/lib/ReactComponent.js ***!
  \***************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactComponent\n */\n\n'use strict';\n\nvar ReactUpdateQueue = __webpack_require__(/*! ./ReactUpdateQueue */ 56);\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction ReactComponent(props, context) {\n  this.props = props;\n  this.context = context;\n}\n\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\nReactComponent.prototype.setState = function(partialState, callback) {\n  (false ? invariant(\n    typeof partialState === 'object' ||\n    typeof partialState === 'function' ||\n    partialState == null,\n    'setState(...): takes an object of state variables to update or a ' +\n    'function which returns an object of state variables.'\n  ) : invariant(typeof partialState === 'object' ||\n  typeof partialState === 'function' ||\n  partialState == null));\n  if (false) {\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      partialState != null,\n      'setState(...): You passed an undefined or null state object; ' +\n      'instead, use forceUpdate().'\n    ) : null);\n  }\n  ReactUpdateQueue.enqueueSetState(this, partialState);\n  if (callback) {\n    ReactUpdateQueue.enqueueCallback(this, callback);\n  }\n};\n\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\nReactComponent.prototype.forceUpdate = function(callback) {\n  ReactUpdateQueue.enqueueForceUpdate(this);\n  if (callback) {\n    ReactUpdateQueue.enqueueCallback(this, callback);\n  }\n};\n\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\nif (false) {\n  var deprecatedAPIs = {\n    getDOMNode: [\n      'getDOMNode',\n      'Use React.findDOMNode(component) instead.'\n    ],\n    isMounted: [\n      'isMounted',\n      'Instead, make sure to clean up subscriptions and pending requests in ' +\n      'componentWillUnmount to prevent memory leaks.'\n    ],\n    replaceProps: [\n      'replaceProps',\n      'Instead, call React.render again at the top level.'\n    ],\n    replaceState: [\n      'replaceState',\n      'Refactor your code to use setState instead (see ' +\n      'https://github.com/facebook/react/issues/3236).'\n    ],\n    setProps: [\n      'setProps',\n      'Instead, call React.render again at the top level.'\n    ]\n  };\n  var defineDeprecationWarning = function(methodName, info) {\n    try {\n      Object.defineProperty(ReactComponent.prototype, methodName, {\n        get: function() {\n          (\"production\" !== process.env.NODE_ENV ? warning(\n            false,\n            '%s(...) is deprecated in plain JavaScript React classes. %s',\n            info[0],\n            info[1]\n          ) : null);\n          return undefined;\n        }\n      });\n    } catch (x) {\n      // IE will fail on defineProperty (es5-shim/sham too)\n    }\n  };\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\nmodule.exports = ReactComponent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactComponent.js\n ** module id = 75\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactComponent.js?")},/*!*********************************************!*\
  !*** ./~/react/lib/ReactDOMIDOperations.js ***!
  \*********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMIDOperations\n * @typechecks static-only\n */\n\n/*jslint evil: true */\n\n'use strict';\n\nvar CSSPropertyOperations = __webpack_require__(/*! ./CSSPropertyOperations */ 72);\nvar DOMChildrenOperations = __webpack_require__(/*! ./DOMChildrenOperations */ 127);\nvar DOMPropertyOperations = __webpack_require__(/*! ./DOMPropertyOperations */ 29);\nvar ReactMount = __webpack_require__(/*! ./ReactMount */ 15);\nvar ReactPerf = __webpack_require__(/*! ./ReactPerf */ 17);\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\nvar setInnerHTML = __webpack_require__(/*! ./setInnerHTML */ 64);\n\n/**\n * Errors for properties that should not be updated with `updatePropertyById()`.\n *\n * @type {object}\n * @private\n */\nvar INVALID_PROPERTY_ERRORS = {\n  dangerouslySetInnerHTML:\n    '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',\n  style: '`style` must be set using `updateStylesByID()`.'\n};\n\n/**\n * Operations used to process updates to DOM nodes. This is made injectable via\n * `ReactDOMComponent.BackendIDOperations`.\n */\nvar ReactDOMIDOperations = {\n\n  /**\n   * Updates a DOM node with new property values. This should only be used to\n   * update DOM properties in `DOMProperty`.\n   *\n   * @param {string} id ID of the node to update.\n   * @param {string} name A valid property name, see `DOMProperty`.\n   * @param {*} value New value of the property.\n   * @internal\n   */\n  updatePropertyByID: function(id, name, value) {\n    var node = ReactMount.getNode(id);\n    (false ? invariant(\n      !INVALID_PROPERTY_ERRORS.hasOwnProperty(name),\n      'updatePropertyByID(...): %s',\n      INVALID_PROPERTY_ERRORS[name]\n    ) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));\n\n    // If we're updating to null or undefined, we should remove the property\n    // from the DOM node instead of inadvertantly setting to a string. This\n    // brings us in line with the same behavior we have on initial render.\n    if (value != null) {\n      DOMPropertyOperations.setValueForProperty(node, name, value);\n    } else {\n      DOMPropertyOperations.deleteValueForProperty(node, name);\n    }\n  },\n\n  /**\n   * Updates a DOM node to remove a property. This should only be used to remove\n   * DOM properties in `DOMProperty`.\n   *\n   * @param {string} id ID of the node to update.\n   * @param {string} name A property name to remove, see `DOMProperty`.\n   * @internal\n   */\n  deletePropertyByID: function(id, name, value) {\n    var node = ReactMount.getNode(id);\n    (false ? invariant(\n      !INVALID_PROPERTY_ERRORS.hasOwnProperty(name),\n      'updatePropertyByID(...): %s',\n      INVALID_PROPERTY_ERRORS[name]\n    ) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));\n    DOMPropertyOperations.deleteValueForProperty(node, name, value);\n  },\n\n  /**\n   * Updates a DOM node with new style values. If a value is specified as '',\n   * the corresponding style property will be unset.\n   *\n   * @param {string} id ID of the node to update.\n   * @param {object} styles Mapping from styles to values.\n   * @internal\n   */\n  updateStylesByID: function(id, styles) {\n    var node = ReactMount.getNode(id);\n    CSSPropertyOperations.setValueForStyles(node, styles);\n  },\n\n  /**\n   * Updates a DOM node's innerHTML.\n   *\n   * @param {string} id ID of the node to update.\n   * @param {string} html An HTML string.\n   * @internal\n   */\n  updateInnerHTMLByID: function(id, html) {\n    var node = ReactMount.getNode(id);\n    setInnerHTML(node, html);\n  },\n\n  /**\n   * Updates a DOM node's text content set by `props.content`.\n   *\n   * @param {string} id ID of the node to update.\n   * @param {string} content Text content.\n   * @internal\n   */\n  updateTextContentByID: function(id, content) {\n    var node = ReactMount.getNode(id);\n    DOMChildrenOperations.updateTextContent(node, content);\n  },\n\n  /**\n   * Replaces a DOM node that exists in the document with markup.\n   *\n   * @param {string} id ID of child to be replaced.\n   * @param {string} markup Dangerous markup to inject in place of child.\n   * @internal\n   * @see {Danger.dangerouslyReplaceNodeWithMarkup}\n   */\n  dangerouslyReplaceNodeWithMarkupByID: function(id, markup) {\n    var node = ReactMount.getNode(id);\n    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);\n  },\n\n  /**\n   * Updates a component's children by processing a series of updates.\n   *\n   * @param {array<object>} updates List of update configurations.\n   * @param {array<string>} markup List of markup strings.\n   * @internal\n   */\n  dangerouslyProcessChildrenUpdates: function(updates, markup) {\n    for (var i = 0; i < updates.length; i++) {\n      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);\n    }\n    DOMChildrenOperations.processUpdates(updates, markup);\n  }\n};\n\nReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {\n  updatePropertyByID: 'updatePropertyByID',\n  deletePropertyByID: 'deletePropertyByID',\n  updateStylesByID: 'updateStylesByID',\n  updateInnerHTMLByID: 'updateInnerHTMLByID',\n  updateTextContentByID: 'updateTextContentByID',\n  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',\n  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'\n});\n\nmodule.exports = ReactDOMIDOperations;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMIDOperations.js\n ** module id = 76\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMIDOperations.js?")},/*!**********************************************!*\
  !*** ./~/react/lib/ReactDOMTextComponent.js ***!
  \**********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMTextComponent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar DOMPropertyOperations = __webpack_require__(/*! ./DOMPropertyOperations */ 29);\nvar ReactComponentBrowserEnvironment =\n  __webpack_require__(/*! ./ReactComponentBrowserEnvironment */ 49);\nvar ReactDOMComponent = __webpack_require__(/*! ./ReactDOMComponent */ 52);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar escapeTextContentForBrowser = __webpack_require__(/*! ./escapeTextContentForBrowser */ 43);\n\n/**\n * Text nodes violate a couple assumptions that React makes about components:\n *\n *  - When mounting text into the DOM, adjacent text nodes are merged.\n *  - Text nodes cannot be assigned a React root ID.\n *\n * This component is used to wrap strings in elements so that they can undergo\n * the same reconciliation that is applied to elements.\n *\n * TODO: Investigate representing React components in the DOM with text nodes.\n *\n * @class ReactDOMTextComponent\n * @extends ReactComponent\n * @internal\n */\nvar ReactDOMTextComponent = function(props) {\n  // This constructor and its argument is currently used by mocks.\n};\n\nassign(ReactDOMTextComponent.prototype, {\n\n  /**\n   * @param {ReactText} text\n   * @internal\n   */\n  construct: function(text) {\n    // TODO: This is really a ReactText (ReactNode), not a ReactElement\n    this._currentElement = text;\n    this._stringText = '' + text;\n\n    // Properties\n    this._rootNodeID = null;\n    this._mountIndex = 0;\n  },\n\n  /**\n   * Creates the markup for this text node. This node is not intended to have\n   * any features besides containing text content.\n   *\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {string} Markup for this text node.\n   * @internal\n   */\n  mountComponent: function(rootID, transaction, context) {\n    this._rootNodeID = rootID;\n    var escapedText = escapeTextContentForBrowser(this._stringText);\n\n    if (transaction.renderToStaticMarkup) {\n      // Normally we'd wrap this in a `span` for the reasons stated above, but\n      // since this is a situation where React won't take over (static pages),\n      // we can simply return the text as it is.\n      return escapedText;\n    }\n\n    return (\n      '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' +\n        escapedText +\n      '</span>'\n    );\n  },\n\n  /**\n   * Updates this component by updating the text content.\n   *\n   * @param {ReactText} nextText The next text content\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  receiveComponent: function(nextText, transaction) {\n    if (nextText !== this._currentElement) {\n      this._currentElement = nextText;\n      var nextStringText = '' + nextText;\n      if (nextStringText !== this._stringText) {\n        // TODO: Save this as pending props and use performUpdateIfNecessary\n        // and/or updateComponent to do the actual update for consistency with\n        // other component types?\n        this._stringText = nextStringText;\n        ReactDOMComponent.BackendIDOperations.updateTextContentByID(\n          this._rootNodeID,\n          nextStringText\n        );\n      }\n    }\n  },\n\n  unmountComponent: function() {\n    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);\n  }\n\n});\n\nmodule.exports = ReactDOMTextComponent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMTextComponent.js\n ** module id = 77\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMTextComponent.js?")},/*!********************************************!*\
  !*** ./~/react/lib/ReactInputSelection.js ***!
  \********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactInputSelection\n */\n\n'use strict';\n\nvar ReactDOMSelection = __webpack_require__(/*! ./ReactDOMSelection */ 149);\n\nvar containsNode = __webpack_require__(/*! ./containsNode */ 87);\nvar focusNode = __webpack_require__(/*! ./focusNode */ 89);\nvar getActiveElement = __webpack_require__(/*! ./getActiveElement */ 90);\n\nfunction isInDocument(node) {\n  return containsNode(document.documentElement, node);\n}\n\n/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */\nvar ReactInputSelection = {\n\n  hasSelectionCapabilities: function(elem) {\n    return elem && (\n      ((elem.nodeName === 'INPUT' && elem.type === 'text') ||\n      elem.nodeName === 'TEXTAREA' || elem.contentEditable === 'true')\n    );\n  },\n\n  getSelectionInformation: function() {\n    var focusedElem = getActiveElement();\n    return {\n      focusedElem: focusedElem,\n      selectionRange:\n          ReactInputSelection.hasSelectionCapabilities(focusedElem) ?\n          ReactInputSelection.getSelection(focusedElem) :\n          null\n    };\n  },\n\n  /**\n   * @restoreSelection: If any selection information was potentially lost,\n   * restore it. This is useful when performing operations that could remove dom\n   * nodes and place them back in, resulting in focus being lost.\n   */\n  restoreSelection: function(priorSelectionInformation) {\n    var curFocusedElem = getActiveElement();\n    var priorFocusedElem = priorSelectionInformation.focusedElem;\n    var priorSelectionRange = priorSelectionInformation.selectionRange;\n    if (curFocusedElem !== priorFocusedElem &&\n        isInDocument(priorFocusedElem)) {\n      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {\n        ReactInputSelection.setSelection(\n          priorFocusedElem,\n          priorSelectionRange\n        );\n      }\n      focusNode(priorFocusedElem);\n    }\n  },\n\n  /**\n   * @getSelection: Gets the selection bounds of a focused textarea, input or\n   * contentEditable node.\n   * -@input: Look up selection bounds of this input\n   * -@return {start: selectionStart, end: selectionEnd}\n   */\n  getSelection: function(input) {\n    var selection;\n\n    if ('selectionStart' in input) {\n      // Modern browser with input or textarea.\n      selection = {\n        start: input.selectionStart,\n        end: input.selectionEnd\n      };\n    } else if (document.selection && input.nodeName === 'INPUT') {\n      // IE8 input.\n      var range = document.selection.createRange();\n      // There can only be one selection per document in IE, so it must\n      // be in our element.\n      if (range.parentElement() === input) {\n        selection = {\n          start: -range.moveStart('character', -input.value.length),\n          end: -range.moveEnd('character', -input.value.length)\n        };\n      }\n    } else {\n      // Content editable or old IE textarea.\n      selection = ReactDOMSelection.getOffsets(input);\n    }\n\n    return selection || {start: 0, end: 0};\n  },\n\n  /**\n   * @setSelection: Sets the selection bounds of a textarea or input and focuses\n   * the input.\n   * -@input     Set selection bounds of this input or textarea\n   * -@offsets   Object of same form that is returned from get*\n   */\n  setSelection: function(input, offsets) {\n    var start = offsets.start;\n    var end = offsets.end;\n    if (typeof end === 'undefined') {\n      end = start;\n    }\n\n    if ('selectionStart' in input) {\n      input.selectionStart = start;\n      input.selectionEnd = Math.min(end, input.value.length);\n    } else if (document.selection && input.nodeName === 'INPUT') {\n      var range = input.createTextRange();\n      range.collapse(true);\n      range.moveStart('character', start);\n      range.moveEnd('character', end - start);\n      range.select();\n    } else {\n      ReactDOMSelection.setOffsets(input, offsets);\n    }\n  }\n};\n\nmodule.exports = ReactInputSelection;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactInputSelection.js\n ** module id = 78\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactInputSelection.js?")},/*!********************************************!*\
  !*** ./~/react/lib/ReactMarkupChecksum.js ***!
  \********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMarkupChecksum\n */\n\n'use strict';\n\nvar adler32 = __webpack_require__(/*! ./adler32 */ 181);\n\nvar ReactMarkupChecksum = {\n  CHECKSUM_ATTR_NAME: 'data-react-checksum',\n\n  /**\n   * @param {string} markup Markup string\n   * @return {string} Markup string with checksum attribute attached\n   */\n  addChecksumToMarkup: function(markup) {\n    var checksum = adler32(markup);\n    return markup.replace(\n      '>',\n      ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '=\"' + checksum + '\">'\n    );\n  },\n\n  /**\n   * @param {string} markup to use\n   * @param {DOMElement} element root React element\n   * @returns {boolean} whether or not the markup is the same\n   */\n  canReuseMarkup: function(markup, element) {\n    var existingChecksum = element.getAttribute(\n      ReactMarkupChecksum.CHECKSUM_ATTR_NAME\n    );\n    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);\n    var markupChecksum = adler32(markup);\n    return markupChecksum === existingChecksum;\n  }\n};\n\nmodule.exports = ReactMarkupChecksum;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactMarkupChecksum.js\n ** module id = 79\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactMarkupChecksum.js?")},/*!***************************************************!*\
  !*** ./~/react/lib/ReactMultiChildUpdateTypes.js ***!
  \***************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMultiChildUpdateTypes\n */\n\n'use strict';\n\nvar keyMirror = __webpack_require__(/*! ./keyMirror */ 34);\n\n/**\n * When a component's children are updated, a series of update configuration\n * objects are created in order to batch and serialize the required changes.\n *\n * Enumerates all the possible types of update configurations.\n *\n * @internal\n */\nvar ReactMultiChildUpdateTypes = keyMirror({\n  INSERT_MARKUP: null,\n  MOVE_EXISTING: null,\n  REMOVE_NODE: null,\n  TEXT_CONTENT: null\n});\n\nmodule.exports = ReactMultiChildUpdateTypes;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactMultiChildUpdateTypes.js\n ** module id = 80\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactMultiChildUpdateTypes.js?")},/*!***************************************!*\
  !*** ./~/react/lib/ReactPropTypes.js ***!
  \***************************************/
function(module,exports,__webpack_require__){eval('/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPropTypes\n */\n\n\'use strict\';\n\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\nvar ReactFragment = __webpack_require__(/*! ./ReactFragment */ 22);\nvar ReactPropTypeLocationNames = __webpack_require__(/*! ./ReactPropTypeLocationNames */ 39);\n\nvar emptyFunction = __webpack_require__(/*! ./emptyFunction */ 10);\n\n/**\n * Collection of methods that allow declaration and validation of props that are\n * supplied to React components. Example usage:\n *\n *   var Props = require(\'ReactPropTypes\');\n *   var MyArticle = React.createClass({\n *     propTypes: {\n *       // An optional string prop named "description".\n *       description: Props.string,\n *\n *       // A required enum prop named "category".\n *       category: Props.oneOf([\'News\',\'Photos\']).isRequired,\n *\n *       // A prop named "dialog" that requires an instance of Dialog.\n *       dialog: Props.instanceOf(Dialog).isRequired\n *     },\n *     render: function() { ... }\n *   });\n *\n * A more formal specification of how these methods are used:\n *\n *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n *   decl := ReactPropTypes.{type}(.isRequired)?\n *\n * Each and every declaration produces a function with the same signature. This\n * allows the creation of custom validation functions. For example:\n *\n *  var MyLink = React.createClass({\n *    propTypes: {\n *      // An optional string or URI prop named "href".\n *      href: function(props, propName, componentName) {\n *        var propValue = props[propName];\n *        if (propValue != null && typeof propValue !== \'string\' &&\n *            !(propValue instanceof URI)) {\n *          return new Error(\n *            \'Expected a string or an URI for \' + propName + \' in \' +\n *            componentName\n *          );\n *        }\n *      }\n *    },\n *    render: function() {...}\n *  });\n *\n * @internal\n */\n\nvar ANONYMOUS = \'<<anonymous>>\';\n\nvar elementTypeChecker = createElementTypeChecker();\nvar nodeTypeChecker = createNodeChecker();\n\nvar ReactPropTypes = {\n  array: createPrimitiveTypeChecker(\'array\'),\n  bool: createPrimitiveTypeChecker(\'boolean\'),\n  func: createPrimitiveTypeChecker(\'function\'),\n  number: createPrimitiveTypeChecker(\'number\'),\n  object: createPrimitiveTypeChecker(\'object\'),\n  string: createPrimitiveTypeChecker(\'string\'),\n\n  any: createAnyTypeChecker(),\n  arrayOf: createArrayOfTypeChecker,\n  element: elementTypeChecker,\n  instanceOf: createInstanceTypeChecker,\n  node: nodeTypeChecker,\n  objectOf: createObjectOfTypeChecker,\n  oneOf: createEnumTypeChecker,\n  oneOfType: createUnionTypeChecker,\n  shape: createShapeTypeChecker\n};\n\nfunction createChainableTypeChecker(validate) {\n  function checkType(isRequired, props, propName, componentName, location) {\n    componentName = componentName || ANONYMOUS;\n    if (props[propName] == null) {\n      var locationName = ReactPropTypeLocationNames[location];\n      if (isRequired) {\n        return new Error(\n          ("Required " + locationName + " `" + propName + "` was not specified in ") +\n          ("`" + componentName + "`.")\n        );\n      }\n      return null;\n    } else {\n      return validate(props, propName, componentName, location);\n    }\n  }\n\n  var chainedCheckType = checkType.bind(null, false);\n  chainedCheckType.isRequired = checkType.bind(null, true);\n\n  return chainedCheckType;\n}\n\nfunction createPrimitiveTypeChecker(expectedType) {\n  function validate(props, propName, componentName, location) {\n    var propValue = props[propName];\n    var propType = getPropType(propValue);\n    if (propType !== expectedType) {\n      var locationName = ReactPropTypeLocationNames[location];\n      // `propValue` being instance of, say, date/regexp, pass the \'object\'\n      // check, but we can offer a more precise error message here rather than\n      // \'of type `object`\'.\n      var preciseType = getPreciseType(propValue);\n\n      return new Error(\n        ("Invalid " + locationName + " `" + propName + "` of type `" + preciseType + "` ") +\n        ("supplied to `" + componentName + "`, expected `" + expectedType + "`.")\n      );\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createAnyTypeChecker() {\n  return createChainableTypeChecker(emptyFunction.thatReturns(null));\n}\n\nfunction createArrayOfTypeChecker(typeChecker) {\n  function validate(props, propName, componentName, location) {\n    var propValue = props[propName];\n    if (!Array.isArray(propValue)) {\n      var locationName = ReactPropTypeLocationNames[location];\n      var propType = getPropType(propValue);\n      return new Error(\n        ("Invalid " + locationName + " `" + propName + "` of type ") +\n        ("`" + propType + "` supplied to `" + componentName + "`, expected an array.")\n      );\n    }\n    for (var i = 0; i < propValue.length; i++) {\n      var error = typeChecker(propValue, i, componentName, location);\n      if (error instanceof Error) {\n        return error;\n      }\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createElementTypeChecker() {\n  function validate(props, propName, componentName, location) {\n    if (!ReactElement.isValidElement(props[propName])) {\n      var locationName = ReactPropTypeLocationNames[location];\n      return new Error(\n        ("Invalid " + locationName + " `" + propName + "` supplied to ") +\n        ("`" + componentName + "`, expected a ReactElement.")\n      );\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createInstanceTypeChecker(expectedClass) {\n  function validate(props, propName, componentName, location) {\n    if (!(props[propName] instanceof expectedClass)) {\n      var locationName = ReactPropTypeLocationNames[location];\n      var expectedClassName = expectedClass.name || ANONYMOUS;\n      return new Error(\n        ("Invalid " + locationName + " `" + propName + "` supplied to ") +\n        ("`" + componentName + "`, expected instance of `" + expectedClassName + "`.")\n      );\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createEnumTypeChecker(expectedValues) {\n  function validate(props, propName, componentName, location) {\n    var propValue = props[propName];\n    for (var i = 0; i < expectedValues.length; i++) {\n      if (propValue === expectedValues[i]) {\n        return null;\n      }\n    }\n\n    var locationName = ReactPropTypeLocationNames[location];\n    var valuesString = JSON.stringify(expectedValues);\n    return new Error(\n      ("Invalid " + locationName + " `" + propName + "` of value `" + propValue + "` ") +\n      ("supplied to `" + componentName + "`, expected one of " + valuesString + ".")\n    );\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createObjectOfTypeChecker(typeChecker) {\n  function validate(props, propName, componentName, location) {\n    var propValue = props[propName];\n    var propType = getPropType(propValue);\n    if (propType !== \'object\') {\n      var locationName = ReactPropTypeLocationNames[location];\n      return new Error(\n        ("Invalid " + locationName + " `" + propName + "` of type ") +\n        ("`" + propType + "` supplied to `" + componentName + "`, expected an object.")\n      );\n    }\n    for (var key in propValue) {\n      if (propValue.hasOwnProperty(key)) {\n        var error = typeChecker(propValue, key, componentName, location);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createUnionTypeChecker(arrayOfTypeCheckers) {\n  function validate(props, propName, componentName, location) {\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (checker(props, propName, componentName, location) == null) {\n        return null;\n      }\n    }\n\n    var locationName = ReactPropTypeLocationNames[location];\n    return new Error(\n      ("Invalid " + locationName + " `" + propName + "` supplied to ") +\n      ("`" + componentName + "`.")\n    );\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createNodeChecker() {\n  function validate(props, propName, componentName, location) {\n    if (!isNode(props[propName])) {\n      var locationName = ReactPropTypeLocationNames[location];\n      return new Error(\n        ("Invalid " + locationName + " `" + propName + "` supplied to ") +\n        ("`" + componentName + "`, expected a ReactNode.")\n      );\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createShapeTypeChecker(shapeTypes) {\n  function validate(props, propName, componentName, location) {\n    var propValue = props[propName];\n    var propType = getPropType(propValue);\n    if (propType !== \'object\') {\n      var locationName = ReactPropTypeLocationNames[location];\n      return new Error(\n        ("Invalid " + locationName + " `" + propName + "` of type `" + propType + "` ") +\n        ("supplied to `" + componentName + "`, expected `object`.")\n      );\n    }\n    for (var key in shapeTypes) {\n      var checker = shapeTypes[key];\n      if (!checker) {\n        continue;\n      }\n      var error = checker(propValue, key, componentName, location);\n      if (error) {\n        return error;\n      }\n    }\n    return null;\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction isNode(propValue) {\n  switch (typeof propValue) {\n    case \'number\':\n    case \'string\':\n    case \'undefined\':\n      return true;\n    case \'boolean\':\n      return !propValue;\n    case \'object\':\n      if (Array.isArray(propValue)) {\n        return propValue.every(isNode);\n      }\n      if (propValue === null || ReactElement.isValidElement(propValue)) {\n        return true;\n      }\n      propValue = ReactFragment.extractIfFragment(propValue);\n      for (var k in propValue) {\n        if (!isNode(propValue[k])) {\n          return false;\n        }\n      }\n      return true;\n    default:\n      return false;\n  }\n}\n\n// Equivalent of `typeof` but with special handling for array and regexp.\nfunction getPropType(propValue) {\n  var propType = typeof propValue;\n  if (Array.isArray(propValue)) {\n    return \'array\';\n  }\n  if (propValue instanceof RegExp) {\n    // Old webkits (at least until Android 4.0) return \'function\' rather than\n    // \'object\' for typeof a RegExp. We\'ll normalize this here so that /bla/\n    // passes PropTypes.object.\n    return \'object\';\n  }\n  return propType;\n}\n\n// This handles more types than `getPropType`. Only used for error messages.\n// See `createPrimitiveTypeChecker`.\nfunction getPreciseType(propValue) {\n  var propType = getPropType(propValue);\n  if (propType === \'object\') {\n    if (propValue instanceof Date) {\n      return \'date\';\n    } else if (propValue instanceof RegExp) {\n      return \'regexp\';\n    }\n  }\n  return propType;\n}\n\nmodule.exports = ReactPropTypes;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactPropTypes.js\n ** module id = 81\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactPropTypes.js?')},/*!**********************************************!*\
  !*** ./~/react/lib/ReactPutListenerQueue.js ***!
  \**********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPutListenerQueue\n */\n\n'use strict';\n\nvar PooledClass = __webpack_require__(/*! ./PooledClass */ 12);\nvar ReactBrowserEventEmitter = __webpack_require__(/*! ./ReactBrowserEventEmitter */ 21);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\n\nfunction ReactPutListenerQueue() {\n  this.listenersToPut = [];\n}\n\nassign(ReactPutListenerQueue.prototype, {\n  enqueuePutListener: function(rootNodeID, propKey, propValue) {\n    this.listenersToPut.push({\n      rootNodeID: rootNodeID,\n      propKey: propKey,\n      propValue: propValue\n    });\n  },\n\n  putListeners: function() {\n    for (var i = 0; i < this.listenersToPut.length; i++) {\n      var listenerToPut = this.listenersToPut[i];\n      ReactBrowserEventEmitter.putListener(\n        listenerToPut.rootNodeID,\n        listenerToPut.propKey,\n        listenerToPut.propValue\n      );\n    }\n  },\n\n  reset: function() {\n    this.listenersToPut.length = 0;\n  },\n\n  destructor: function() {\n    this.reset();\n  }\n});\n\nPooledClass.addPoolingTo(ReactPutListenerQueue);\n\nmodule.exports = ReactPutListenerQueue;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactPutListenerQueue.js\n ** module id = 82\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactPutListenerQueue.js?")},/*!***************************************!*\
  !*** ./~/react/lib/ReactRootIndex.js ***!
  \***************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactRootIndex\n * @typechecks\n */\n\n'use strict';\n\nvar ReactRootIndexInjection = {\n  /**\n   * @param {function} _createReactRootIndex\n   */\n  injectCreateReactRootIndex: function(_createReactRootIndex) {\n    ReactRootIndex.createReactRootIndex = _createReactRootIndex;\n  }\n};\n\nvar ReactRootIndex = {\n  createReactRootIndex: null,\n  injection: ReactRootIndexInjection\n};\n\nmodule.exports = ReactRootIndex;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactRootIndex.js\n ** module id = 83\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactRootIndex.js?")},/*!*********************************************!*\
  !*** ./~/react/lib/ReactTransitionGroup.js ***!
  \*********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactTransitionGroup\n */\n\n'use strict';\n\nvar React = __webpack_require__(/*! ./React */ 20);\nvar ReactTransitionChildMapping = __webpack_require__(/*! ./ReactTransitionChildMapping */ 166);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar cloneWithProps = __webpack_require__(/*! ./cloneWithProps */ 86);\nvar emptyFunction = __webpack_require__(/*! ./emptyFunction */ 10);\n\nvar ReactTransitionGroup = React.createClass({\n  displayName: 'ReactTransitionGroup',\n\n  propTypes: {\n    component: React.PropTypes.any,\n    childFactory: React.PropTypes.func\n  },\n\n  getDefaultProps: function() {\n    return {\n      component: 'span',\n      childFactory: emptyFunction.thatReturnsArgument\n    };\n  },\n\n  getInitialState: function() {\n    return {\n      children: ReactTransitionChildMapping.getChildMapping(this.props.children)\n    };\n  },\n\n  componentWillMount: function() {\n    this.currentlyTransitioningKeys = {};\n    this.keysToEnter = [];\n    this.keysToLeave = [];\n  },\n\n  componentDidMount: function() {\n    var initialChildMapping = this.state.children;\n    for (var key in initialChildMapping) {\n      if (initialChildMapping[key]) {\n        this.performAppear(key);\n      }\n    }\n  },\n\n  componentWillReceiveProps: function(nextProps) {\n    var nextChildMapping = ReactTransitionChildMapping.getChildMapping(\n      nextProps.children\n    );\n    var prevChildMapping = this.state.children;\n\n    this.setState({\n      children: ReactTransitionChildMapping.mergeChildMappings(\n        prevChildMapping,\n        nextChildMapping\n      )\n    });\n\n    var key;\n\n    for (key in nextChildMapping) {\n      var hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);\n      if (nextChildMapping[key] && !hasPrev &&\n          !this.currentlyTransitioningKeys[key]) {\n        this.keysToEnter.push(key);\n      }\n    }\n\n    for (key in prevChildMapping) {\n      var hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);\n      if (prevChildMapping[key] && !hasNext &&\n          !this.currentlyTransitioningKeys[key]) {\n        this.keysToLeave.push(key);\n      }\n    }\n\n    // If we want to someday check for reordering, we could do it here.\n  },\n\n  componentDidUpdate: function() {\n    var keysToEnter = this.keysToEnter;\n    this.keysToEnter = [];\n    keysToEnter.forEach(this.performEnter);\n\n    var keysToLeave = this.keysToLeave;\n    this.keysToLeave = [];\n    keysToLeave.forEach(this.performLeave);\n  },\n\n  performAppear: function(key) {\n    this.currentlyTransitioningKeys[key] = true;\n\n    var component = this.refs[key];\n\n    if (component.componentWillAppear) {\n      component.componentWillAppear(\n        this._handleDoneAppearing.bind(this, key)\n      );\n    } else {\n      this._handleDoneAppearing(key);\n    }\n  },\n\n  _handleDoneAppearing: function(key) {\n    var component = this.refs[key];\n    if (component.componentDidAppear) {\n      component.componentDidAppear();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n\n    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(\n      this.props.children\n    );\n\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n      // This was removed before it had fully appeared. Remove it.\n      this.performLeave(key);\n    }\n  },\n\n  performEnter: function(key) {\n    this.currentlyTransitioningKeys[key] = true;\n\n    var component = this.refs[key];\n\n    if (component.componentWillEnter) {\n      component.componentWillEnter(\n        this._handleDoneEntering.bind(this, key)\n      );\n    } else {\n      this._handleDoneEntering(key);\n    }\n  },\n\n  _handleDoneEntering: function(key) {\n    var component = this.refs[key];\n    if (component.componentDidEnter) {\n      component.componentDidEnter();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n\n    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(\n      this.props.children\n    );\n\n    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {\n      // This was removed before it had fully entered. Remove it.\n      this.performLeave(key);\n    }\n  },\n\n  performLeave: function(key) {\n    this.currentlyTransitioningKeys[key] = true;\n\n    var component = this.refs[key];\n    if (component.componentWillLeave) {\n      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));\n    } else {\n      // Note that this is somewhat dangerous b/c it calls setState()\n      // again, effectively mutating the component before all the work\n      // is done.\n      this._handleDoneLeaving(key);\n    }\n  },\n\n  _handleDoneLeaving: function(key) {\n    var component = this.refs[key];\n\n    if (component.componentDidLeave) {\n      component.componentDidLeave();\n    }\n\n    delete this.currentlyTransitioningKeys[key];\n\n    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(\n      this.props.children\n    );\n\n    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {\n      // This entered again before it fully left. Add it again.\n      this.performEnter(key);\n    } else {\n      var newChildren = assign({}, this.state.children);\n      delete newChildren[key];\n      this.setState({children: newChildren});\n    }\n  },\n\n  render: function() {\n    // TODO: we could get rid of the need for the wrapper node\n    // by cloning a single child\n    var childrenToRender = [];\n    for (var key in this.state.children) {\n      var child = this.state.children[key];\n      if (child) {\n        // You may need to apply reactive updates to a child as it is leaving.\n        // The normal React way to do it won't work since the child will have\n        // already been removed. In case you need this behavior you can provide\n        // a childFactory function to wrap every child, even the ones that are\n        // leaving.\n        childrenToRender.push(cloneWithProps(\n          this.props.childFactory(child),\n          {ref: key, key: key}\n        ));\n      }\n    }\n    return React.createElement(\n      this.props.component,\n      this.props,\n      childrenToRender\n    );\n  }\n});\n\nmodule.exports = ReactTransitionGroup;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactTransitionGroup.js\n ** module id = 84\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactTransitionGroup.js?")},/*!****************************************!*\
  !*** ./~/react/lib/ViewportMetrics.js ***!
  \****************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ViewportMetrics\n */\n\n'use strict';\n\nvar ViewportMetrics = {\n\n  currentScrollLeft: 0,\n\n  currentScrollTop: 0,\n\n  refreshScrollValues: function(scrollPosition) {\n    ViewportMetrics.currentScrollLeft = scrollPosition.x;\n    ViewportMetrics.currentScrollTop = scrollPosition.y;\n  }\n\n};\n\nmodule.exports = ViewportMetrics;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ViewportMetrics.js\n ** module id = 85\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ViewportMetrics.js?")},/*!***************************************!*\
  !*** ./~/react/lib/cloneWithProps.js ***!
  \***************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks static-only\n * @providesModule cloneWithProps\n */\n\n'use strict';\n\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\nvar ReactPropTransferer = __webpack_require__(/*! ./ReactPropTransferer */ 160);\n\nvar keyOf = __webpack_require__(/*! ./keyOf */ 11);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nvar CHILDREN_PROP = keyOf({children: null});\n\n/**\n * Sometimes you want to change the props of a child passed to you. Usually\n * this is to add a CSS class.\n *\n * @param {ReactElement} child child element you'd like to clone\n * @param {object} props props you'd like to modify. className and style will be\n * merged automatically.\n * @return {ReactElement} a clone of child with props merged in.\n */\nfunction cloneWithProps(child, props) {\n  if (false) {\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      !child.ref,\n      'You are calling cloneWithProps() on a child with a ref. This is ' +\n      'dangerous because you\\'re creating a new child which will not be ' +\n      'added as a ref to its parent.'\n    ) : null);\n  }\n\n  var newProps = ReactPropTransferer.mergeProps(props, child.props);\n\n  // Use `child.props.children` if it is provided.\n  if (!newProps.hasOwnProperty(CHILDREN_PROP) &&\n      child.props.hasOwnProperty(CHILDREN_PROP)) {\n    newProps.children = child.props.children;\n  }\n\n  // The current API doesn't retain _owner and _context, which is why this\n  // doesn't use ReactElement.cloneAndReplaceProps.\n  return ReactElement.createElement(child.type, newProps);\n}\n\nmodule.exports = cloneWithProps;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/cloneWithProps.js\n ** module id = 86\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/cloneWithProps.js?")},/*!*************************************!*\
  !*** ./~/react/lib/containsNode.js ***!
  \*************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule containsNode\n * @typechecks\n */\n\nvar isTextNode = __webpack_require__(/*! ./isTextNode */ 196);\n\n/*jslint bitwise:true */\n\n/**\n * Checks if a given DOM node contains or is another DOM node.\n *\n * @param {?DOMNode} outerNode Outer DOM node.\n * @param {?DOMNode} innerNode Inner DOM node.\n * @return {boolean} True if `outerNode` contains or is `innerNode`.\n */\nfunction containsNode(outerNode, innerNode) {\n  if (!outerNode || !innerNode) {\n    return false;\n  } else if (outerNode === innerNode) {\n    return true;\n  } else if (isTextNode(outerNode)) {\n    return false;\n  } else if (isTextNode(innerNode)) {\n    return containsNode(outerNode, innerNode.parentNode);\n  } else if (outerNode.contains) {\n    return outerNode.contains(innerNode);\n  } else if (outerNode.compareDocumentPosition) {\n    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = containsNode;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/containsNode.js\n ** module id = 87\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/containsNode.js?")},/*!************************************!*\
  !*** ./~/react/lib/findDOMNode.js ***!
  \************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule findDOMNode\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactCurrentOwner = __webpack_require__(/*! ./ReactCurrentOwner */ 14);\nvar ReactInstanceMap = __webpack_require__(/*! ./ReactInstanceMap */ 24);\nvar ReactMount = __webpack_require__(/*! ./ReactMount */ 15);\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\nvar isNode = __webpack_require__(/*! ./isNode */ 94);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\n/**\n * Returns the DOM node rendered by this element.\n *\n * @param {ReactComponent|DOMElement} componentOrElement\n * @return {DOMElement} The root node of this element.\n */\nfunction findDOMNode(componentOrElement) {\n  if (false) {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null) {\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        owner._warnedAboutRefsInRender,\n        '%s is accessing getDOMNode or findDOMNode inside its render(). ' +\n        'render() should be a pure function of props and state. It should ' +\n        'never access something that requires stale data from the previous ' +\n        'render, such as refs. Move this logic to componentDidMount and ' +\n        'componentDidUpdate instead.',\n        owner.getName() || 'A component'\n      ) : null);\n      owner._warnedAboutRefsInRender = true;\n    }\n  }\n  if (componentOrElement == null) {\n    return null;\n  }\n  if (isNode(componentOrElement)) {\n    return componentOrElement;\n  }\n  if (ReactInstanceMap.has(componentOrElement)) {\n    return ReactMount.getNodeFromInstance(componentOrElement);\n  }\n  (false ? invariant(\n    componentOrElement.render == null ||\n    typeof componentOrElement.render !== 'function',\n    'Component (with keys: %s) contains `render` method ' +\n    'but is not mounted in the DOM',\n    Object.keys(componentOrElement)\n  ) : invariant(componentOrElement.render == null ||\n  typeof componentOrElement.render !== 'function'));\n  (false ? invariant(\n    false,\n    'Element appears to be neither ReactComponent nor DOMNode (keys: %s)',\n    Object.keys(componentOrElement)\n  ) : invariant(false));\n}\n\nmodule.exports = findDOMNode;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/findDOMNode.js\n ** module id = 88\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/findDOMNode.js?")},/*!**********************************!*\
  !*** ./~/react/lib/focusNode.js ***!
  \**********************************/
function(module,exports){eval('/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule focusNode\n */\n\n"use strict";\n\n/**\n * @param {DOMElement} node input/textarea to focus\n */\nfunction focusNode(node) {\n  // IE8 can throw "Can\'t move focus to the control because it is invisible,\n  // not enabled, or of a type that does not accept the focus." for all kinds of\n  // reasons that are too expensive and fragile to test.\n  try {\n    node.focus();\n  } catch(e) {\n  }\n}\n\nmodule.exports = focusNode;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/focusNode.js\n ** module id = 89\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/focusNode.js?')},/*!*****************************************!*\
  !*** ./~/react/lib/getActiveElement.js ***!
  \*****************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getActiveElement\n * @typechecks\n */\n\n/**\n * Same as document.activeElement but wraps in a try-catch block. In IE it is\n * not safe to call document.activeElement if there is nothing focused.\n *\n * The activeElement will be null only if the document body is not yet defined.\n */\nfunction getActiveElement() /*?DOMElement*/ {\n  try {\n    return document.activeElement || document.body;\n  } catch (e) {\n    return document.body;\n  }\n}\n\nmodule.exports = getActiveElement;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getActiveElement.js\n ** module id = 90\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getActiveElement.js?")},/*!**************************************!*\
  !*** ./~/react/lib/getIteratorFn.js ***!
  \**************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getIteratorFn\n * @typechecks static-only\n */\n\n'use strict';\n\n/* global Symbol */\nvar ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n/**\n * Returns the iterator method function contained on the iterable object.\n *\n * Be sure to invoke the function with the iterable as context:\n *\n *     var iteratorFn = getIteratorFn(myIterable);\n *     if (iteratorFn) {\n *       var iterator = iteratorFn.call(myIterable);\n *       ...\n *     }\n *\n * @param {?object} maybeIterable\n * @return {?function}\n */\nfunction getIteratorFn(maybeIterable) {\n  var iteratorFn = maybeIterable && (\n    (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL])\n  );\n  if (typeof iteratorFn === 'function') {\n    return iteratorFn;\n  }\n}\n\nmodule.exports = getIteratorFn;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getIteratorFn.js\n ** module id = 91\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getIteratorFn.js?")},/*!**************************************!*\
  !*** ./~/react/lib/getMarkupWrap.js ***!
  \**************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getMarkupWrap\n */\n\nvar ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ 6);\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\n/**\n * Dummy container used to detect which wraps are necessary.\n */\nvar dummyNode =\n  ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;\n\n/**\n * Some browsers cannot use `innerHTML` to render certain elements standalone,\n * so we wrap them, render the wrapped nodes, then extract the desired node.\n *\n * In IE8, certain elements cannot render alone, so wrap all elements ('*').\n */\nvar shouldWrap = {\n  // Force wrapping for SVG elements because if they get created inside a <div>,\n  // they will be initialized in the wrong namespace (and will not display).\n  'circle': true,\n  'clipPath': true,\n  'defs': true,\n  'ellipse': true,\n  'g': true,\n  'line': true,\n  'linearGradient': true,\n  'path': true,\n  'polygon': true,\n  'polyline': true,\n  'radialGradient': true,\n  'rect': true,\n  'stop': true,\n  'text': true\n};\n\nvar selectWrap = [1, '<select multiple=\"true\">', '</select>'];\nvar tableWrap = [1, '<table>', '</table>'];\nvar trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\nvar svgWrap = [1, '<svg>', '</svg>'];\n\nvar markupWrap = {\n  '*': [1, '?<div>', '</div>'],\n\n  'area': [1, '<map>', '</map>'],\n  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],\n  'legend': [1, '<fieldset>', '</fieldset>'],\n  'param': [1, '<object>', '</object>'],\n  'tr': [2, '<table><tbody>', '</tbody></table>'],\n\n  'optgroup': selectWrap,\n  'option': selectWrap,\n\n  'caption': tableWrap,\n  'colgroup': tableWrap,\n  'tbody': tableWrap,\n  'tfoot': tableWrap,\n  'thead': tableWrap,\n\n  'td': trWrap,\n  'th': trWrap,\n\n  'circle': svgWrap,\n  'clipPath': svgWrap,\n  'defs': svgWrap,\n  'ellipse': svgWrap,\n  'g': svgWrap,\n  'line': svgWrap,\n  'linearGradient': svgWrap,\n  'path': svgWrap,\n  'polygon': svgWrap,\n  'polyline': svgWrap,\n  'radialGradient': svgWrap,\n  'rect': svgWrap,\n  'stop': svgWrap,\n  'text': svgWrap\n};\n\n/**\n * Gets the markup wrap configuration for the supplied `nodeName`.\n *\n * NOTE: This lazily detects which wraps are necessary for the current browser.\n *\n * @param {string} nodeName Lowercase `nodeName`.\n * @return {?array} Markup wrap configuration, if applicable.\n */\nfunction getMarkupWrap(nodeName) {\n  (false ? invariant(!!dummyNode, 'Markup wrapping node not initialized') : invariant(!!dummyNode));\n  if (!markupWrap.hasOwnProperty(nodeName)) {\n    nodeName = '*';\n  }\n  if (!shouldWrap.hasOwnProperty(nodeName)) {\n    if (nodeName === '*') {\n      dummyNode.innerHTML = '<link />';\n    } else {\n      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';\n    }\n    shouldWrap[nodeName] = !dummyNode.firstChild;\n  }\n  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;\n}\n\n\nmodule.exports = getMarkupWrap;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getMarkupWrap.js\n ** module id = 92\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getMarkupWrap.js?")},/*!***********************************************!*\
  !*** ./~/react/lib/getTextContentAccessor.js ***!
  \***********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getTextContentAccessor\n */\n\n'use strict';\n\nvar ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ 6);\n\nvar contentKey = null;\n\n/**\n * Gets the key used to access text content on a DOM node.\n *\n * @return {?string} Key used to access text content.\n * @internal\n */\nfunction getTextContentAccessor() {\n  if (!contentKey && ExecutionEnvironment.canUseDOM) {\n    // Prefer textContent to innerText because many browsers support both but\n    // SVG <text> elements don't support innerText even when <div> does.\n    contentKey = 'textContent' in document.documentElement ?\n      'textContent' :\n      'innerText';\n  }\n  return contentKey;\n}\n\nmodule.exports = getTextContentAccessor;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getTextContentAccessor.js\n ** module id = 93\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getTextContentAccessor.js?")},/*!*******************************!*\
  !*** ./~/react/lib/isNode.js ***!
  \*******************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isNode\n * @typechecks\n */\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM node.\n */\nfunction isNode(object) {\n  return !!(object && (\n    ((typeof Node === 'function' ? object instanceof Node : typeof object === 'object' &&\n    typeof object.nodeType === 'number' &&\n    typeof object.nodeName === 'string'))\n  ));\n}\n\nmodule.exports = isNode;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/isNode.js\n ** module id = 94\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/isNode.js?")},/*!*******************************************!*\
  !*** ./~/react/lib/isTextInputElement.js ***!
  \*******************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isTextInputElement\n */\n\n'use strict';\n\n/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */\nvar supportedInputTypes = {\n  'color': true,\n  'date': true,\n  'datetime': true,\n  'datetime-local': true,\n  'email': true,\n  'month': true,\n  'number': true,\n  'password': true,\n  'range': true,\n  'search': true,\n  'tel': true,\n  'text': true,\n  'time': true,\n  'url': true,\n  'week': true\n};\n\nfunction isTextInputElement(elem) {\n  return elem && (\n    (elem.nodeName === 'INPUT' && supportedInputTypes[elem.type] || elem.nodeName === 'TEXTAREA')\n  );\n}\n\nmodule.exports = isTextInputElement;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/isTextInputElement.js\n ** module id = 95\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/isTextInputElement.js?")},/*!**********************************!*\
  !*** ./~/react/lib/onlyChild.js ***!
  \**********************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule onlyChild\n */\n'use strict';\n\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection. The current implementation of this\n * function assumes that a single child gets passed without a wrapper, but the\n * purpose of this helper function is to abstract away the particular structure\n * of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactComponent} The first and only `ReactComponent` contained in the\n * structure.\n */\nfunction onlyChild(children) {\n  (false ? invariant(\n    ReactElement.isValidElement(children),\n    'onlyChild must be passed a children with exactly one child.'\n  ) : invariant(ReactElement.isValidElement(children)));\n  return children;\n}\n\nmodule.exports = onlyChild;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/onlyChild.js\n ** module id = 96\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/onlyChild.js?")},/*!*************************************!*\
  !*** ./~/react/lib/shallowEqual.js ***!
  \*************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule shallowEqual\n */\n\n'use strict';\n\n/**\n * Performs equality by iterating through keys on an object and returning\n * false when any key has values which are not strictly equal between\n * objA and objB. Returns true when the values of all keys are strictly equal.\n *\n * @return {boolean}\n */\nfunction shallowEqual(objA, objB) {\n  if (objA === objB) {\n    return true;\n  }\n  var key;\n  // Test for A's keys different from B.\n  for (key in objA) {\n    if (objA.hasOwnProperty(key) &&\n        (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {\n      return false;\n    }\n  }\n  // Test for B's keys missing from A.\n  for (key in objB) {\n    if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = shallowEqual;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/shallowEqual.js\n ** module id = 97\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/shallowEqual.js?")},/*!********************************************!*\
  !*** ./~/react/lib/traverseAllChildren.js ***!
  \********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule traverseAllChildren\n */\n\n'use strict';\n\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\nvar ReactFragment = __webpack_require__(/*! ./ReactFragment */ 22);\nvar ReactInstanceHandles = __webpack_require__(/*! ./ReactInstanceHandles */ 23);\n\nvar getIteratorFn = __webpack_require__(/*! ./getIteratorFn */ 91);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\nvar SUBSEPARATOR = ':';\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nvar userProvidedKeyEscaperLookup = {\n  '=': '=0',\n  '.': '=1',\n  ':': '=2'\n};\n\nvar userProvidedKeyEscapeRegex = /[=.:]/g;\n\nvar didWarnAboutMaps = false;\n\nfunction userProvidedKeyEscaper(match) {\n  return userProvidedKeyEscaperLookup[match];\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  if (component && component.key != null) {\n    // Explicit key\n    return wrapUserProvidedKey(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\n/**\n * Escape a component key so that it is safe to use in a reactid.\n *\n * @param {*} key Component key to be escaped.\n * @return {string} An escaped string.\n */\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(\n    userProvidedKeyEscapeRegex,\n    userProvidedKeyEscaper\n  );\n}\n\n/**\n * Wrap a `key` value explicitly provided by the user to distinguish it from\n * implicitly-generated keys generated by a component's index in its parent.\n *\n * @param {string} key Value of a user-provided `key` attribute\n * @return {string}\n */\nfunction wrapUserProvidedKey(key) {\n  return '$' + escapeUserProvidedKey(key);\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!number} indexSoFar Number of children encountered until this point.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildrenImpl(\n  children,\n  nameSoFar,\n  indexSoFar,\n  callback,\n  traverseContext\n) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  if (children === null ||\n      type === 'string' ||\n      type === 'number' ||\n      ReactElement.isValidElement(children)) {\n    callback(\n      traverseContext,\n      children,\n      // If it's the only child, treat the name as if it was wrapped in an array\n      // so that it's consistent if the number of children grows.\n      nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,\n      indexSoFar\n    );\n    return 1;\n  }\n\n  var child, nextName, nextIndex;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = (\n        (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) +\n        getComponentKey(child, i)\n      );\n      nextIndex = indexSoFar + subtreeCount;\n      subtreeCount += traverseAllChildrenImpl(\n        child,\n        nextName,\n        nextIndex,\n        callback,\n        traverseContext\n      );\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n    if (iteratorFn) {\n      var iterator = iteratorFn.call(children);\n      var step;\n      if (iteratorFn !== children.entries) {\n        var ii = 0;\n        while (!(step = iterator.next()).done) {\n          child = step.value;\n          nextName = (\n            (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) +\n            getComponentKey(child, ii++)\n          );\n          nextIndex = indexSoFar + subtreeCount;\n          subtreeCount += traverseAllChildrenImpl(\n            child,\n            nextName,\n            nextIndex,\n            callback,\n            traverseContext\n          );\n        }\n      } else {\n        if (false) {\n          (\"production\" !== process.env.NODE_ENV ? warning(\n            didWarnAboutMaps,\n            'Using Maps as children is not yet fully supported. It is an ' +\n            'experimental feature that might be removed. Convert it to a ' +\n            'sequence / iterable of keyed ReactElements instead.'\n          ) : null);\n          didWarnAboutMaps = true;\n        }\n        // Iterator will provide entry [k,v] tuples rather than values.\n        while (!(step = iterator.next()).done) {\n          var entry = step.value;\n          if (entry) {\n            child = entry[1];\n            nextName = (\n              (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) +\n              wrapUserProvidedKey(entry[0]) + SUBSEPARATOR +\n              getComponentKey(child, 0)\n            );\n            nextIndex = indexSoFar + subtreeCount;\n            subtreeCount += traverseAllChildrenImpl(\n              child,\n              nextName,\n              nextIndex,\n              callback,\n              traverseContext\n            );\n          }\n        }\n      }\n    } else if (type === 'object') {\n      (false ? invariant(\n        children.nodeType !== 1,\n        'traverseAllChildren(...): Encountered an invalid child; DOM ' +\n        'elements are not valid children of React components.'\n      ) : invariant(children.nodeType !== 1));\n      var fragment = ReactFragment.extract(children);\n      for (var key in fragment) {\n        if (fragment.hasOwnProperty(key)) {\n          child = fragment[key];\n          nextName = (\n            (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) +\n            wrapUserProvidedKey(key) + SUBSEPARATOR +\n            getComponentKey(child, 0)\n          );\n          nextIndex = indexSoFar + subtreeCount;\n          subtreeCount += traverseAllChildrenImpl(\n            child,\n            nextName,\n            nextIndex,\n            callback,\n            traverseContext\n          );\n        }\n      }\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', 0, callback, traverseContext);\n}\n\nmodule.exports = traverseAllChildren;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/traverseAllChildren.js\n ** module id = 98\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/traverseAllChildren.js?")},/*!***********************!*\
  !*** ./src/chart.jsx ***!
  \***********************/
function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _interopRequireDefault = __webpack_require__(/*! babel-runtime/helpers/interop-require-default */ 67)['default'];\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _react = __webpack_require__(/*! react */ 66);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactHighcharts = __webpack_require__(/*! react-highcharts */ 121);\n\nvar _reactHighcharts2 = _interopRequireDefault(_reactHighcharts);\n\nvar dateMultiple = 24 * 60 * 60 * 1000;\n\nvar Chart = _react2['default'].createClass({\n  displayName: 'Chart',\n\n  propTypes: {\n    data: _react2['default'].PropTypes.array.isRequired,\n    term: _react2['default'].PropTypes.string.isRequired\n  },\n  points: function points() {\n    return this.props.data.map(function (d, i) {\n      return [d.time * dateMultiple, d.count];\n    });\n  },\n  config: function config() {\n    return {\n      title: { text: 'Adverse events' },\n      credits: { text: 'open fda', href: 'https://open.fda.gov' },\n      xAxis: {\n        type: 'datetime',\n        title: { text: 'Date' }\n      },\n      yAxis: {\n        title: {\n          text: 'Event count'\n        },\n        min: 0\n      },\n      series: [{\n        name: this.props.term,\n        data: this.points()\n      }]\n    };\n  },\n  render: function render() {\n    return _react2['default'].createElement(_reactHighcharts2['default'], { config: this.config() });\n  }\n});\n\nexports['default'] = Chart;\nmodule.exports = exports['default'];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/chart.jsx\n ** module id = 99\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/chart.jsx?")},/*!***********************!*\
  !*** ./src/index.jsx ***!
  \***********************/
function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _Promise = __webpack_require__(/*! babel-runtime/core-js/promise */ 101)['default'];\n\nvar _interopRequireDefault = __webpack_require__(/*! babel-runtime/helpers/interop-require-default */ 67)['default'];\n\nvar _react = __webpack_require__(/*! react */ 66);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _chart = __webpack_require__(/*! chart */ 99);\n\nvar _chart2 = _interopRequireDefault(_chart);\n\nvar get = function get(url, query) {\n  return new _Promise(function (fulfill, reject) {\n    var request = new XMLHttpRequest();\n    request.open('GET', url, true);\n    request.onload = function () {\n      if (request.status >= 200 && request.status < 400) {\n        fulfill(JSON.parse(request.responseText));\n      }\n    };\n    request.send(query);\n  });\n};\n\nvar App = _react2['default'].createClass({\n  displayName: 'App',\n\n  getInitialState: function getInitialState() {\n    return { events: [], term: '' };\n  },\n  search: function search(e) {\n    e.preventDefault();\n    var term = e.target.search.value;\n    this.setState({ term: term });\n    get((\"http://quirx.herokuapp.com\") + '/events.json?q=' + term).then((function (response) {\n      this.setState({ events: response.events });\n    }).bind(this));\n  },\n  render: function render() {\n    return _react2['default'].createElement(\n      'main',\n      null,\n      _react2['default'].createElement(\n        'form',\n        { onSubmit: this.search },\n        _react2['default'].createElement(\n          'label',\n          { htmlFor: 'search' },\n          'Search'\n        ),\n        _react2['default'].createElement('input', { id: 'search', type: 'search', autoFocus: true }),\n        _react2['default'].createElement('input', { type: 'submit', value: 'Search' })\n      ),\n      _react2['default'].createElement(\n        'p',\n        null,\n        this.state.events.length,\n        ' events matched \"',\n        this.state.term,\n        '\"'\n      ),\n      _react2['default'].createElement(_chart2['default'], { data: this.state.events, term: this.state.term })\n    );\n  }\n});\n_react2['default'].render(_react2['default'].createElement(App, null), document.getElementById('content'));\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.jsx\n ** module id = 100\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/index.jsx?")},/*!********************************************!*\
  !*** ./~/babel-runtime/core-js/promise.js ***!
  \********************************************/
function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(/*! core-js/library/fn/promise */ 102), __esModule: true };\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/promise.js\n ** module id = 101\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/core-js/promise.js?')},/*!*********************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/fn/promise.js ***!
  \*********************************************************/
function(module,exports,__webpack_require__){eval("__webpack_require__(/*! ../modules/es6.object.to-string */ 117);\n__webpack_require__(/*! ../modules/es6.string.iterator */ 119);\n__webpack_require__(/*! ../modules/web.dom.iterable */ 120);\n__webpack_require__(/*! ../modules/es6.promise */ 118);\nmodule.exports = __webpack_require__(/*! ../modules/$ */ 5).core.Promise;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/fn/promise.js\n ** module id = 102\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/fn/promise.js?")},/*!*******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.dom-create.js ***!
  \*******************************************************************/
function(module,exports,__webpack_require__){eval("var $        = __webpack_require__(/*! ./$ */ 5)\n  , document = $.g.document\n  , isObject = $.isObject\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.dom-create.js\n ** module id = 103\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.dom-create.js?")},/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.for-of.js ***!
  \***************************************************************/
function(module,exports,__webpack_require__){eval("var ctx  = __webpack_require__(/*! ./$.ctx */ 35)\n  , get  = __webpack_require__(/*! ./$.iter */ 28).get\n  , call = __webpack_require__(/*! ./$.iter-call */ 107);\nmodule.exports = function(iterable, entries, fn, that){\n  var iterator = get(iterable)\n    , f        = ctx(fn, that, entries ? 2 : 1)\n    , step;\n  while(!(step = iterator.next()).done){\n    if(call(iterator, f, step.value, entries) === false){\n      return call.close(iterator);\n    }\n  }\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.for-of.js\n ** module id = 104\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.for-of.js?")},/*!***********************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.fw.js ***!
  \***********************************************************/
function(module,exports){eval("module.exports = function($){\n  $.FW   = false;\n  $.path = $.core;\n  return $;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.fw.js\n ** module id = 105\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.fw.js?")},/*!***************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.invoke.js ***!
  \***************************************************************/
function(module,exports){eval("// Fast apply\n// http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function(fn, args, that){\n  var un = that === undefined;\n  switch(args.length){\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])\n                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);\n  } return              fn.apply(that, args);\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.invoke.js\n ** module id = 106\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.invoke.js?")},/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.iter-call.js ***!
  \******************************************************************/
function(module,exports,__webpack_require__){eval("var assertObject = __webpack_require__(/*! ./$.assert */ 26).obj;\nfunction close(iterator){\n  var ret = iterator['return'];\n  if(ret !== undefined)assertObject(ret.call(iterator));\n}\nfunction call(iterator, fn, value, entries){\n  try {\n    return entries ? fn(assertObject(value)[0], value[1]) : fn(value);\n  } catch(e){\n    close(iterator);\n    throw e;\n  }\n}\ncall.close = close;\nmodule.exports = call;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.iter-call.js\n ** module id = 107\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.iter-call.js?")},/*!********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.iter-detect.js ***!
  \********************************************************************/
function(module,exports,__webpack_require__){eval("var SYMBOL_ITERATOR = __webpack_require__(/*! ./$.wks */ 16)('iterator')\n  , SAFE_CLOSING    = false;\ntry {\n  var riter = [7][SYMBOL_ITERATOR]();\n  riter['return'] = function(){ SAFE_CLOSING = true; };\n  Array.from(riter, function(){ throw 2; });\n} catch(e){ /* empty */ }\nmodule.exports = function(exec){\n  if(!SAFE_CLOSING)return false;\n  var safe = false;\n  try {\n    var arr  = [7]\n      , iter = arr[SYMBOL_ITERATOR]();\n    iter.next = function(){ safe = true; };\n    arr[SYMBOL_ITERATOR] = function(){ return iter; };\n    exec(arr);\n  } catch(e){ /* empty */ }\n  return safe;\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.iter-detect.js\n ** module id = 108\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.iter-detect.js?")},/*!************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.mix.js ***!
  \************************************************************/
function(module,exports,__webpack_require__){eval("var $redef = __webpack_require__(/*! ./$.redef */ 44);\r\nmodule.exports = function(target, src){\r\n  for(var key in src)$redef(target, key, src[key]);\r\n  return target;\r\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.mix.js\n ** module id = 109\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.mix.js?")},/*!*************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.same.js ***!
  \*************************************************************/
function(module,exports){eval("module.exports = Object.is || function is(x, y){\r\n  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\r\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.same.js\n ** module id = 110\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.same.js?")},/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.set-proto.js ***!
  \******************************************************************/
function(module,exports,__webpack_require__){eval("// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar $      = __webpack_require__(/*! ./$ */ 5)\n  , assert = __webpack_require__(/*! ./$.assert */ 26);\nfunction check(O, proto){\n  assert.obj(O);\n  assert(proto === null || $.isObject(proto), proto, \": can't set as prototype!\");\n}\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} // eslint-disable-line\n    ? function(buggy, set){\n        try {\n          set = __webpack_require__(/*! ./$.ctx */ 35)(Function.call, $.getDesc(Object.prototype, '__proto__').set, 2);\n          set({}, []);\n        } catch(e){ buggy = true; }\n        return function setPrototypeOf(O, proto){\n          check(O, proto);\n          if(buggy)O.__proto__ = proto;\n          else set(O, proto);\n          return O;\n        };\n      }()\n    : undefined),\n  check: check\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.set-proto.js\n ** module id = 111\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.set-proto.js?")},/*!****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.species.js ***!
  \****************************************************************/
function(module,exports,__webpack_require__){eval("var $       = __webpack_require__(/*! ./$ */ 5)\n  , SPECIES = __webpack_require__(/*! ./$.wks */ 16)('species');\nmodule.exports = function(C){\n  if($.DESC && !(SPECIES in C))$.setDesc(C, SPECIES, {\n    configurable: true,\n    get: $.that\n  });\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.species.js\n ** module id = 112\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.species.js?")},/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.string-at.js ***!
  \******************************************************************/
function(module,exports,__webpack_require__){eval("// true  -> String#at\n// false -> String#codePointAt\nvar $ = __webpack_require__(/*! ./$ */ 5);\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String($.assertDefined(that))\n      , i = $.toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l\n      || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n        ? TO_STRING ? s.charAt(i) : a\n        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.string-at.js\n ** module id = 113\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.string-at.js?")},/*!*************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.task.js ***!
  \*************************************************************/
function(module,exports,__webpack_require__){eval("'use strict';\nvar $      = __webpack_require__(/*! ./$ */ 5)\n  , ctx    = __webpack_require__(/*! ./$.ctx */ 35)\n  , cof    = __webpack_require__(/*! ./$.cof */ 27)\n  , invoke = __webpack_require__(/*! ./$.invoke */ 106)\n  , cel    = __webpack_require__(/*! ./$.dom-create */ 103)\n  , global             = $.g\n  , isFunction         = $.isFunction\n  , html               = $.html\n  , process            = global.process\n  , setTask            = global.setImmediate\n  , clearTask          = global.clearImmediate\n  , MessageChannel     = global.MessageChannel\n  , counter            = 0\n  , queue              = {}\n  , ONREADYSTATECHANGE = 'onreadystatechange'\n  , defer, channel, port;\nfunction run(){\n  var id = +this;\n  if($.has(queue, id)){\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n}\nfunction listner(event){\n  run.call(event.data);\n}\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif(!isFunction(setTask) || !isFunction(clearTask)){\n  setTask = function(fn){\n    var args = [], i = 1;\n    while(arguments.length > i)args.push(arguments[i++]);\n    queue[++counter] = function(){\n      invoke(isFunction(fn) ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function(id){\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if(cof(process) == 'process'){\n    defer = function(id){\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Modern browsers, skip implementation for WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is object\n  } else if(global.addEventListener && isFunction(global.postMessage) && !global.importScripts){\n    defer = function(id){\n      global.postMessage(id, '*');\n    };\n    global.addEventListener('message', listner, false);\n  // WebWorkers\n  } else if(isFunction(MessageChannel)){\n    channel = new MessageChannel;\n    port    = channel.port2;\n    channel.port1.onmessage = listner;\n    defer = ctx(port.postMessage, port, 1);\n  // IE8-\n  } else if(ONREADYSTATECHANGE in cel('script')){\n    defer = function(id){\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function(id){\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set:   setTask,\n  clear: clearTask\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.task.js\n ** module id = 114\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.task.js?")},/*!****************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/$.unscope.js ***!
  \****************************************************************/
function(module,exports){eval("module.exports = function(){ /* empty */ };\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/$.unscope.js\n ** module id = 115\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/$.unscope.js?")},/*!*************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.array.iterator.js ***!
  \*************************************************************************/
function(module,exports,__webpack_require__){eval("var $          = __webpack_require__(/*! ./$ */ 5)\n  , setUnscope = __webpack_require__(/*! ./$.unscope */ 115)\n  , ITER       = __webpack_require__(/*! ./$.uid */ 36).safe('iter')\n  , $iter      = __webpack_require__(/*! ./$.iter */ 28)\n  , step       = $iter.step\n  , Iterators  = $iter.Iterators;\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\n__webpack_require__(/*! ./$.iter-define */ 69)(Array, 'Array', function(iterated, kind){\n  $.set(this, ITER, {o: $.toObject(iterated), i: 0, k: kind});\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var iter  = this[ITER]\n    , O     = iter.o\n    , kind  = iter.k\n    , index = iter.i++;\n  if(!O || index >= O.length){\n    iter.o = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\nsetUnscope('keys');\nsetUnscope('values');\nsetUnscope('entries');\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/es6.array.iterator.js\n ** module id = 116\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/es6.array.iterator.js?")},/*!***************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.object.to-string.js ***!
  \***************************************************************************/
function(module,exports,__webpack_require__){eval("'use strict';\n// 19.1.3.6 Object.prototype.toString()\nvar cof = __webpack_require__(/*! ./$.cof */ 27)\n  , tmp = {};\ntmp[__webpack_require__(/*! ./$.wks */ 16)('toStringTag')] = 'z';\nif(__webpack_require__(/*! ./$ */ 5).FW && cof(tmp) != 'z'){\n  __webpack_require__(/*! ./$.redef */ 44)(Object.prototype, 'toString', function toString(){\n    return '[object ' + cof.classof(this) + ']';\n  }, true);\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/es6.object.to-string.js\n ** module id = 117\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/es6.object.to-string.js?")},/*!******************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.promise.js ***!
  \******************************************************************/
function(module,exports,__webpack_require__){eval("'use strict';\nvar $        = __webpack_require__(/*! ./$ */ 5)\n  , ctx      = __webpack_require__(/*! ./$.ctx */ 35)\n  , cof      = __webpack_require__(/*! ./$.cof */ 27)\n  , $def     = __webpack_require__(/*! ./$.def */ 68)\n  , assert   = __webpack_require__(/*! ./$.assert */ 26)\n  , forOf    = __webpack_require__(/*! ./$.for-of */ 104)\n  , setProto = __webpack_require__(/*! ./$.set-proto */ 111).set\n  , same     = __webpack_require__(/*! ./$.same */ 110)\n  , species  = __webpack_require__(/*! ./$.species */ 112)\n  , SPECIES  = __webpack_require__(/*! ./$.wks */ 16)('species')\n  , RECORD   = __webpack_require__(/*! ./$.uid */ 36).safe('record')\n  , PROMISE  = 'Promise'\n  , global   = $.g\n  , process  = global.process\n  , isNode   = cof(process) == 'process'\n  , asap     = process && process.nextTick || __webpack_require__(/*! ./$.task */ 114).set\n  , P        = global[PROMISE]\n  , isFunction     = $.isFunction\n  , isObject       = $.isObject\n  , assertFunction = assert.fn\n  , assertObject   = assert.obj\n  , Wrapper;\n\nfunction testResolve(sub){\n  var test = new P(function(){});\n  if(sub)test.constructor = Object;\n  return P.resolve(test) === test;\n}\n\nvar useNative = function(){\n  var works = false;\n  function P2(x){\n    var self = new P(x);\n    setProto(self, P2.prototype);\n    return self;\n  }\n  try {\n    works = isFunction(P) && isFunction(P.resolve) && testResolve();\n    setProto(P2, P);\n    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});\n    // actual Firefox has broken subclass support, test that\n    if(!(P2.resolve(5).then(function(){}) instanceof P2)){\n      works = false;\n    }\n    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162\n    if(works && $.DESC){\n      var thenableThenGotten = false;\n      P.resolve($.setDesc({}, 'then', {\n        get: function(){ thenableThenGotten = true; }\n      }));\n      works = thenableThenGotten;\n    }\n  } catch(e){ works = false; }\n  return works;\n}();\n\n// helpers\nfunction isPromise(it){\n  return isObject(it) && (useNative ? cof.classof(it) == 'Promise' : RECORD in it);\n}\nfunction sameConstructor(a, b){\n  // library wrapper special case\n  if(!$.FW && a === P && b === Wrapper)return true;\n  return same(a, b);\n}\nfunction getConstructor(C){\n  var S = assertObject(C)[SPECIES];\n  return S != undefined ? S : C;\n}\nfunction isThenable(it){\n  var then;\n  if(isObject(it))then = it.then;\n  return isFunction(then) ? then : false;\n}\nfunction notify(record){\n  var chain = record.c;\n  // strange IE + webpack dev server bug - use .call(global)\n  if(chain.length)asap.call(global, function(){\n    var value = record.v\n      , ok    = record.s == 1\n      , i     = 0;\n    function run(react){\n      var cb = ok ? react.ok : react.fail\n        , ret, then;\n      try {\n        if(cb){\n          if(!ok)record.h = true;\n          ret = cb === true ? value : cb(value);\n          if(ret === react.P){\n            react.rej(TypeError('Promise-chain cycle'));\n          } else if(then = isThenable(ret)){\n            then.call(ret, react.res, react.rej);\n          } else react.res(ret);\n        } else react.rej(value);\n      } catch(err){\n        react.rej(err);\n      }\n    }\n    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach\n    chain.length = 0;\n  });\n}\nfunction isUnhandled(promise){\n  var record = promise[RECORD]\n    , chain  = record.a || record.c\n    , i      = 0\n    , react;\n  if(record.h)return false;\n  while(chain.length > i){\n    react = chain[i++];\n    if(react.fail || !isUnhandled(react.P))return false;\n  } return true;\n}\nfunction $reject(value){\n  var record = this\n    , promise;\n  if(record.d)return;\n  record.d = true;\n  record = record.r || record; // unwrap\n  record.v = value;\n  record.s = 2;\n  record.a = record.c.slice();\n  setTimeout(function(){\n    // strange IE + webpack dev server bug - use .call(global)\n    asap.call(global, function(){\n      if(isUnhandled(promise = record.p)){\n        if(isNode){\n          process.emit('unhandledRejection', value, promise);\n        } else if(global.console && console.error){\n          console.error('Unhandled promise rejection', value);\n        }\n      }\n      record.a = undefined;\n    });\n  }, 1);\n  notify(record);\n}\nfunction $resolve(value){\n  var record = this\n    , then;\n  if(record.d)return;\n  record.d = true;\n  record = record.r || record; // unwrap\n  try {\n    if(then = isThenable(value)){\n      // strange IE + webpack dev server bug - use .call(global)\n      asap.call(global, function(){\n        var wrapper = {r: record, d: false}; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch(e){\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      record.v = value;\n      record.s = 1;\n      notify(record);\n    }\n  } catch(e){\n    $reject.call({r: record, d: false}, e); // wrap\n  }\n}\n\n// constructor polyfill\nif(!useNative){\n  // 25.4.3.1 Promise(executor)\n  P = function Promise(executor){\n    assertFunction(executor);\n    var record = {\n      p: assert.inst(this, P, PROMISE),       // <- promise\n      c: [],                                  // <- awaiting reactions\n      a: undefined,                           // <- checked in isUnhandled reactions\n      s: 0,                                   // <- state\n      d: false,                               // <- done\n      v: undefined,                           // <- value\n      h: false                                // <- handled rejection\n    };\n    $.hide(this, RECORD, record);\n    try {\n      executor(ctx($resolve, record, 1), ctx($reject, record, 1));\n    } catch(err){\n      $reject.call(record, err);\n    }\n  };\n  __webpack_require__(/*! ./$.mix */ 109)(P.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected){\n      var S = assertObject(assertObject(this).constructor)[SPECIES];\n      var react = {\n        ok:   isFunction(onFulfilled) ? onFulfilled : true,\n        fail: isFunction(onRejected)  ? onRejected  : false\n      };\n      var promise = react.P = new (S != undefined ? S : P)(function(res, rej){\n        react.res = assertFunction(res);\n        react.rej = assertFunction(rej);\n      });\n      var record = this[RECORD];\n      record.c.push(react);\n      if(record.a)record.a.push(react);\n      if(record.s)notify(record);\n      return promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function(onRejected){\n      return this.then(undefined, onRejected);\n    }\n  });\n}\n\n// export\n$def($def.G + $def.W + $def.F * !useNative, {Promise: P});\ncof.set(P, PROMISE);\nspecies(P);\nspecies(Wrapper = $.core[PROMISE]);\n\n// statics\n$def($def.S + $def.F * !useNative, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r){\n    return new (getConstructor(this))(function(res, rej){ rej(r); });\n  }\n});\n$def($def.S + $def.F * (!useNative || testResolve(true)), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x){\n    return isPromise(x) && sameConstructor(x.constructor, this)\n      ? x : new this(function(res){ res(x); });\n  }\n});\n$def($def.S + $def.F * !(useNative && __webpack_require__(/*! ./$.iter-detect */ 108)(function(iter){\n  P.all(iter)['catch'](function(){});\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable){\n    var C      = getConstructor(this)\n      , values = [];\n    return new C(function(res, rej){\n      forOf(iterable, false, values.push, values);\n      var remaining = values.length\n        , results   = Array(remaining);\n      if(remaining)$.each.call(values, function(promise, index){\n        C.resolve(promise).then(function(value){\n          results[index] = value;\n          --remaining || res(results);\n        }, rej);\n      });\n      else res(results);\n    });\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable){\n    var C = getConstructor(this);\n    return new C(function(res, rej){\n      forOf(iterable, false, function(promise){\n        C.resolve(promise).then(res, rej);\n      });\n    });\n  }\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/es6.promise.js\n ** module id = 118\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/es6.promise.js?")},/*!**************************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/es6.string.iterator.js ***!
  \**************************************************************************/
function(module,exports,__webpack_require__){eval("var set   = __webpack_require__(/*! ./$ */ 5).set\n  , $at   = __webpack_require__(/*! ./$.string-at */ 113)(true)\n  , ITER  = __webpack_require__(/*! ./$.uid */ 36).safe('iter')\n  , $iter = __webpack_require__(/*! ./$.iter */ 28)\n  , step  = $iter.step;\n\n// 21.1.3.27 String.prototype[@@iterator]()\n__webpack_require__(/*! ./$.iter-define */ 69)(String, 'String', function(iterated){\n  set(this, ITER, {o: String(iterated), i: 0});\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var iter  = this[ITER]\n    , O     = iter.o\n    , index = iter.i\n    , point;\n  if(index >= O.length)return step(1);\n  point = $at(O, index);\n  iter.i += point.length;\n  return step(0, point);\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/es6.string.iterator.js\n ** module id = 119\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/es6.string.iterator.js?")},/*!***********************************************************************!*\
  !*** ./~/babel-runtime/~/core-js/library/modules/web.dom.iterable.js ***!
  \***********************************************************************/
function(module,exports,__webpack_require__){eval("__webpack_require__(/*! ./es6.array.iterator */ 116);\nvar $           = __webpack_require__(/*! ./$ */ 5)\n  , Iterators   = __webpack_require__(/*! ./$.iter */ 28).Iterators\n  , ITERATOR    = __webpack_require__(/*! ./$.wks */ 16)('iterator')\n  , ArrayValues = Iterators.Array\n  , NL          = $.g.NodeList\n  , HTC         = $.g.HTMLCollection\n  , NLProto     = NL && NL.prototype\n  , HTCProto    = HTC && HTC.prototype;\nif($.FW){\n  if(NL && !(ITERATOR in NLProto))$.hide(NLProto, ITERATOR, ArrayValues);\n  if(HTC && !(ITERATOR in HTCProto))$.hide(HTCProto, ITERATOR, ArrayValues);\n}\nIterators.NodeList = Iterators.HTMLCollection = ArrayValues;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/~/core-js/library/modules/web.dom.iterable.js\n ** module id = 120\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/~/core-js/library/modules/web.dom.iterable.js?")},/*!*************************************!*\
  !*** ./~/react-highcharts/index.js ***!
  \*************************************/
function(module,exports,__webpack_require__){eval("(function webpackUniversalModuleDefinition(root, factory) {\n	if(true)\n		module.exports = factory(__webpack_require__(/*! react */ 66), __webpack_require__(/*! react/addons */ 122));\n	else if(typeof define === 'function' && define.amd)\n		define([\"react\", \"react/addons\"], factory);\n	else if(typeof exports === 'object')\n		exports[\"Highcharts\"] = factory(require(\"react\"), require(\"react/addons\"));\n	else\n		root[\"Highcharts\"] = factory(root[\"react\"], root[\"react/addons\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ 	// The module cache\n/******/ 	var installedModules = {};\n/******/\n/******/ 	// The require function\n/******/ 	function __webpack_require__(moduleId) {\n/******/\n/******/ 		// Check if module is in cache\n/******/ 		if(installedModules[moduleId])\n/******/ 			return installedModules[moduleId].exports;\n/******/\n/******/ 		// Create a new module (and put it into the cache)\n/******/ 		var module = installedModules[moduleId] = {\n/******/ 			exports: {},\n/******/ 			id: moduleId,\n/******/ 			loaded: false\n/******/ 		};\n/******/\n/******/ 		// Execute the module function\n/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ 		// Flag the module as loaded\n/******/ 		module.loaded = true;\n/******/\n/******/ 		// Return the exports of the module\n/******/ 		return module.exports;\n/******/ 	}\n/******/\n/******/\n/******/ 	// expose the modules object (__webpack_modules__)\n/******/ 	__webpack_require__.m = modules;\n/******/\n/******/ 	// expose the module cache\n/******/ 	__webpack_require__.c = installedModules;\n/******/\n/******/ 	// __webpack_public_path__\n/******/ 	__webpack_require__.p = \"\";\n/******/\n/******/ 	// Load entry module and return exports\n/******/ 	return __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__(1);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n	/* WEBPACK VAR INJECTION */(function(global) {global.HighchartsAdapter = __webpack_require__(5);\n	var Highcharts = __webpack_require__(6);\n	var React = __webpack_require__(2);\n	var update = __webpack_require__(3).addons.update;\n	module.exports = React.createClass({\n	  displayName: 'Highcharts',\n\n	  renderChart: function () {\n	    if (!this.props.config) {\n	      throw new Error('Config has to be specified, for the Highchart component');\n	    }\n\n	    var config = this.props.config;\n	    var node = this.refs.chart.getDOMNode();\n\n	    if (!config.chart) {\n	      config = update(config, {chart: {$set: {}}})\n	    }\n\n	    config = update(config, {chart: {renderTo: {$set: node}}});\n\n	    new Highcharts.Chart(config);\n	  },\n\n	  componentDidMount: function () {\n	    this.renderChart();\n	  },\n	  componentDidUpdate: function () {\n	    this.renderChart();\n	  },\n	  render: function () {\n	    return React.createElement(\"div\", {className: \"chart\", ref: \"chart\"})\n	  }\n	});\n\n	module.exports.Highcharts = Highcharts;\n	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */,\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n	/**\n	 * @license @product.name@ JS v@product.version@ (@product.date@)\n	 *\n	 * Standalone Highcharts Framework\n	 *\n	 * License: MIT License\n	 */\n\n\n	/*global Highcharts */\n	var HighchartsAdapter = (function () {\n\n	var UNDEFINED,\n		doc = document,\n		emptyArray = [],\n		timers = [],\n		timerId,\n		animSetters = {},\n		Fx;\n\n	Math.easeInOutSine = function (t, b, c, d) {\n		return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n	};\n\n\n\n	/**\n	 * Extend given object with custom events\n	 */\n	function augment(obj) {\n		function removeOneEvent(el, type, fn) {\n			el.removeEventListener(type, fn, false);\n		}\n\n		function IERemoveOneEvent(el, type, fn) {\n			fn = el.HCProxiedMethods[fn.toString()];\n			el.detachEvent('on' + type, fn);\n		}\n\n		function removeAllEvents(el, type) {\n			var events = el.HCEvents,\n				remove,\n				types,\n				len,\n				n;\n\n			if (el.removeEventListener) {\n				remove = removeOneEvent;\n			} else if (el.attachEvent) {\n				remove = IERemoveOneEvent;\n			} else {\n				return; // break on non-DOM events\n			}\n\n\n			if (type) {\n				types = {};\n				types[type] = true;\n			} else {\n				types = events;\n			}\n\n			for (n in types) {\n				if (events[n]) {\n					len = events[n].length;\n					while (len--) {\n						remove(el, n, events[n][len]);\n					}\n				}\n			}\n		}\n\n		if (!obj.HCExtended) {\n			Highcharts.extend(obj, {\n				HCExtended: true,\n\n				HCEvents: {},\n\n				bind: function (name, fn) {\n					var el = this,\n						events = this.HCEvents,\n						wrappedFn;\n\n					// handle DOM events in modern browsers\n					if (el.addEventListener) {\n						el.addEventListener(name, fn, false);\n\n					// handle old IE implementation\n					} else if (el.attachEvent) {\n						\n						wrappedFn = function (e) {\n							e.target = e.srcElement || window; // #2820\n							fn.call(el, e);\n						};\n\n						if (!el.HCProxiedMethods) {\n							el.HCProxiedMethods = {};\n						}\n\n						// link wrapped fn with original fn, so we can get this in removeEvent\n						el.HCProxiedMethods[fn.toString()] = wrappedFn;\n\n						el.attachEvent('on' + name, wrappedFn);\n					}\n\n\n					if (events[name] === UNDEFINED) {\n						events[name] = [];\n					}\n\n					events[name].push(fn);\n				},\n\n				unbind: function (name, fn) {\n					var events,\n						index;\n\n					if (name) {\n						events = this.HCEvents[name] || [];\n						if (fn) {\n							index = HighchartsAdapter.inArray(fn, events);\n							if (index > -1) {\n								events.splice(index, 1);\n								this.HCEvents[name] = events;\n							}\n							if (this.removeEventListener) {\n								removeOneEvent(this, name, fn);\n							} else if (this.attachEvent) {\n								IERemoveOneEvent(this, name, fn);\n							}\n						} else {\n							removeAllEvents(this, name);\n							this.HCEvents[name] = [];\n						}\n					} else {\n						removeAllEvents(this);\n						this.HCEvents = {};\n					}\n				},\n\n				trigger: function (name, args) {\n					var events = this.HCEvents[name] || [],\n						target = this,\n						len = events.length,\n						i,\n						preventDefault,\n						fn;\n\n					// Attach a simple preventDefault function to skip default handler if called\n					preventDefault = function () {\n						args.defaultPrevented = true;\n					};\n					\n					for (i = 0; i < len; i++) {\n						fn = events[i];\n\n						// args is never null here\n						if (args.stopped) {\n							return;\n						}\n\n						args.preventDefault = preventDefault;\n						args.target = target;\n\n						// If the type is not set, we're running a custom event (#2297). If it is set,\n						// we're running a browser event, and setting it will cause en error in\n						// IE8 (#2465).\n						if (!args.type) {\n							args.type = name;\n						}\n						\n\n						\n						// If the event handler return false, prevent the default handler from executing\n						if (fn.call(this, args) === false) {\n							args.preventDefault();\n						}\n					}\n				}\n			});\n		}\n\n		return obj;\n	}\n\n\n	return {\n\n		/**\n		 * Initialize the adapter. This is run once as Highcharts is first run.\n		 */\n		init: function (pathAnim) {\n\n			/**\n			 * Compatibility section to add support for legacy IE. This can be removed if old IE \n			 * support is not needed.\n			 */\n			if (!doc.defaultView) {\n				this._getStyle = function (el, prop) {\n					var val;\n					if (el.style[prop]) {\n						return el.style[prop];\n					} else {\n						if (prop === 'opacity') {\n							prop = 'filter';\n						}\n						/*jslint unparam: true*/\n						val = el.currentStyle[prop.replace(/\\-(\\w)/g, function (a, b) { return b.toUpperCase(); })];\n						if (prop === 'filter') {\n							val = val.replace(\n								/alpha\\(opacity=([0-9]+)\\)/, \n								function (a, b) { \n									return b / 100; \n								}\n							);\n						}\n						/*jslint unparam: false*/\n						return val === '' ? 1 : val;\n					} \n				};\n				this.adapterRun = function (elem, method) {\n					var alias = { width: 'clientWidth', height: 'clientHeight' }[method];\n\n					if (alias) {\n						elem.style.zoom = 1;\n						return elem[alias] - 2 * parseInt(HighchartsAdapter._getStyle(elem, 'padding'), 10);\n					}\n				};\n			}\n\n			if (!Array.prototype.forEach) {\n				this.each = function (arr, fn) { // legacy\n					var i = 0, \n						len = arr.length;\n					for (; i < len; i++) {\n						if (fn.call(arr[i], arr[i], i, arr) === false) {\n							return i;\n						}\n					}\n				};\n			}\n\n			if (!Array.prototype.indexOf) {\n				this.inArray = function (item, arr) {\n					var len, \n						i = 0;\n\n					if (arr) {\n						len = arr.length;\n						\n						for (; i < len; i++) {\n							if (arr[i] === item) {\n								return i;\n							}\n						}\n					}\n\n					return -1;\n				};\n			}\n\n			if (!Array.prototype.filter) {\n				this.grep = function (elements, callback) {\n					var ret = [],\n						i = 0,\n						length = elements.length;\n\n					for (; i < length; i++) {\n						if (!!callback(elements[i], i)) {\n							ret.push(elements[i]);\n						}\n					}\n\n					return ret;\n				};\n			}\n\n			//--- End compatibility section ---\n\n\n			/**\n			 * Start of animation specific code\n			 */\n			Fx = function (elem, options, prop) {\n				this.options = options;\n				this.elem = elem;\n				this.prop = prop;\n			};\n			Fx.prototype = {\n				\n				update: function () {\n					var styles,\n						paths = this.paths,\n						elem = this.elem,\n						elemelem = elem.element; // if destroyed, it is null\n\n					// Animation setter defined from outside\n					if (animSetters[this.prop]) {\n						animSetters[this.prop](this);\n\n					// Animating a path definition on SVGElement\n					} else if (paths && elemelem) {\n						elem.attr('d', pathAnim.step(paths[0], paths[1], this.now, this.toD));\n\n					// Other animations on SVGElement\n					} else if (elem.attr) {\n						if (elemelem) {\n							elem.attr(this.prop, this.now);\n						}\n\n					// HTML styles\n					} else {\n						styles = {};\n						styles[this.prop] = this.now + this.unit;\n						Highcharts.css(elem, styles);\n					}\n					\n					if (this.options.step) {\n						this.options.step.call(this.elem, this.now, this);\n					}\n\n				},\n				custom: function (from, to, unit) {\n					var self = this,\n						t = function (gotoEnd) {\n							return self.step(gotoEnd);\n						},\n						i;\n\n					this.startTime = +new Date();\n					this.start = from;\n					this.end = to;\n					this.unit = unit;\n					this.now = this.start;\n					this.pos = this.state = 0;\n\n					t.elem = this.elem;\n\n					if (t() && timers.push(t) === 1) {\n						timerId = setInterval(function () {\n							\n							for (i = 0; i < timers.length; i++) {\n								if (!timers[i]()) {\n									timers.splice(i--, 1);\n								}\n							}\n\n							if (!timers.length) {\n								clearInterval(timerId);\n							}\n						}, 13);\n					}\n				},\n				\n				step: function (gotoEnd) {\n					var t = +new Date(),\n						ret,\n						done,\n						options = this.options,\n						elem = this.elem,\n						i;\n					\n					if (elem.stopAnimation || (elem.attr && !elem.element)) { // #2616, element including flag is destroyed\n						ret = false;\n\n					} else if (gotoEnd || t >= options.duration + this.startTime) {\n						this.now = this.end;\n						this.pos = this.state = 1;\n						this.update();\n\n						this.options.curAnim[this.prop] = true;\n\n						done = true;\n						for (i in options.curAnim) {\n							if (options.curAnim[i] !== true) {\n								done = false;\n							}\n						}\n\n						if (done) {\n							if (options.complete) {\n								options.complete.call(elem);\n							}\n						}\n						ret = false;\n\n					} else {\n						var n = t - this.startTime;\n						this.state = n / options.duration;\n						this.pos = options.easing(n, 0, 1, options.duration);\n						this.now = this.start + ((this.end - this.start) * this.pos);\n						this.update();\n						ret = true;\n					}\n					return ret;\n				}\n			};\n\n			/**\n			 * The adapter animate method\n			 */\n			this.animate = function (el, prop, opt) {\n				var start,\n					unit = '',\n					end,\n					fx,\n					args,\n					name;\n\n				el.stopAnimation = false; // ready for new\n\n				if (typeof opt !== 'object' || opt === null) {\n					args = arguments;\n					opt = {\n						duration: args[2],\n						easing: args[3],\n						complete: args[4]\n					};\n				}\n				if (typeof opt.duration !== 'number') {\n					opt.duration = 400;\n				}\n				opt.easing = Math[opt.easing] || Math.easeInOutSine;\n				opt.curAnim = Highcharts.extend({}, prop);\n				\n				for (name in prop) {\n					fx = new Fx(el, opt, name);\n					end = null;\n					\n					if (name === 'd') {\n						fx.paths = pathAnim.init(\n							el,\n							el.d,\n							prop.d\n						);\n						fx.toD = prop.d;\n						start = 0;\n						end = 1;\n					} else if (el.attr) {\n						start = el.attr(name);\n					} else {\n						start = parseFloat(HighchartsAdapter._getStyle(el, name)) || 0;\n						if (name !== 'opacity') {\n							unit = 'px';\n						}\n					}\n		\n					if (!end) {\n						end = prop[name];\n					}\n					fx.custom(start, end, unit);\n				}	\n			};\n		},\n\n		/**\n		 * Internal method to return CSS value for given element and property\n		 */\n		_getStyle: function (el, prop) {\n			return window.getComputedStyle(el, undefined).getPropertyValue(prop);\n		},\n\n		/**\n		 * Add an animation setter for a specific property\n		 */\n		addAnimSetter: function (prop, fn) {\n			animSetters[prop] = fn;\n		},\n\n		/**\n		 * Downloads a script and executes a callback when done.\n		 * @param {String} scriptLocation\n		 * @param {Function} callback\n		 */\n		getScript: function (scriptLocation, callback) {\n			// We cannot assume that Assets class from mootools-more is available so instead insert a script tag to download script.\n			var head = doc.getElementsByTagName('head')[0],\n				script = doc.createElement('script');\n\n			script.type = 'text/javascript';\n			script.src = scriptLocation;\n			script.onload = callback;\n\n			head.appendChild(script);\n		},\n\n		/**\n		 * Return the index of an item in an array, or -1 if not found\n		 */\n		inArray: function (item, arr) {\n			return arr.indexOf ? arr.indexOf(item) : emptyArray.indexOf.call(arr, item);\n		},\n\n\n		/**\n		 * A direct link to adapter methods\n		 */\n		adapterRun: function (elem, method) {\n			return parseInt(HighchartsAdapter._getStyle(elem, method), 10);\n		},\n\n		/**\n		 * Filter an array\n		 */\n		grep: function (elements, callback) {\n			return emptyArray.filter.call(elements, callback);\n		},\n\n		/**\n		 * Map an array\n		 */\n		map: function (arr, fn) {\n			var results = [], i = 0, len = arr.length;\n\n			for (; i < len; i++) {\n				results[i] = fn.call(arr[i], arr[i], i, arr);\n			}\n\n			return results;\n		},\n\n		/**\n		 * Get the element's offset position, corrected by overflow:auto. Loosely based on jQuery's offset method.\n		 */\n		offset: function (el) {\n			var docElem = document.documentElement,\n				box = el.getBoundingClientRect();\n\n			return {\n				top: box.top  + (window.pageYOffset || docElem.scrollTop)  - (docElem.clientTop  || 0),\n				left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\n			};\n		},\n\n		/**\n		 * Add an event listener\n		 */\n		addEvent: function (el, type, fn) {\n			augment(el).bind(type, fn);\n		},\n\n		/**\n		 * Remove event added with addEvent\n		 */\n		removeEvent: function (el, type, fn) {\n			augment(el).unbind(type, fn);\n		},\n\n		/**\n		 * Fire an event on a custom object\n		 */\n		fireEvent: function (el, type, eventArguments, defaultFunction) {\n			var e;\n\n			if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {\n				e = doc.createEvent('Events');\n				e.initEvent(type, true, true);\n				e.target = el;\n\n				Highcharts.extend(e, eventArguments);\n\n				if (el.dispatchEvent) {\n					el.dispatchEvent(e);\n				} else {\n					el.fireEvent(type, e);\n				}\n\n			} else if (el.HCExtended === true) {\n				eventArguments = eventArguments || {};\n				el.trigger(type, eventArguments);\n			}\n\n			if (eventArguments && eventArguments.defaultPrevented) {\n				defaultFunction = null;\n			}\n\n			if (defaultFunction) {\n				defaultFunction(eventArguments);\n			}\n		},\n\n		washMouseEvent: function (e) {\n			return e;\n		},\n\n\n		/**\n		 * Stop running animation\n		 */\n		stop: function (el) {\n			el.stopAnimation = true;\n		},\n\n		/**\n		 * Utility for iterating over an array. Parameters are reversed compared to jQuery.\n		 * @param {Array} arr\n		 * @param {Function} fn\n		 */\n		each: function (arr, fn) { // modern browsers\n			return Array.prototype.forEach.call(arr, fn);\n		}\n	};\n	}());\n\n\n	/*** EXPORTS FROM exports-loader ***/\n	module.exports = HighchartsAdapter\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n	// ==ClosureCompiler==\n	// @compilation_level SIMPLE_OPTIMIZATIONS\n\n	/**\n	 * @license Highcharts JS v4.1.4-modified ()\n	 *\n	 * (c) 2009-2014 Torstein Honsi\n	 *\n	 * License: www.highcharts.com/license\n	 */\n\n	// JSLint options:\n	/*global Highcharts, HighchartsAdapter, document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $, console, each, grep */\n	/*jslint ass: true, sloppy: true, forin: true, plusplus: true, nomen: true, vars: true, regexp: true, newcap: true, browser: true, continue: true, white: true */\n	(function () {\n	// encapsulated variables\n	var UNDEFINED,\n		doc = document,\n		win = window,\n		math = Math,\n		mathRound = math.round,\n		mathFloor = math.floor,\n		mathCeil = math.ceil,\n		mathMax = math.max,\n		mathMin = math.min,\n		mathAbs = math.abs,\n		mathCos = math.cos,\n		mathSin = math.sin,\n		mathPI = math.PI,\n		deg2rad = mathPI * 2 / 360,\n\n\n		// some variables\n		userAgent = navigator.userAgent,\n		isOpera = win.opera,\n		isIE = /(msie|trident)/i.test(userAgent) && !isOpera,\n		docMode8 = doc.documentMode === 8,\n		isWebKit = /AppleWebKit/.test(userAgent),\n		isFirefox = /Firefox/.test(userAgent),\n		isTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent),\n		SVG_NS = 'http://www.w3.org/2000/svg',\n		hasSVG = !!doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,\n		hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38\n		useCanVG = !hasSVG && !isIE && !!doc.createElement('canvas').getContext,\n		Renderer,\n		hasTouch,\n		symbolSizes = {},\n		idCounter = 0,\n		garbageBin,\n		defaultOptions,\n		dateFormat, // function\n		globalAnimation,\n		pathAnim,\n		timeUnits,\n		noop = function () { return UNDEFINED; },\n		charts = [],\n		chartCount = 0,\n		PRODUCT = 'Highcharts',\n		VERSION = '4.1.4-modified',\n\n		// some constants for frequently used strings\n		DIV = 'div',\n		ABSOLUTE = 'absolute',\n		RELATIVE = 'relative',\n		HIDDEN = 'hidden',\n		PREFIX = 'highcharts-',\n		VISIBLE = 'visible',\n		PX = 'px',\n		NONE = 'none',\n		M = 'M',\n		L = 'L',\n		numRegex = /^[0-9]+$/,\n		NORMAL_STATE = '',\n		HOVER_STATE = 'hover',\n		SELECT_STATE = 'select',\n		marginNames = ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],\n		\n		// Object for extending Axis\n		AxisPlotLineOrBandExtension,\n\n		// constants for attributes\n		STROKE_WIDTH = 'stroke-width',\n\n		// time methods, changed based on whether or not UTC is used\n		Date,  // Allow using a different Date class\n		makeTime,\n		timezoneOffset,\n		getTimezoneOffset,\n		getMinutes,\n		getHours,\n		getDay,\n		getDate,\n		getMonth,\n		getFullYear,\n		setMinutes,\n		setHours,\n		setDate,\n		setMonth,\n		setFullYear,\n\n\n		// lookup over the types and the associated classes\n		seriesTypes = {},\n		Highcharts;\n\n	// The Highcharts namespace\n	Highcharts = win.Highcharts = win.Highcharts ? error(16, true) : {};\n\n	Highcharts.seriesTypes = seriesTypes;\n\n	/**\n	 * Extend an object with the members of another\n	 * @param {Object} a The object to be extended\n	 * @param {Object} b The object to add to the first one\n	 */\n	var extend = Highcharts.extend = function (a, b) {\n		var n;\n		if (!a) {\n			a = {};\n		}\n		for (n in b) {\n			a[n] = b[n];\n		}\n		return a;\n	};\n		\n	/**\n	 * Deep merge two or more objects and return a third object. If the first argument is\n	 * true, the contents of the second object is copied into the first object.\n	 * Previously this function redirected to jQuery.extend(true), but this had two limitations.\n	 * First, it deep merged arrays, which lead to workarounds in Highcharts. Second,\n	 * it copied properties from extended prototypes. \n	 */\n	function merge() {\n		var i,\n			args = arguments,\n			len,\n			ret = {},\n			doCopy = function (copy, original) {\n				var value, key;\n\n				// An object is replacing a primitive\n				if (typeof copy !== 'object') {\n					copy = {};\n				}\n\n				for (key in original) {\n					if (original.hasOwnProperty(key)) {\n						value = original[key];\n\n						// Copy the contents of objects, but not arrays or DOM nodes\n						if (value && typeof value === 'object' && Object.prototype.toString.call(value) !== '[object Array]' &&\n								key !== 'renderTo' && typeof value.nodeType !== 'number') {\n							copy[key] = doCopy(copy[key] || {}, value);\n					\n						// Primitives and arrays are copied over directly\n						} else {\n							copy[key] = original[key];\n						}\n					}\n				}\n				return copy;\n			};\n\n		// If first argument is true, copy into the existing object. Used in setOptions.\n		if (args[0] === true) {\n			ret = args[1];\n			args = Array.prototype.slice.call(args, 2);\n		}\n\n		// For each argument, extend the return\n		len = args.length;\n		for (i = 0; i < len; i++) {\n			ret = doCopy(ret, args[i]);\n		}\n\n		return ret;\n	}\n\n	/**\n	 * Shortcut for parseInt\n	 * @param {Object} s\n	 * @param {Number} mag Magnitude\n	 */\n	function pInt(s, mag) {\n		return parseInt(s, mag || 10);\n	}\n\n	/**\n	 * Check for string\n	 * @param {Object} s\n	 */\n	function isString(s) {\n		return typeof s === 'string';\n	}\n\n	/**\n	 * Check for object\n	 * @param {Object} obj\n	 */\n	function isObject(obj) {\n		return obj && typeof obj === 'object';\n	}\n\n	/**\n	 * Check for array\n	 * @param {Object} obj\n	 */\n	function isArray(obj) {\n		return Object.prototype.toString.call(obj) === '[object Array]';\n	}\n\n	/**\n	 * Check for number\n	 * @param {Object} n\n	 */\n	function isNumber(n) {\n		return typeof n === 'number';\n	}\n\n	function log2lin(num) {\n		return math.log(num) / math.LN10;\n	}\n	function lin2log(num) {\n		return math.pow(10, num);\n	}\n\n	/**\n	 * Remove last occurence of an item from an array\n	 * @param {Array} arr\n	 * @param {Mixed} item\n	 */\n	function erase(arr, item) {\n		var i = arr.length;\n		while (i--) {\n			if (arr[i] === item) {\n				arr.splice(i, 1);\n				break;\n			}\n		}\n		//return arr;\n	}\n\n	/**\n	 * Returns true if the object is not null or undefined. Like MooTools' $.defined.\n	 * @param {Object} obj\n	 */\n	function defined(obj) {\n		return obj !== UNDEFINED && obj !== null;\n	}\n\n	/**\n	 * Set or get an attribute or an object of attributes. Can't use jQuery attr because\n	 * it attempts to set expando properties on the SVG element, which is not allowed.\n	 *\n	 * @param {Object} elem The DOM element to receive the attribute(s)\n	 * @param {String|Object} prop The property or an abject of key-value pairs\n	 * @param {String} value The value if a single property is set\n	 */\n	function attr(elem, prop, value) {\n		var key,\n			ret;\n\n		// if the prop is a string\n		if (isString(prop)) {\n			// set the value\n			if (defined(value)) {\n				elem.setAttribute(prop, value);\n\n			// get the value\n			} else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...\n				ret = elem.getAttribute(prop);\n			}\n\n		// else if prop is defined, it is a hash of key/value pairs\n		} else if (defined(prop) && isObject(prop)) {\n			for (key in prop) {\n				elem.setAttribute(key, prop[key]);\n			}\n		}\n		return ret;\n	}\n	/**\n	 * Check if an element is an array, and if not, make it into an array. Like\n	 * MooTools' $.splat.\n	 */\n	function splat(obj) {\n		return isArray(obj) ? obj : [obj];\n	}\n\n\n	/**\n	 * Return the first value that is defined. Like MooTools' $.pick.\n	 */\n	var pick = Highcharts.pick = function () {\n		var args = arguments,\n			i,\n			arg,\n			length = args.length;\n		for (i = 0; i < length; i++) {\n			arg = args[i];\n			if (arg !== UNDEFINED && arg !== null) {\n				return arg;\n			}\n		}\n	};\n\n	/**\n	 * Set CSS on a given element\n	 * @param {Object} el\n	 * @param {Object} styles Style object with camel case property names\n	 */\n	function css(el, styles) {\n		if (isIE && !hasSVG) { // #2686\n			if (styles && styles.opacity !== UNDEFINED) {\n				styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';\n			}\n		}\n		extend(el.style, styles);\n	}\n\n	/**\n	 * Utility function to create element with attributes and styles\n	 * @param {Object} tag\n	 * @param {Object} attribs\n	 * @param {Object} styles\n	 * @param {Object} parent\n	 * @param {Object} nopad\n	 */\n	function createElement(tag, attribs, styles, parent, nopad) {\n		var el = doc.createElement(tag);\n		if (attribs) {\n			extend(el, attribs);\n		}\n		if (nopad) {\n			css(el, {padding: 0, border: NONE, margin: 0});\n		}\n		if (styles) {\n			css(el, styles);\n		}\n		if (parent) {\n			parent.appendChild(el);\n		}\n		return el;\n	}\n\n	/**\n	 * Extend a prototyped class by new members\n	 * @param {Object} parent\n	 * @param {Object} members\n	 */\n	function extendClass(parent, members) {\n		var object = function () { return UNDEFINED; };\n		object.prototype = new parent();\n		extend(object.prototype, members);\n		return object;\n	}\n\n	/**\n	 * Pad a string to a given length by adding 0 to the beginning\n	 * @param {Number} number\n	 * @param {Number} length\n	 */\n	function pad(number, length) {\n		// Create an array of the remaining length +1 and join it with 0's\n		return new Array((length || 2) + 1 - String(number).length).join(0) + number;\n	}\n\n	/**\n	 * Wrap a method with extended functionality, preserving the original function\n	 * @param {Object} obj The context object that the method belongs to \n	 * @param {String} method The name of the method to extend\n	 * @param {Function} func A wrapper function callback. This function is called with the same arguments\n	 * as the original function, except that the original function is unshifted and passed as the first \n	 * argument. \n	 */\n	var wrap = Highcharts.wrap = function (obj, method, func) {\n		var proceed = obj[method];\n		obj[method] = function () {\n			var args = Array.prototype.slice.call(arguments);\n			args.unshift(proceed);\n			return func.apply(this, args);\n		};\n	};\n\n\n	function getTZOffset(timestamp) {\n		return ((getTimezoneOffset && getTimezoneOffset(timestamp)) || timezoneOffset || 0) * 60000;\n	}\n\n	/**\n	 * Based on http://www.php.net/manual/en/function.strftime.php\n	 * @param {String} format\n	 * @param {Number} timestamp\n	 * @param {Boolean} capitalize\n	 */\n	dateFormat = function (format, timestamp, capitalize) {\n		if (!defined(timestamp) || isNaN(timestamp)) {\n			return 'Invalid date';\n		}\n		format = pick(format, '%Y-%m-%d %H:%M:%S');\n\n		var date = new Date(timestamp - getTZOffset(timestamp)),\n			key, // used in for constuct below\n			// get the basic time values\n			hours = date[getHours](),\n			day = date[getDay](),\n			dayOfMonth = date[getDate](),\n			month = date[getMonth](),\n			fullYear = date[getFullYear](),\n			lang = defaultOptions.lang,\n			langWeekdays = lang.weekdays,\n\n			// List all format keys. Custom formats can be added from the outside. \n			replacements = extend({\n\n				// Day\n				'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'\n				'A': langWeekdays[day], // Long weekday, like 'Monday'\n				'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31\n				'e': dayOfMonth, // Day of the month, 1 through 31\n				'w': day,\n\n				// Week (none implemented)\n				//'W': weekNumber(),\n\n				// Month\n				'b': lang.shortMonths[month], // Short month, like 'Jan'\n				'B': lang.months[month], // Long month, like 'January'\n				'm': pad(month + 1), // Two digit month number, 01 through 12\n\n				// Year\n				'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009\n				'Y': fullYear, // Four digits year, like 2009\n\n				// Time\n				'H': pad(hours), // Two digits hours in 24h format, 00 through 23\n				'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11\n				'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12\n				'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59\n				'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM\n				'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM\n				'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59\n				'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)\n			}, Highcharts.dateFormats);\n\n\n		// do the replaces\n		for (key in replacements) {\n			while (format.indexOf('%' + key) !== -1) { // regex would do it in one line, but this is faster\n				format = format.replace('%' + key, typeof replacements[key] === 'function' ? replacements[key](timestamp) : replacements[key]);\n			}\n		}\n\n		// Optionally capitalize the string and return\n		return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;\n	};\n\n	/** \n	 * Format a single variable. Similar to sprintf, without the % prefix.\n	 */\n	function formatSingle(format, val) {\n		var floatRegex = /f$/,\n			decRegex = /\\.([0-9])/,\n			lang = defaultOptions.lang,\n			decimals;\n\n		if (floatRegex.test(format)) { // float\n			decimals = format.match(decRegex);\n			decimals = decimals ? decimals[1] : -1;\n			if (val !== null) {\n				val = Highcharts.numberFormat(\n					val,\n					decimals,\n					lang.decimalPoint,\n					format.indexOf(',') > -1 ? lang.thousandsSep : ''\n				);\n			}\n		} else {\n			val = dateFormat(format, val);\n		}\n		return val;\n	}\n\n	/**\n	 * Format a string according to a subset of the rules of Python's String.format method.\n	 */\n	function format(str, ctx) {\n		var splitter = '{',\n			isInside = false,\n			segment,\n			valueAndFormat,\n			path,\n			i,\n			len,\n			ret = [],\n			val,\n			index;\n		\n		while ((index = str.indexOf(splitter)) !== -1) {\n			\n			segment = str.slice(0, index);\n			if (isInside) { // we're on the closing bracket looking back\n				\n				valueAndFormat = segment.split(':');\n				path = valueAndFormat.shift().split('.'); // get first and leave format\n				len = path.length;\n				val = ctx;\n\n				// Assign deeper paths\n				for (i = 0; i < len; i++) {\n					val = val[path[i]];\n				}\n\n				// Format the replacement\n				if (valueAndFormat.length) {\n					val = formatSingle(valueAndFormat.join(':'), val);\n				}\n\n				// Push the result and advance the cursor\n				ret.push(val);\n				\n			} else {\n				ret.push(segment);\n				\n			}\n			str = str.slice(index + 1); // the rest\n			isInside = !isInside; // toggle\n			splitter = isInside ? '}' : '{'; // now look for next matching bracket\n		}\n		ret.push(str);\n		return ret.join('');\n	}\n\n	/**\n	 * Get the magnitude of a number\n	 */\n	function getMagnitude(num) {\n		return math.pow(10, mathFloor(math.log(num) / math.LN10));\n	}\n\n	/**\n	 * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5\n	 * @param {Number} interval\n	 * @param {Array} multiples\n	 * @param {Number} magnitude\n	 * @param {Object} options\n	 */\n	function normalizeTickInterval(interval, multiples, magnitude, allowDecimals, preventExceed) {\n		var normalized, \n			i,\n			retInterval = interval;\n\n		// round to a tenfold of 1, 2, 2.5 or 5\n		magnitude = pick(magnitude, 1);\n		normalized = interval / magnitude;\n\n		// multiples for a linear scale\n		if (!multiples) {\n			multiples = [1, 2, 2.5, 5, 10];\n\n			// the allowDecimals option\n			if (allowDecimals === false) {\n				if (magnitude === 1) {\n					multiples = [1, 2, 5, 10];\n				} else if (magnitude <= 0.1) {\n					multiples = [1 / magnitude];\n				}\n			}\n		}\n\n		// normalize the interval to the nearest multiple\n		for (i = 0; i < multiples.length; i++) {\n			retInterval = multiples[i];\n			if ((preventExceed && retInterval * magnitude >= interval) || // only allow tick amounts smaller than natural\n				(!preventExceed && (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2))) {\n				break;\n			}\n		}\n\n		// multiply back to the correct magnitude\n		retInterval *= magnitude;\n		\n		return retInterval;\n	}\n\n\n	/**\n	 * Utility method that sorts an object array and keeping the order of equal items.\n	 * ECMA script standard does not specify the behaviour when items are equal.\n	 */\n	function stableSort(arr, sortFunction) {\n		var length = arr.length,\n			sortValue,\n			i;\n\n		// Add index to each item\n		for (i = 0; i < length; i++) {\n			arr[i].ss_i = i; // stable sort index\n		}\n\n		arr.sort(function (a, b) {\n			sortValue = sortFunction(a, b);\n			return sortValue === 0 ? a.ss_i - b.ss_i : sortValue;\n		});\n\n		// Remove index from items\n		for (i = 0; i < length; i++) {\n			delete arr[i].ss_i; // stable sort index\n		}\n	}\n\n	/**\n	 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum\n	 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This\n	 * method is slightly slower, but safe.\n	 */\n	function arrayMin(data) {\n		var i = data.length,\n			min = data[0];\n\n		while (i--) {\n			if (data[i] < min) {\n				min = data[i];\n			}\n		}\n		return min;\n	}\n\n	/**\n	 * Non-recursive method to find the lowest member of an array. Math.min raises a maximum\n	 * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This\n	 * method is slightly slower, but safe.\n	 */\n	function arrayMax(data) {\n		var i = data.length,\n			max = data[0];\n\n		while (i--) {\n			if (data[i] > max) {\n				max = data[i];\n			}\n		}\n		return max;\n	}\n\n	/**\n	 * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.\n	 * It loops all properties and invokes destroy if there is a destroy method. The property is\n	 * then delete'ed.\n	 * @param {Object} The object to destroy properties on\n	 * @param {Object} Exception, do not destroy this property, only delete it.\n	 */\n	function destroyObjectProperties(obj, except) {\n		var n;\n		for (n in obj) {\n			// If the object is non-null and destroy is defined\n			if (obj[n] && obj[n] !== except && obj[n].destroy) {\n				// Invoke the destroy\n				obj[n].destroy();\n			}\n\n			// Delete the property from the object.\n			delete obj[n];\n		}\n	}\n\n\n	/**\n	 * Discard an element by moving it to the bin and delete\n	 * @param {Object} The HTML node to discard\n	 */\n	function discardElement(element) {\n		// create a garbage bin element, not part of the DOM\n		if (!garbageBin) {\n			garbageBin = createElement(DIV);\n		}\n\n		// move the node and empty bin\n		if (element) {\n			garbageBin.appendChild(element);\n		}\n		garbageBin.innerHTML = '';\n	}\n\n	/**\n	 * Provide error messages for debugging, with links to online explanation \n	 */\n	function error (code, stop) {\n		var msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;\n		if (stop) {\n			throw msg;\n		}\n		// else ...\n		if (win.console) {\n			console.log(msg);\n		}\n	}\n\n	/**\n	 * Fix JS round off float errors\n	 * @param {Number} num\n	 */\n	function correctFloat(num) {\n		return parseFloat(\n			num.toPrecision(14)\n		);\n	}\n\n	/**\n	 * Set the global animation to either a given value, or fall back to the\n	 * given chart's animation option\n	 * @param {Object} animation\n	 * @param {Object} chart\n	 */\n	function setAnimation(animation, chart) {\n		globalAnimation = pick(animation, chart.animation);\n	}\n\n	/**\n	 * The time unit lookup\n	 */\n	timeUnits = {\n		millisecond: 1,\n		second: 1000,\n		minute: 60000,\n		hour: 3600000,\n		day: 24 * 3600000,\n		week: 7 * 24 * 3600000,\n		month: 28 * 24 * 3600000,\n		year: 364 * 24 * 3600000\n	};\n\n\n	/**\n	 * Format a number and return a string based on input settings\n	 * @param {Number} number The input number to format\n	 * @param {Number} decimals The amount of decimals\n	 * @param {String} decPoint The decimal point, defaults to the one given in the lang options\n	 * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options\n	 */\n	Highcharts.numberFormat = function (number, decimals, decPoint, thousandsSep) {\n		var lang = defaultOptions.lang,\n			// http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/\n			n = +number || 0,\n			c = decimals === -1 ?\n				mathMin((n.toString().split('.')[1] || '').length, 20) : // Preserve decimals. Not huge numbers (#3793).\n				(isNaN(decimals = mathAbs(decimals)) ? 2 : decimals),\n			d = decPoint === undefined ? lang.decimalPoint : decPoint,\n			t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep,\n			s = n < 0 ? \"-\" : \"\",\n			i = String(pInt(n = mathAbs(n).toFixed(c))),\n			j = i.length > 3 ? i.length % 3 : 0;\n\n		return (s + (j ? i.substr(0, j) + t : \"\") + i.substr(j).replace(/(\\d{3})(?=\\d)/g, \"$1\" + t) +\n				(c ? d + mathAbs(n - i).toFixed(c).slice(2) : \"\"));\n	};\n	/**\n	 * Path interpolation algorithm used across adapters\n	 */\n	pathAnim = {\n		/**\n		 * Prepare start and end values so that the path can be animated one to one\n		 */\n		init: function (elem, fromD, toD) {\n			fromD = fromD || '';\n			var shift = elem.shift,\n				bezier = fromD.indexOf('C') > -1,\n				numParams = bezier ? 7 : 3,\n				endLength,\n				slice,\n				i,\n				start = fromD.split(' '),\n				end = [].concat(toD), // copy\n				startBaseLine,\n				endBaseLine,\n				sixify = function (arr) { // in splines make move points have six parameters like bezier curves\n					i = arr.length;\n					while (i--) {\n						if (arr[i] === M) {\n							arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);\n						}\n					}\n				};\n\n			if (bezier) {\n				sixify(start);\n				sixify(end);\n			}\n\n			// pull out the base lines before padding\n			if (elem.isArea) {\n				startBaseLine = start.splice(start.length - 6, 6);\n				endBaseLine = end.splice(end.length - 6, 6);\n			}\n\n			// if shifting points, prepend a dummy point to the end path\n			if (shift <= end.length / numParams && start.length === end.length) {\n				while (shift--) {\n					end = [].concat(end).splice(0, numParams).concat(end);\n				}\n			}\n			elem.shift = 0; // reset for following animations\n\n			// copy and append last point until the length matches the end length\n			if (start.length) {\n				endLength = end.length;\n				while (start.length < endLength) {\n\n					//bezier && sixify(start);\n					slice = [].concat(start).splice(start.length - numParams, numParams);\n					if (bezier) { // disable first control point\n						slice[numParams - 6] = slice[numParams - 2];\n						slice[numParams - 5] = slice[numParams - 1];\n					}\n					start = start.concat(slice);\n				}\n			}\n\n			if (startBaseLine) { // append the base lines for areas\n				start = start.concat(startBaseLine);\n				end = end.concat(endBaseLine);\n			}\n			return [start, end];\n		},\n\n		/**\n		 * Interpolate each value of the path and return the array\n		 */\n		step: function (start, end, pos, complete) {\n			var ret = [],\n				i = start.length,\n				startVal;\n\n			if (pos === 1) { // land on the final path without adjustment points appended in the ends\n				ret = complete;\n\n			} else if (i === end.length && pos < 1) {\n				while (i--) {\n					startVal = parseFloat(start[i]);\n					ret[i] =\n						isNaN(startVal) ? // a letter instruction like M or L\n							start[i] :\n							pos * (parseFloat(end[i] - startVal)) + startVal;\n\n				}\n			} else { // if animation is finished or length not matching, land on right value\n				ret = end;\n			}\n			return ret;\n		}\n	};\n\n	(function ($) {\n		/**\n		 * The default HighchartsAdapter for jQuery\n		 */\n		win.HighchartsAdapter = win.HighchartsAdapter || ($ && {\n			\n			/**\n			 * Initialize the adapter by applying some extensions to jQuery\n			 */\n			init: function (pathAnim) {\n				\n				// extend the animate function to allow SVG animations\n				var Fx = $.fx;\n				\n				/*jslint unparam: true*//* allow unused param x in this function */\n				$.extend($.easing, {\n					easeOutQuad: function (x, t, b, c, d) {\n						return -c * (t /= d) * (t - 2) + b;\n					}\n				});\n				/*jslint unparam: false*/\n			\n				// extend some methods to check for elem.attr, which means it is a Highcharts SVG object\n				$.each(['cur', '_default', 'width', 'height', 'opacity'], function (i, fn) {\n					var obj = Fx.step,\n						base;\n						\n					// Handle different parent objects\n					if (fn === 'cur') {\n						obj = Fx.prototype; // 'cur', the getter, relates to Fx.prototype\n					\n					} else if (fn === '_default' && $.Tween) { // jQuery 1.8 model\n						obj = $.Tween.propHooks[fn];\n						fn = 'set';\n					}\n			\n					// Overwrite the method\n					base = obj[fn];\n					if (base) { // step.width and step.height don't exist in jQuery < 1.7\n			\n						// create the extended function replacement\n						obj[fn] = function (fx) {\n\n							var elem;\n							\n							// Fx.prototype.cur does not use fx argument\n							fx = i ? fx : this;\n\n							// Don't run animations on textual properties like align (#1821)\n							if (fx.prop === 'align') {\n								return;\n							}\n			\n							// shortcut\n							elem = fx.elem;\n			\n							// Fx.prototype.cur returns the current value. The other ones are setters\n							// and returning a value has no effect.\n							return elem.attr ? // is SVG element wrapper\n								elem.attr(fx.prop, fn === 'cur' ? UNDEFINED : fx.now) : // apply the SVG wrapper's method\n								base.apply(this, arguments); // use jQuery's built-in method\n						};\n					}\n				});\n\n				// Extend the opacity getter, needed for fading opacity with IE9 and jQuery 1.10+\n				wrap($.cssHooks.opacity, 'get', function (proceed, elem, computed) {\n					return elem.attr ? (elem.opacity || 0) : proceed.call(this, elem, computed);\n				});\n				\n				// Define the setter function for d (path definitions)\n				this.addAnimSetter('d', function (fx) {\n					var elem = fx.elem,\n						ends;\n			\n					// Normally start and end should be set in state == 0, but sometimes,\n					// for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped\n					// in these cases\n					if (!fx.started) {\n						ends = pathAnim.init(elem, elem.d, elem.toD);\n						fx.start = ends[0];\n						fx.end = ends[1];\n						fx.started = true;\n					}\n			\n					// Interpolate each value of the path\n					elem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));\n				});\n				\n				/**\n				 * Utility for iterating over an array. Parameters are reversed compared to jQuery.\n				 * @param {Array} arr\n				 * @param {Function} fn\n				 */\n				this.each = Array.prototype.forEach ?\n					function (arr, fn) { // modern browsers\n						return Array.prototype.forEach.call(arr, fn);\n						\n					} : \n					function (arr, fn) { // legacy\n						var i, \n							len = arr.length;\n						for (i = 0; i < len; i++) {\n							if (fn.call(arr[i], arr[i], i, arr) === false) {\n								return i;\n							}\n						}\n					};\n				\n				/**\n				 * Register Highcharts as a plugin in the respective framework\n				 */\n				$.fn.highcharts = function () {\n					var constr = 'Chart', // default constructor\n						args = arguments,\n						options,\n						ret,\n						chart;\n\n					if (this[0]) {\n\n						if (isString(args[0])) {\n							constr = args[0];\n							args = Array.prototype.slice.call(args, 1); \n						}\n						options = args[0];\n\n						// Create the chart\n						if (options !== UNDEFINED) {\n							/*jslint unused:false*/\n							options.chart = options.chart || {};\n							options.chart.renderTo = this[0];\n							chart = new Highcharts[constr](options, args[1]);\n							ret = this;\n							/*jslint unused:true*/\n						}\n\n						// When called without parameters or with the return argument, get a predefined chart\n						if (options === UNDEFINED) {\n							ret = charts[attr(this[0], 'data-highcharts-chart')];\n						}\n					}\n					\n					return ret;\n				};\n\n			},\n\n			/**\n			 * Add an animation setter for a specific property\n			 */\n			addAnimSetter: function (prop, setter) {\n				// jQuery 1.8 style\n				if ($.Tween) {\n					$.Tween.propHooks[prop] = {\n						set: setter\n					};\n				// pre 1.8\n				} else {\n					$.fx.step[prop] = setter;\n				}\n			},\n			\n			/**\n			 * Downloads a script and executes a callback when done.\n			 * @param {String} scriptLocation\n			 * @param {Function} callback\n			 */\n			getScript: $.getScript,\n			\n			/**\n			 * Return the index of an item in an array, or -1 if not found\n			 */\n			inArray: $.inArray,\n			\n			/**\n			 * A direct link to jQuery methods. MooTools and Prototype adapters must be implemented for each case of method.\n			 * @param {Object} elem The HTML element\n			 * @param {String} method Which method to run on the wrapped element\n			 */\n			adapterRun: function (elem, method) {\n				return $(elem)[method]();\n			},\n		\n			/**\n			 * Filter an array\n			 */\n			grep: $.grep,\n		\n			/**\n			 * Map an array\n			 * @param {Array} arr\n			 * @param {Function} fn\n			 */\n			map: function (arr, fn) {\n				//return jQuery.map(arr, fn);\n				var results = [],\n					i = 0,\n					len = arr.length;\n				for (; i < len; i++) {\n					results[i] = fn.call(arr[i], arr[i], i, arr);\n				}\n				return results;\n		\n			},\n		\n			/**\n			 * Get the position of an element relative to the top left of the page\n			 */\n			offset: function (el) {\n				return $(el).offset();\n			},\n		\n			/**\n			 * Add an event listener\n			 * @param {Object} el A HTML element or custom object\n			 * @param {String} event The event type\n			 * @param {Function} fn The event handler\n			 */\n			addEvent: function (el, event, fn) {\n				$(el).bind(event, fn);\n			},\n		\n			/**\n			 * Remove event added with addEvent\n			 * @param {Object} el The object\n			 * @param {String} eventType The event type. Leave blank to remove all events.\n			 * @param {Function} handler The function to remove\n			 */\n			removeEvent: function (el, eventType, handler) {\n				// workaround for jQuery issue with unbinding custom events:\n				// http://forum.jQuery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jQuery-1-4-2\n				var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';\n				if (doc[func] && el && !el[func]) {\n					el[func] = function () {};\n				}\n		\n				$(el).unbind(eventType, handler);\n			},\n		\n			/**\n			 * Fire an event on a custom object\n			 * @param {Object} el\n			 * @param {String} type\n			 * @param {Object} eventArguments\n			 * @param {Function} defaultFunction\n			 */\n			fireEvent: function (el, type, eventArguments, defaultFunction) {\n				var event = $.Event(type),\n					detachedType = 'detached' + type,\n					defaultPrevented;\n		\n				// Remove warnings in Chrome when accessing returnValue (#2790), layerX and layerY. Although Highcharts\n				// never uses these properties, Chrome includes them in the default click event and\n				// raises the warning when they are copied over in the extend statement below.\n				//\n				// To avoid problems in IE (see #1010) where we cannot delete the properties and avoid\n				// testing if they are there (warning in chrome) the only option is to test if running IE.\n				if (!isIE && eventArguments) {\n					delete eventArguments.layerX;\n					delete eventArguments.layerY;\n					delete eventArguments.returnValue;\n				}\n		\n				extend(event, eventArguments);\n		\n				// Prevent jQuery from triggering the object method that is named the\n				// same as the event. For example, if the event is 'select', jQuery\n				// attempts calling el.select and it goes into a loop.\n				if (el[type]) {\n					el[detachedType] = el[type];\n					el[type] = null;\n				}\n		\n				// Wrap preventDefault and stopPropagation in try/catch blocks in\n				// order to prevent JS errors when cancelling events on non-DOM\n				// objects. #615.\n				/*jslint unparam: true*/\n				$.each(['preventDefault', 'stopPropagation'], function (i, fn) {\n					var base = event[fn];\n					event[fn] = function () {\n						try {\n							base.call(event);\n						} catch (e) {\n							if (fn === 'preventDefault') {\n								defaultPrevented = true;\n							}\n						}\n					};\n				});\n				/*jslint unparam: false*/\n		\n				// trigger it\n				$(el).trigger(event);\n		\n				// attach the method\n				if (el[detachedType]) {\n					el[type] = el[detachedType];\n					el[detachedType] = null;\n				}\n		\n				if (defaultFunction && !event.isDefaultPrevented() && !defaultPrevented) {\n					defaultFunction(event);\n				}\n			},\n			\n			/**\n			 * Extension method needed for MooTools\n			 */\n			washMouseEvent: function (e) {\n				var ret = e.originalEvent || e;\n				\n				// computed by jQuery, needed by IE8\n				if (ret.pageX === UNDEFINED) { // #1236\n					ret.pageX = e.pageX;\n					ret.pageY = e.pageY;\n				}\n				\n				return ret;\n			},\n		\n			/**\n			 * Animate a HTML element or SVG element wrapper\n			 * @param {Object} el\n			 * @param {Object} params\n			 * @param {Object} options jQuery-like animation options: duration, easing, callback\n			 */\n			animate: function (el, params, options) {\n				var $el = $(el);\n				if (!el.style) {\n					el.style = {}; // #1881\n				}\n				if (params.d) {\n					el.toD = params.d; // keep the array form for paths, used in $.fx.step.d\n					params.d = 1; // because in jQuery, animating to an array has a different meaning\n				}\n		\n				$el.stop();\n				if (params.opacity !== UNDEFINED && el.attr) {\n					params.opacity += 'px'; // force jQuery to use same logic as width and height (#2161)\n				}\n				el.hasAnim = 1; // #3342\n				$el.animate(params, options);\n		\n			},\n			/**\n			 * Stop running animation\n			 */\n			stop: function (el) {\n				if (el.hasAnim) { // #3342, memory leak on calling $(el) from destroy\n					$(el).stop();\n				}\n			}\n		});\n	}(win.jQuery));\n\n\n	// check for a custom HighchartsAdapter defined prior to this file\n	var globalAdapter = win.HighchartsAdapter,\n		adapter = globalAdapter || {};\n		\n	// Initialize the adapter\n	if (globalAdapter) {\n		globalAdapter.init.call(globalAdapter, pathAnim);\n	}\n\n\n	// Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object\n	// and all the utility functions will be null. In that case they are populated by the\n	// default adapters below.\n	var adapterRun = adapter.adapterRun,\n		getScript = adapter.getScript,\n		inArray = adapter.inArray,\n		each = Highcharts.each = adapter.each,\n		grep = adapter.grep,\n		offset = adapter.offset,\n		map = adapter.map,\n		addEvent = adapter.addEvent,\n		removeEvent = adapter.removeEvent,\n		fireEvent = adapter.fireEvent,\n		washMouseEvent = adapter.washMouseEvent,\n		animate = adapter.animate,\n		stop = adapter.stop;\n\n\n\n	/* ****************************************************************************\n	 * Handle the options                                                         *\n	 *****************************************************************************/\n	defaultOptions = {\n		colors: ['#7cb5ec', '#434348', '#90ed7d', '#f7a35c', \n			    '#8085e9', '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],\n		symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],\n		lang: {\n			loading: 'Loading...',\n			months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',\n					'August', 'September', 'October', 'November', 'December'],\n			shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n			weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n			decimalPoint: '.',\n			numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels\n			resetZoom: 'Reset zoom',\n			resetZoomTitle: 'Reset zoom level 1:1',\n			thousandsSep: ' '\n		},\n		global: {\n			useUTC: true,\n			//timezoneOffset: 0,\n			canvasToolsURL: 'http://code.highcharts.com/4.1.4-modified/modules/canvas-tools.js',\n			VMLRadialGradientURL: 'http://code.highcharts.com/4.1.4-modified/gfx/vml-radial-gradient.png'\n		},\n		chart: {\n			//animation: true,\n			//alignTicks: false,\n			//reflow: true,\n			//className: null,\n			//events: { load, selection },\n			//margin: [null],\n			//marginTop: null,\n			//marginRight: null,\n			//marginBottom: null,\n			//marginLeft: null,\n			borderColor: '#4572A7',\n			//borderWidth: 0,\n			borderRadius: 0,\n			defaultSeriesType: 'line',\n			ignoreHiddenSeries: true,\n			//inverted: false,\n			//shadow: false,\n			spacing: [10, 10, 15, 10],\n			//spacingTop: 10,\n			//spacingRight: 10,\n			//spacingBottom: 15,\n			//spacingLeft: 10,\n			//style: {\n			//	fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif', // default font\n			//	fontSize: '12px'\n			//},\n			backgroundColor: '#FFFFFF',\n			//plotBackgroundColor: null,\n			plotBorderColor: '#C0C0C0',\n			//plotBorderWidth: 0,\n			//plotShadow: false,\n			//zoomType: ''\n			resetZoomButton: {\n				theme: {\n					zIndex: 20\n				},\n				position: {\n					align: 'right',\n					x: -10,\n					//verticalAlign: 'top',\n					y: 10\n				}\n				// relativeTo: 'plot'\n			}\n		},\n		title: {\n			text: 'Chart title',\n			align: 'center',\n			// floating: false,\n			margin: 15,\n			// x: 0,\n			// verticalAlign: 'top',\n			// y: null,\n			style: {\n				color: '#333333',\n				fontSize: '18px'\n			}\n\n		},\n		subtitle: {\n			text: '',\n			align: 'center',\n			// floating: false\n			// x: 0,\n			// verticalAlign: 'top',\n			// y: null,\n			style: {\n				color: '#555555'\n			}\n		},\n\n		plotOptions: {\n			line: { // base series options\n				allowPointSelect: false,\n				showCheckbox: false,\n				animation: {\n					duration: 1000\n				},\n				//connectNulls: false,\n				//cursor: 'default',\n				//clip: true,\n				//dashStyle: null,\n				//enableMouseTracking: true,\n				events: {},\n				//legendIndex: 0,\n				//linecap: 'round',\n				lineWidth: 2,\n				//shadow: false,\n				// stacking: null,\n				marker: {\n					//enabled: true,\n					//symbol: null,\n					lineWidth: 0,\n					radius: 4,\n					lineColor: '#FFFFFF',\n					//fillColor: null,\n					states: { // states for a single point\n						hover: {\n							enabled: true,\n							lineWidthPlus: 1,\n							radiusPlus: 2\n						},\n						select: {\n							fillColor: '#FFFFFF',\n							lineColor: '#000000',\n							lineWidth: 2\n						}\n					}\n				},\n				point: {\n					events: {}\n				},\n				dataLabels: {\n					align: 'center',\n					// defer: true,\n					// enabled: false,\n					formatter: function () {\n						return this.y === null ? '' : Highcharts.numberFormat(this.y, -1);\n					},\n					style: {\n						color: 'contrast',\n						fontSize: '11px',\n						fontWeight: 'bold',\n						textShadow: '0 0 6px contrast, 0 0 3px contrast'\n					},\n					verticalAlign: 'bottom', // above singular point\n					x: 0,\n					y: 0,\n					// backgroundColor: undefined,\n					// borderColor: undefined,\n					// borderRadius: undefined,\n					// borderWidth: undefined,\n					padding: 5\n					// shadow: false\n				},\n				cropThreshold: 300, // draw points outside the plot area when the number of points is less than this\n				pointRange: 0,\n				//pointStart: 0,\n				//pointInterval: 1,\n				//showInLegend: null, // auto: true for standalone series, false for linked series\n				states: { // states for the entire series\n					hover: {\n						//enabled: false,\n						lineWidthPlus: 1,\n						marker: {\n							// lineWidth: base + 1,\n							// radius: base + 1\n						},\n						halo: {\n							size: 10,\n							opacity: 0.25\n						}\n					},\n					select: {\n						marker: {}\n					}\n				},\n				stickyTracking: true,\n				//tooltip: {\n					//pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.y}</b>'\n					//valueDecimals: null,\n					//xDateFormat: '%A, %b %e, %Y',\n					//valuePrefix: '',\n					//ySuffix: ''				\n				//}\n				turboThreshold: 1000\n				// zIndex: null\n			}\n		},\n		labels: {\n			//items: [],\n			style: {\n				//font: defaultFont,\n				position: ABSOLUTE,\n				color: '#3E576F'\n			}\n		},\n		legend: {\n			enabled: true,\n			align: 'center',\n			//floating: false,\n			layout: 'horizontal',\n			labelFormatter: function () {\n				return this.name;\n			},\n			//borderWidth: 0,\n			borderColor: '#909090',\n			borderRadius: 0,\n			navigation: {\n				// animation: true,\n				activeColor: '#274b6d',\n				// arrowSize: 12\n				inactiveColor: '#CCC'\n				// style: {} // text styles\n			},\n			// margin: 20,\n			// reversed: false,\n			shadow: false,\n			// backgroundColor: null,\n			/*style: {\n				padding: '5px'\n			},*/\n			itemStyle: {			\n				color: '#333333',\n				fontSize: '12px',\n				fontWeight: 'bold'\n			},\n			itemHoverStyle: {\n				//cursor: 'pointer', removed as of #601\n				color: '#000'\n			},\n			itemHiddenStyle: {\n				color: '#CCC'\n			},\n			itemCheckboxStyle: {\n				position: ABSOLUTE,\n				width: '13px', // for IE precision\n				height: '13px'\n			},\n			// itemWidth: undefined,\n			// symbolRadius: 0,\n			// symbolWidth: 16,\n			symbolPadding: 5,\n			verticalAlign: 'bottom',\n			// width: undefined,\n			x: 0,\n			y: 0,\n			title: {\n				//text: null,\n				style: {\n					fontWeight: 'bold'\n				}\n			}			\n		},\n\n		loading: {\n			// hideDuration: 100,\n			labelStyle: {\n				fontWeight: 'bold',\n				position: RELATIVE,\n				top: '45%'\n			},\n			// showDuration: 0,\n			style: {\n				position: ABSOLUTE,\n				backgroundColor: 'white',\n				opacity: 0.5,\n				textAlign: 'center'\n			}\n		},\n\n		tooltip: {\n			enabled: true,\n			animation: hasSVG,\n			//crosshairs: null,\n			backgroundColor: 'rgba(249, 249, 249, .85)',\n			borderWidth: 1,\n			borderRadius: 3,\n			dateTimeLabelFormats: { \n				millisecond: '%A, %b %e, %H:%M:%S.%L',\n				second: '%A, %b %e, %H:%M:%S',\n				minute: '%A, %b %e, %H:%M',\n				hour: '%A, %b %e, %H:%M',\n				day: '%A, %b %e, %Y',\n				week: 'Week from %A, %b %e, %Y',\n				month: '%B %Y',\n				year: '%Y'\n			},\n			footerFormat: '',\n			//formatter: defaultFormatter,\n			headerFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n			pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.y}</b><br/>',\n			shadow: true,\n			//shape: 'callout',\n			//shared: false,\n			snap: isTouchDevice ? 25 : 10,\n			style: {\n				color: '#333333',\n				cursor: 'default',\n				fontSize: '12px',\n				padding: '8px',\n				whiteSpace: 'nowrap'\n			}\n			//xDateFormat: '%A, %b %e, %Y',\n			//valueDecimals: null,\n			//valuePrefix: '',\n			//valueSuffix: ''\n		},\n\n		credits: {\n			enabled: true,\n			text: 'Highcharts.com',\n			href: 'http://www.highcharts.com',\n			position: {\n				align: 'right',\n				x: -10,\n				verticalAlign: 'bottom',\n				y: -5\n			},\n			style: {\n				cursor: 'pointer',\n				color: '#909090',\n				fontSize: '9px'\n			}\n		}\n	};\n\n\n\n\n	// Series defaults\n	var defaultPlotOptions = defaultOptions.plotOptions,\n		defaultSeriesOptions = defaultPlotOptions.line;\n\n	// set the default time methods\n	setTimeMethods();\n\n\n\n	/**\n	 * Set the time methods globally based on the useUTC option. Time method can be either\n	 * local time or UTC (default).\n	 */\n	function setTimeMethods() {\n		var globalOptions = defaultOptions.global,\n			useUTC = globalOptions.useUTC,\n			GET = useUTC ? 'getUTC' : 'get',\n			SET = useUTC ? 'setUTC' : 'set';\n\n\n		Date = globalOptions.Date || window.Date;\n		timezoneOffset = useUTC && globalOptions.timezoneOffset;\n		getTimezoneOffset = useUTC && globalOptions.getTimezoneOffset;\n		makeTime = function (year, month, date, hours, minutes, seconds) {\n			var d;\n			if (useUTC) {\n				d = Date.UTC.apply(0, arguments);\n				d += getTZOffset(d);\n			} else {\n				d = new Date(\n					year,\n					month,\n					pick(date, 1),\n					pick(hours, 0),\n					pick(minutes, 0),\n					pick(seconds, 0)\n				).getTime();\n			}\n			return d;\n		};\n		getMinutes =  GET + 'Minutes';\n		getHours =    GET + 'Hours';\n		getDay =      GET + 'Day';\n		getDate =     GET + 'Date';\n		getMonth =    GET + 'Month';\n		getFullYear = GET + 'FullYear';\n		setMinutes =  SET + 'Minutes';\n		setHours =    SET + 'Hours';\n		setDate =     SET + 'Date';\n		setMonth =    SET + 'Month';\n		setFullYear = SET + 'FullYear';\n\n	}\n\n	/**\n	 * Merge the default options with custom options and return the new options structure\n	 * @param {Object} options The new custom options\n	 */\n	function setOptions(options) {\n		\n		// Copy in the default options\n		defaultOptions = merge(true, defaultOptions, options);\n		\n		// Apply UTC\n		setTimeMethods();\n\n		return defaultOptions;\n	}\n\n	/**\n	 * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules\n	 * wasn't enough because the setOptions method created a new object.\n	 */\n	function getOptions() {\n		return defaultOptions;\n	}\n\n\n	/**\n	 * Handle color operations. The object methods are chainable.\n	 * @param {String} input The input color in either rbga or hex format\n	 */\n	var rgbaRegEx = /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n		hexRegEx = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,\n		rgbRegEx = /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/;\n\n	var Color = function (input) {\n		// declare variables\n		var rgba = [], result, stops;\n\n		/**\n		 * Parse the input color to rgba array\n		 * @param {String} input\n		 */\n		function init(input) {\n\n			// Gradients\n			if (input && input.stops) {\n				stops = map(input.stops, function (stop) {\n					return Color(stop[1]);\n				});\n\n			// Solid colors\n			} else {\n				// rgba\n				result = rgbaRegEx.exec(input);\n				if (result) {\n					rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];\n				} else { \n					// hex\n					result = hexRegEx.exec(input);\n					if (result) {\n						rgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];\n					} else {\n						// rgb\n						result = rgbRegEx.exec(input);\n						if (result) {\n							rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];\n						}\n					}\n				}\n			}		\n\n		}\n		/**\n		 * Return the color a specified format\n		 * @param {String} format\n		 */\n		function get(format) {\n			var ret;\n\n			if (stops) {\n				ret = merge(input);\n				ret.stops = [].concat(ret.stops);\n				each(stops, function (stop, i) {\n					ret.stops[i] = [ret.stops[i][0], stop.get(format)];\n				});\n\n			// it's NaN if gradient colors on a column chart\n			} else if (rgba && !isNaN(rgba[0])) {\n				if (format === 'rgb') {\n					ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';\n				} else if (format === 'a') {\n					ret = rgba[3];\n				} else {\n					ret = 'rgba(' + rgba.join(',') + ')';\n				}\n			} else {\n				ret = input;\n			}\n			return ret;\n		}\n\n		/**\n		 * Brighten the color\n		 * @param {Number} alpha\n		 */\n		function brighten(alpha) {\n			if (stops) {\n				each(stops, function (stop) {\n					stop.brighten(alpha);\n				});\n			\n			} else if (isNumber(alpha) && alpha !== 0) {\n				var i;\n				for (i = 0; i < 3; i++) {\n					rgba[i] += pInt(alpha * 255);\n\n					if (rgba[i] < 0) {\n						rgba[i] = 0;\n					}\n					if (rgba[i] > 255) {\n						rgba[i] = 255;\n					}\n				}\n			}\n			return this;\n		}\n		/**\n		 * Set the color's opacity to a given alpha value\n		 * @param {Number} alpha\n		 */\n		function setOpacity(alpha) {\n			rgba[3] = alpha;\n			return this;\n		}\n\n		// initialize: parse the input\n		init(input);\n\n		// public methods\n		return {\n			get: get,\n			brighten: brighten,\n			rgba: rgba,\n			setOpacity: setOpacity,\n			raw: input\n		};\n	};\n\n\n	/**\n	 * A wrapper object for SVG elements\n	 */\n	function SVGElement() {}\n\n	SVGElement.prototype = {\n		\n		// Default base for animation\n		opacity: 1,\n		// For labels, these CSS properties are applied to the <text> node directly\n		textProps: ['fontSize', 'fontWeight', 'fontFamily', 'color', \n			'lineHeight', 'width', 'textDecoration', 'textShadow'],\n		\n		/**\n		 * Initialize the SVG renderer\n		 * @param {Object} renderer\n		 * @param {String} nodeName\n		 */\n		init: function (renderer, nodeName) {\n			var wrapper = this;\n			wrapper.element = nodeName === 'span' ?\n				createElement(nodeName) :\n				doc.createElementNS(SVG_NS, nodeName);\n			wrapper.renderer = renderer;\n		},\n		\n		/**\n		 * Animate a given attribute\n		 * @param {Object} params\n		 * @param {Number} options The same options as in jQuery animation\n		 * @param {Function} complete Function to perform at the end of animation\n		 */\n		animate: function (params, options, complete) {\n			var animOptions = pick(options, globalAnimation, true);\n			stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)\n			if (animOptions) {\n				animOptions = merge(animOptions, {}); //#2625\n				if (complete) { // allows using a callback with the global animation without overwriting it\n					animOptions.complete = complete;\n				}\n				animate(this, params, animOptions);\n			} else {\n				this.attr(params);\n				if (complete) {\n					complete();\n				}\n			}\n			return this;\n		},\n\n		/**\n		 * Build an SVG gradient out of a common JavaScript configuration object\n		 */\n		colorGradient: function (color, prop, elem) {\n			var renderer = this.renderer,\n				colorObject,\n				gradName,\n				gradAttr,\n				gradients,\n				gradientObject,\n				stops,\n				stopColor,\n				stopOpacity,\n				radialReference,\n				n,\n				id,\n				key = [];\n\n			// Apply linear or radial gradients\n			if (color.linearGradient) {\n				gradName = 'linearGradient';\n			} else if (color.radialGradient) {\n				gradName = 'radialGradient';\n			}\n\n			if (gradName) {\n				gradAttr = color[gradName];\n				gradients = renderer.gradients;\n				stops = color.stops;\n				radialReference = elem.radialReference;\n\n				// Keep < 2.2 kompatibility\n				if (isArray(gradAttr)) {\n					color[gradName] = gradAttr = {\n						x1: gradAttr[0],\n						y1: gradAttr[1],\n						x2: gradAttr[2],\n						y2: gradAttr[3],\n						gradientUnits: 'userSpaceOnUse'\n					};\n				}\n\n				// Correct the radial gradient for the radial reference system\n				if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {\n					gradAttr = merge(gradAttr, {\n						cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],\n						cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],\n						r: gradAttr.r * radialReference[2],\n						gradientUnits: 'userSpaceOnUse'\n					});\n				}\n\n				// Build the unique key to detect whether we need to create a new element (#1282)\n				for (n in gradAttr) {\n					if (n !== 'id') {\n						key.push(n, gradAttr[n]);\n					}\n				}\n				for (n in stops) {\n					key.push(stops[n]);\n				}\n				key = key.join(',');\n\n				// Check if a gradient object with the same config object is created within this renderer\n				if (gradients[key]) {\n					id = gradients[key].attr('id');\n\n				} else {\n\n					// Set the id and create the element\n					gradAttr.id = id = PREFIX + idCounter++;\n					gradients[key] = gradientObject = renderer.createElement(gradName)\n						.attr(gradAttr)\n						.add(renderer.defs);\n\n\n					// The gradient needs to keep a list of stops to be able to destroy them\n					gradientObject.stops = [];\n					each(stops, function (stop) {\n						var stopObject;\n						if (stop[1].indexOf('rgba') === 0) {\n							colorObject = Color(stop[1]);\n							stopColor = colorObject.get('rgb');\n							stopOpacity = colorObject.get('a');\n						} else {\n							stopColor = stop[1];\n							stopOpacity = 1;\n						}\n						stopObject = renderer.createElement('stop').attr({\n							offset: stop[0],\n							'stop-color': stopColor,\n							'stop-opacity': stopOpacity\n						}).add(gradientObject);\n\n						// Add the stop element to the gradient\n						gradientObject.stops.push(stopObject);\n					});\n				}\n\n				// Set the reference to the gradient object\n				elem.setAttribute(prop, 'url(' + renderer.url + '#' + id + ')');\n			} \n		},\n\n		/**\n		 * Apply a polyfill to the text-stroke CSS property, by copying the text element\n		 * and apply strokes to the copy.\n		 *\n		 * docs: update default, document the polyfill and the limitations on hex colors and pixel values, document contrast pseudo-color\n		 * TODO: \n		 * - update defaults\n		 */\n		applyTextShadow: function (textShadow) {\n			var elem = this.element,\n				tspans,\n				hasContrast = textShadow.indexOf('contrast') !== -1,\n				// IE10 and IE11 report textShadow in elem.style even though it doesn't work. Check\n				// this again with new IE release. In exports, the rendering is passed to PhantomJS. \n				supports = this.renderer.forExport || (elem.style.textShadow !== UNDEFINED && !isIE);\n\n			// When the text shadow is set to contrast, use dark stroke for light text and vice versa\n			if (hasContrast) {\n				textShadow = textShadow.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));\n			}\n\n			/* Selective side-by-side testing in supported browser (http://jsfiddle.net/highcharts/73L1ptrh/)\n			if (elem.textContent.indexOf('2.') === 0) {\n				elem.style['text-shadow'] = 'none';\n				supports = false;\n			}\n			// */\n\n			// No reason to polyfill, we've got native support\n			if (supports) {\n				if (hasContrast) { // Apply the altered style\n					css(elem, {\n						textShadow: textShadow\n					});\n				}\n			} else {\n\n				this.fakeTS = true; // Fake text shadow\n\n				// In order to get the right y position of the clones, \n				// copy over the y setter\n				this.ySetter = this.xSetter;\n\n				tspans = [].slice.call(elem.getElementsByTagName('tspan'));\n				each(textShadow.split(/\\s?,\\s?/g), function (textShadow) {\n					var firstChild = elem.firstChild,\n						color,\n						strokeWidth;\n					\n					textShadow = textShadow.split(' ');\n					color = textShadow[textShadow.length - 1];\n\n					// Approximately tune the settings to the text-shadow behaviour\n					strokeWidth = textShadow[textShadow.length - 2];\n\n					if (strokeWidth) {\n						each(tspans, function (tspan, y) {\n							var clone;\n\n							// Let the first line start at the correct X position\n							if (y === 0) {\n								tspan.setAttribute('x', elem.getAttribute('x'));\n								y = elem.getAttribute('y');\n								tspan.setAttribute('y', y || 0);\n								if (y === null) {\n									elem.setAttribute('y', 0);\n								}\n							}\n\n							// Create the clone and apply shadow properties\n							clone = tspan.cloneNode(1);\n							attr(clone, {\n								'class': PREFIX + 'text-shadow',\n								'fill': color,\n								'stroke': color,\n								'stroke-opacity': 1 / mathMax(pInt(strokeWidth), 3),\n								'stroke-width': strokeWidth,\n								'stroke-linejoin': 'round'\n							});\n							elem.insertBefore(clone, firstChild);\n						});\n					}\n				});\n			}\n		},\n\n		/**\n		 * Set or get a given attribute\n		 * @param {Object|String} hash\n		 * @param {Mixed|Undefined} val\n		 */\n		attr: function (hash, val) {\n			var key,\n				value,\n				element = this.element,\n				hasSetSymbolSize,\n				ret = this,\n				skipAttr;\n\n			// single key-value pair\n			if (typeof hash === 'string' && val !== UNDEFINED) {\n				key = hash;\n				hash = {};\n				hash[key] = val;\n			}\n\n			// used as a getter: first argument is a string, second is undefined\n			if (typeof hash === 'string') {\n				ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);\n			\n			// setter\n			} else {\n\n				for (key in hash) {\n					value = hash[key];\n					skipAttr = false;\n\n\n\n					if (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {\n						if (!hasSetSymbolSize) {\n							this.symbolAttr(hash);\n							hasSetSymbolSize = true;\n						}\n						skipAttr = true;\n					}\n\n					if (this.rotation && (key === 'x' || key === 'y')) {\n						this.doTransform = true;\n					}\n					\n					if (!skipAttr) {\n						(this[key + 'Setter'] || this._defaultSetter).call(this, value, key, element);\n					}\n\n					// Let the shadow follow the main element\n					if (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {\n						this.updateShadows(key, value);\n					}\n				}\n\n				// Update transform. Do this outside the loop to prevent redundant updating for batch setting\n				// of attributes.\n				if (this.doTransform) {\n					this.updateTransform();\n					this.doTransform = false;\n				}\n\n			}\n\n			return ret;\n		},\n\n		updateShadows: function (key, value) {\n			var shadows = this.shadows,\n				i = shadows.length;\n			while (i--) {\n				shadows[i].setAttribute(\n					key,\n					key === 'height' ?\n						mathMax(value - (shadows[i].cutHeight || 0), 0) :\n						key === 'd' ? this.d : value\n				);\n			}\n		},\n\n		/**\n		 * Add a class name to an element\n		 */\n		addClass: function (className) {\n			var element = this.element,\n				currentClassName = attr(element, 'class') || '';\n\n			if (currentClassName.indexOf(className) === -1) {\n				attr(element, 'class', currentClassName + ' ' + className);\n			}\n			return this;\n		},\n		/* hasClass and removeClass are not (yet) needed\n		hasClass: function (className) {\n			return attr(this.element, 'class').indexOf(className) !== -1;\n		},\n		removeClass: function (className) {\n			attr(this.element, 'class', attr(this.element, 'class').replace(className, ''));\n			return this;\n		},\n		*/\n\n		/**\n		 * If one of the symbol size affecting parameters are changed,\n		 * check all the others only once for each call to an element's\n		 * .attr() method\n		 * @param {Object} hash\n		 */\n		symbolAttr: function (hash) {\n			var wrapper = this;\n\n			each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {\n				wrapper[key] = pick(hash[key], wrapper[key]);\n			});\n\n			wrapper.attr({\n				d: wrapper.renderer.symbols[wrapper.symbolName](\n					wrapper.x,\n					wrapper.y,\n					wrapper.width,\n					wrapper.height,\n					wrapper\n				)\n			});\n		},\n\n		/**\n		 * Apply a clipping path to this object\n		 * @param {String} id\n		 */\n		clip: function (clipRect) {\n			return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : NONE);\n		},\n\n		/**\n		 * Calculate the coordinates needed for drawing a rectangle crisply and return the\n		 * calculated attributes\n		 * @param {Number} strokeWidth\n		 * @param {Number} x\n		 * @param {Number} y\n		 * @param {Number} width\n		 * @param {Number} height\n		 */\n		crisp: function (rect) {\n\n			var wrapper = this,\n				key,\n				attribs = {},\n				normalizer,\n				strokeWidth = rect.strokeWidth || wrapper.strokeWidth || 0;\n\n			normalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors\n\n			// normalize for crisp edges\n			rect.x = mathFloor(rect.x || wrapper.x || 0) + normalizer;\n			rect.y = mathFloor(rect.y || wrapper.y || 0) + normalizer;\n			rect.width = mathFloor((rect.width || wrapper.width || 0) - 2 * normalizer);\n			rect.height = mathFloor((rect.height || wrapper.height || 0) - 2 * normalizer);\n			rect.strokeWidth = strokeWidth;\n\n			for (key in rect) {\n				if (wrapper[key] !== rect[key]) { // only set attribute if changed\n					wrapper[key] = attribs[key] = rect[key];\n				}\n			}\n\n			return attribs;\n		},\n\n		/**\n		 * Set styles for the element\n		 * @param {Object} styles\n		 */\n		css: function (styles) {\n			var elemWrapper = this,\n				oldStyles = elemWrapper.styles,\n				newStyles = {},\n				elem = elemWrapper.element,\n				textWidth,\n				n,\n				serializedCss = '',\n				hyphenate,\n				hasNew = !oldStyles;\n\n			// convert legacy\n			if (styles && styles.color) {\n				styles.fill = styles.color;\n			}\n\n			// Filter out existing styles to increase performance (#2640)\n			if (oldStyles) {\n				for (n in styles) {\n					if (styles[n] !== oldStyles[n]) {\n						newStyles[n] = styles[n];\n						hasNew = true;\n					}\n				}\n			}\n			if (hasNew) {\n				textWidth = elemWrapper.textWidth = \n					(styles && styles.width && elem.nodeName.toLowerCase() === 'text' && pInt(styles.width)) || \n					elemWrapper.textWidth; // #3501\n\n				// Merge the new styles with the old ones\n				if (oldStyles) {\n					styles = extend(\n						oldStyles,\n						newStyles\n					);\n				}		\n\n				// store object\n				elemWrapper.styles = styles;\n\n				if (textWidth && (useCanVG || (!hasSVG && elemWrapper.renderer.forExport))) {\n					delete styles.width;\n				}\n\n				// serialize and set style attribute\n				if (isIE && !hasSVG) {\n					css(elemWrapper.element, styles);\n				} else {\n					/*jslint unparam: true*/\n					hyphenate = function (a, b) { return '-' + b.toLowerCase(); };\n					/*jslint unparam: false*/\n					for (n in styles) {\n						serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';\n					}\n					attr(elem, 'style', serializedCss); // #1881\n				}\n\n\n				// re-build text\n				if (textWidth && elemWrapper.added) {\n					elemWrapper.renderer.buildText(elemWrapper);\n				}\n			}\n\n			return elemWrapper;\n		},\n\n		/**\n		 * Add an event listener\n		 * @param {String} eventType\n		 * @param {Function} handler\n		 */\n		on: function (eventType, handler) {\n			var svgElement = this,\n				element = svgElement.element;\n			\n			// touch\n			if (hasTouch && eventType === 'click') {\n				element.ontouchstart = function (e) {			\n					svgElement.touchEventFired = Date.now();				\n					e.preventDefault();\n					handler.call(element, e);\n				};\n				element.onclick = function (e) {												\n					if (userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) { // #2269\n						handler.call(element, e);\n					}\n				};			\n			} else {\n				// simplest possible event model for internal use\n				element['on' + eventType] = handler;\n			}\n			return this;\n		},\n\n		/**\n		 * Set the coordinates needed to draw a consistent radial gradient across\n		 * pie slices regardless of positioning inside the chart. The format is\n		 * [centerX, centerY, diameter] in pixels.\n		 */\n		setRadialReference: function (coordinates) {\n			this.element.radialReference = coordinates;\n			return this;\n		},\n\n		/**\n		 * Move an object and its children by x and y values\n		 * @param {Number} x\n		 * @param {Number} y\n		 */\n		translate: function (x, y) {\n			return this.attr({\n				translateX: x,\n				translateY: y\n			});\n		},\n\n		/**\n		 * Invert a group, rotate and flip\n		 */\n		invert: function () {\n			var wrapper = this;\n			wrapper.inverted = true;\n			wrapper.updateTransform();\n			return wrapper;\n		},\n\n		/**\n		 * Private method to update the transform attribute based on internal\n		 * properties\n		 */\n		updateTransform: function () {\n			var wrapper = this,\n				translateX = wrapper.translateX || 0,\n				translateY = wrapper.translateY || 0,\n				scaleX = wrapper.scaleX,\n				scaleY = wrapper.scaleY,\n				inverted = wrapper.inverted,\n				rotation = wrapper.rotation,\n				element = wrapper.element,\n				transform;\n\n			// flipping affects translate as adjustment for flipping around the group's axis\n			if (inverted) {\n				translateX += wrapper.attr('width');\n				translateY += wrapper.attr('height');\n			}\n\n			// Apply translate. Nearly all transformed elements have translation, so instead\n			// of checking for translate = 0, do it always (#1767, #1846).\n			transform = ['translate(' + translateX + ',' + translateY + ')'];\n\n			// apply rotation\n			if (inverted) {\n				transform.push('rotate(90) scale(-1,1)');\n			} else if (rotation) { // text rotation\n				transform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');\n				\n				// Delete bBox memo when the rotation changes\n				//delete wrapper.bBox;\n			}\n\n			// apply scale\n			if (defined(scaleX) || defined(scaleY)) {\n				transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');\n			}\n\n			if (transform.length) {\n				element.setAttribute('transform', transform.join(' '));\n			}\n		},\n		/**\n		 * Bring the element to the front\n		 */\n		toFront: function () {\n			var element = this.element;\n			element.parentNode.appendChild(element);\n			return this;\n		},\n\n\n		/**\n		 * Break down alignment options like align, verticalAlign, x and y\n		 * to x and y relative to the chart.\n		 *\n		 * @param {Object} alignOptions\n		 * @param {Boolean} alignByTranslate\n		 * @param {String[Object} box The box to align to, needs a width and height. When the\n		 *		box is a string, it refers to an object in the Renderer. For example, when\n		 *		box is 'spacingBox', it refers to Renderer.spacingBox which holds width, height\n		 *		x and y properties.\n		 *\n		 */\n		align: function (alignOptions, alignByTranslate, box) {\n			var align,\n				vAlign,\n				x,\n				y,\n				attribs = {},\n				alignTo,\n				renderer = this.renderer,\n				alignedObjects = renderer.alignedObjects;\n\n			// First call on instanciate\n			if (alignOptions) {\n				this.alignOptions = alignOptions;\n				this.alignByTranslate = alignByTranslate;\n				if (!box || isString(box)) { // boxes other than renderer handle this internally\n					this.alignTo = alignTo = box || 'renderer';\n					erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize\n					alignedObjects.push(this);\n					box = null; // reassign it below\n				}\n\n			// When called on resize, no arguments are supplied\n			} else {\n				alignOptions = this.alignOptions;\n				alignByTranslate = this.alignByTranslate;\n				alignTo = this.alignTo;\n			}\n\n			box = pick(box, renderer[alignTo], renderer);\n\n			// Assign variables\n			align = alignOptions.align;\n			vAlign = alignOptions.verticalAlign;\n			x = (box.x || 0) + (alignOptions.x || 0); // default: left align\n			y = (box.y || 0) + (alignOptions.y || 0); // default: top align\n\n			// Align\n			if (align === 'right' || align === 'center') {\n				x += (box.width - (alignOptions.width || 0)) /\n						{ right: 1, center: 2 }[align];\n			}\n			attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);\n\n\n			// Vertical align\n			if (vAlign === 'bottom' || vAlign === 'middle') {\n				y += (box.height - (alignOptions.height || 0)) /\n						({ bottom: 1, middle: 2 }[vAlign] || 1);\n\n			}\n			attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);\n\n			// Animate only if already placed\n			this[this.placed ? 'animate' : 'attr'](attribs);\n			this.placed = true;\n			this.alignAttr = attribs;\n\n			return this;\n		},\n\n		/**\n		 * Get the bounding box (width, height, x and y) for the element\n		 */\n		getBBox: function (reload) {\n			var wrapper = this,\n				bBox,// = wrapper.bBox,\n				renderer = wrapper.renderer,\n				width,\n				height,\n				rotation = wrapper.rotation,\n				element = wrapper.element,\n				styles = wrapper.styles,\n				rad = rotation * deg2rad,\n				textStr = wrapper.textStr,\n				textShadow,\n				elemStyle = element.style,\n				toggleTextShadowShim,\n				cacheKey;\n\n			if (textStr !== UNDEFINED) {\n\n				// Properties that affect bounding box\n				cacheKey = ['', rotation || 0, styles && styles.fontSize, element.style.width].join(',');\n\n				// Since numbers are monospaced, and numerical labels appear a lot in a chart,\n				// we assume that a label of n characters has the same bounding box as others \n				// of the same length.\n				if (textStr === '' || numRegex.test(textStr)) {\n					cacheKey = 'num:' + textStr.toString().length + cacheKey;\n\n				// Caching all strings reduces rendering time by 4-5%.\n				} else {\n					cacheKey = textStr + cacheKey;\n				}\n			}\n\n			if (cacheKey && !reload) {\n				bBox = renderer.cache[cacheKey];\n			}\n\n			// No cache found\n			if (!bBox) {\n\n				// SVG elements\n				if (element.namespaceURI === SVG_NS || renderer.forExport) {\n					try { // Fails in Firefox if the container has display: none.\n\n						// When the text shadow shim is used, we need to hide the fake shadows\n						// to get the correct bounding box (#3872)\n						toggleTextShadowShim = this.fakeTS && function (display) {\n							each(element.querySelectorAll('.' + PREFIX + 'text-shadow'), function (tspan) {\n								tspan.style.display = display;\n							});\n						};\n\n						// Workaround for #3842, Firefox reporting wrong bounding box for shadows\n						if (isFirefox && elemStyle.textShadow) {\n							textShadow = elemStyle.textShadow;\n							elemStyle.textShadow = '';\n						} else if (toggleTextShadowShim) {\n							toggleTextShadowShim(NONE);\n						}\n\n						bBox = element.getBBox ?\n							// SVG: use extend because IE9 is not allowed to change width and height in case\n							// of rotation (below)\n							extend({}, element.getBBox()) :\n							// Canvas renderer and legacy IE in export mode\n							{\n								width: element.offsetWidth,\n								height: element.offsetHeight\n							};\n\n						// #3842\n						if (textShadow) {\n							elemStyle.textShadow = textShadow;\n						} else if (toggleTextShadowShim) {\n							toggleTextShadowShim('');\n						}\n					} catch (e) {}\n\n					// If the bBox is not set, the try-catch block above failed. The other condition\n					// is for Opera that returns a width of -Infinity on hidden elements.\n					if (!bBox || bBox.width < 0) {\n						bBox = { width: 0, height: 0 };\n					}\n\n\n				// VML Renderer or useHTML within SVG\n				} else {\n\n					bBox = wrapper.htmlGetBBox();\n\n				}\n\n				// True SVG elements as well as HTML elements in modern browsers using the .useHTML option\n				// need to compensated for rotation\n				if (renderer.isSVG) {\n					width = bBox.width;\n					height = bBox.height;\n\n					// Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669, #2568)\n					if (isIE && styles && styles.fontSize === '11px' && height.toPrecision(3) === '16.9') {\n						bBox.height = height = 14;\n					}\n\n					// Adjust for rotated text\n					if (rotation) {\n						bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));\n						bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));\n					}\n				}\n\n				// Cache it\n				renderer.cache[cacheKey] = bBox;\n			}\n			return bBox;\n		},\n\n		/**\n		 * Show the element\n		 */\n		show: function (inherit) {\n			// IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881)\n			if (inherit && this.element.namespaceURI === SVG_NS) {\n				this.element.removeAttribute('visibility');\n			} else {\n				this.attr({ visibility: inherit ? 'inherit' : VISIBLE });\n			}\n			return this;\n		},\n\n		/**\n		 * Hide the element\n		 */\n		hide: function () {\n			return this.attr({ visibility: HIDDEN });\n		},\n\n		fadeOut: function (duration) {\n			var elemWrapper = this;\n			elemWrapper.animate({\n				opacity: 0\n			}, {\n				duration: duration || 150,\n				complete: function () {\n					elemWrapper.attr({ y: -9999 }); // #3088, assuming we're only using this for tooltips\n				}\n			});\n		},\n\n		/**\n		 * Add the element\n		 * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined\n		 *	to append the element to the renderer.box.\n		 */\n		add: function (parent) {\n\n			var renderer = this.renderer,\n				element = this.element,\n				inserted;\n\n			if (parent) {\n				this.parentGroup = parent;\n			}\n\n			// mark as inverted\n			this.parentInverted = parent && parent.inverted;\n\n			// build formatted text\n			if (this.textStr !== undefined) {\n				renderer.buildText(this);\n			}\n\n			// Mark as added\n			this.added = true;\n\n			// If we're adding to renderer root, or other elements in the group \n			// have a z index, we need to handle it\n			if (!parent || parent.handleZ || this.zIndex) {\n				inserted = this.zIndexSetter();\n			}\n\n			// If zIndex is not handled, append at the end\n			if (!inserted) {\n				(parent ? parent.element : renderer.box).appendChild(element);\n			}\n\n			// fire an event for internal hooks\n			if (this.onAdd) {\n				this.onAdd();\n			}\n\n			return this;\n		},\n\n		/**\n		 * Removes a child either by removeChild or move to garbageBin.\n		 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n		 */\n		safeRemoveChild: function (element) {\n			var parentNode = element.parentNode;\n			if (parentNode) {\n				parentNode.removeChild(element);\n			}\n		},\n\n		/**\n		 * Destroy the element and element wrapper\n		 */\n		destroy: function () {\n			var wrapper = this,\n				element = wrapper.element || {},\n				shadows = wrapper.shadows,\n				parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,\n				grandParent,\n				key,\n				i;\n\n			// remove events\n			element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;\n			stop(wrapper); // stop running animations\n\n			if (wrapper.clipPath) {\n				wrapper.clipPath = wrapper.clipPath.destroy();\n			}\n\n			// Destroy stops in case this is a gradient object\n			if (wrapper.stops) {\n				for (i = 0; i < wrapper.stops.length; i++) {\n					wrapper.stops[i] = wrapper.stops[i].destroy();\n				}\n				wrapper.stops = null;\n			}\n\n			// remove element\n			wrapper.safeRemoveChild(element);\n\n			// destroy shadows\n			if (shadows) {\n				each(shadows, function (shadow) {\n					wrapper.safeRemoveChild(shadow);\n				});\n			}\n\n			// In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).\n			while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {\n				grandParent = parentToClean.parentGroup;\n				wrapper.safeRemoveChild(parentToClean.div);\n				delete parentToClean.div;\n				parentToClean = grandParent;\n			}\n\n			// remove from alignObjects\n			if (wrapper.alignTo) {\n				erase(wrapper.renderer.alignedObjects, wrapper);\n			}\n\n			for (key in wrapper) {\n				delete wrapper[key];\n			}\n\n			return null;\n		},\n\n		/**\n		 * Add a shadow to the element. Must be done after the element is added to the DOM\n		 * @param {Boolean|Object} shadowOptions\n		 */\n		shadow: function (shadowOptions, group, cutOff) {\n			var shadows = [],\n				i,\n				shadow,\n				element = this.element,\n				strokeWidth,\n				shadowWidth,\n				shadowElementOpacity,\n\n				// compensate for inverted plot area\n				transform;\n\n\n			if (shadowOptions) {\n				shadowWidth = pick(shadowOptions.width, 3);\n				shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n				transform = this.parentInverted ?\n					'(-1,-1)' :\n					'(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';\n				for (i = 1; i <= shadowWidth; i++) {\n					shadow = element.cloneNode(0);\n					strokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n					attr(shadow, {\n						'isShadow': 'true',\n						'stroke': shadowOptions.color || 'black',\n						'stroke-opacity': shadowElementOpacity * i,\n						'stroke-width': strokeWidth,\n						'transform': 'translate' + transform,\n						'fill': NONE\n					});\n					if (cutOff) {\n						attr(shadow, 'height', mathMax(attr(shadow, 'height') - strokeWidth, 0));\n						shadow.cutHeight = strokeWidth;\n					}\n\n					if (group) {\n						group.element.appendChild(shadow);\n					} else {\n						element.parentNode.insertBefore(shadow, element);\n					}\n\n					shadows.push(shadow);\n				}\n\n				this.shadows = shadows;\n			}\n			return this;\n\n		},\n\n		xGetter: function (key) {\n			if (this.element.nodeName === 'circle') {\n				key = { x: 'cx', y: 'cy' }[key] || key;\n			}\n			return this._defaultGetter(key);\n		},\n\n		/** \n		 * Get the current value of an attribute or pseudo attribute, used mainly\n		 * for animation.\n		 */\n		_defaultGetter: function (key) {\n			var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);\n\n			if (/^[\\-0-9\\.]+$/.test(ret)) { // is numerical\n				ret = parseFloat(ret);\n			}\n			return ret;\n		},\n\n\n		dSetter: function (value, key, element) {\n			if (value && value.join) { // join path\n				value = value.join(' ');\n			}\n			if (/(NaN| {2}|^$)/.test(value)) {\n				value = 'M 0 0';\n			}\n			element.setAttribute(key, value);\n\n			this[key] = value;\n		},\n		dashstyleSetter: function (value) {\n			var i;\n			value = value && value.toLowerCase();\n			if (value) {\n				value = value\n					.replace('shortdashdotdot', '3,1,1,1,1,1,')\n					.replace('shortdashdot', '3,1,1,1')\n					.replace('shortdot', '1,1,')\n					.replace('shortdash', '3,1,')\n					.replace('longdash', '8,3,')\n					.replace(/dot/g, '1,3,')\n					.replace('dash', '4,3,')\n					.replace(/,$/, '')\n					.split(','); // ending comma\n\n				i = value.length;\n				while (i--) {\n					value[i] = pInt(value[i]) * this['stroke-width'];\n				}\n				value = value.join(',')\n					.replace('NaN', 'none'); // #3226\n				this.element.setAttribute('stroke-dasharray', value);\n			}\n		},\n		alignSetter: function (value) {\n			this.element.setAttribute('text-anchor', { left: 'start', center: 'middle', right: 'end' }[value]);\n		},\n		opacitySetter: function (value, key, element) {\n			this[key] = value;\n			element.setAttribute(key, value);\n		},\n		titleSetter: function (value) {\n			var titleNode = this.element.getElementsByTagName('title')[0];\n			if (!titleNode) {\n				titleNode = doc.createElementNS(SVG_NS, 'title');\n				this.element.appendChild(titleNode);\n			}\n			titleNode.textContent = (String(pick(value), '')).replace(/<[^>]*>/g, ''); // #3276 #3895\n		},\n		textSetter: function (value) {\n			if (value !== this.textStr) {\n				// Delete bBox memo when the text changes\n				delete this.bBox;\n			\n				this.textStr = value;\n				if (this.added) {\n					this.renderer.buildText(this);\n				}\n			}\n		},\n		fillSetter: function (value, key, element) {\n			if (typeof value === 'string') {\n				element.setAttribute(key, value);\n			} else if (value) {\n				this.colorGradient(value, key, element);\n			}\n		},\n		zIndexSetter: function (value, key) {\n			var renderer = this.renderer,\n				parentGroup = this.parentGroup,\n				parentWrapper = parentGroup || renderer,\n				parentNode = parentWrapper.element || renderer.box,\n				childNodes,\n				otherElement,\n				otherZIndex,\n				element = this.element,\n				inserted,\n				run = this.added,\n				i;\n			\n			if (defined(value)) {\n				element.setAttribute(key, value); // So we can read it for other elements in the group\n				value = +value;\n				if (this[key] === value) { // Only update when needed (#3865)\n					run = false;\n				}\n				this[key] = value;\n			}\n\n			// Insert according to this and other elements' zIndex. Before .add() is called,\n			// nothing is done. Then on add, or by later calls to zIndexSetter, the node\n			// is placed on the right place in the DOM.\n			if (run) {\n				value = this.zIndex;\n\n				if (value && parentGroup) {\n					parentGroup.handleZ = true;\n				}\n			\n				childNodes = parentNode.childNodes;\n				for (i = 0; i < childNodes.length && !inserted; i++) {\n					otherElement = childNodes[i];\n					otherZIndex = attr(otherElement, 'zIndex');\n					if (otherElement !== element && (\n							// Insert before the first element with a higher zIndex\n							pInt(otherZIndex) > value ||\n							// If no zIndex given, insert before the first element with a zIndex\n							(!defined(value) && defined(otherZIndex))\n\n							)) {\n						parentNode.insertBefore(element, otherElement);\n						inserted = true;\n					}\n				}\n				if (!inserted) {\n					parentNode.appendChild(element);\n				}\n			}\n			return inserted;\n		},\n		_defaultSetter: function (value, key, element) {\n			element.setAttribute(key, value);\n		}\n	};\n\n	// Some shared setters and getters\n	SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;\n	SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = \n			SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter = \n			SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function (value, key) {\n		this[key] = value;\n		this.doTransform = true;\n	};\n\n	// WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the \n	// stroke attribute altogether. #1270, #1369, #3065, #3072.\n	SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function (value, key, element) {\n		this[key] = value;\n		// Only apply the stroke attribute if the stroke width is defined and larger than 0\n		if (this.stroke && this['stroke-width']) {\n			this.strokeWidth = this['stroke-width'];\n			SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden\n			element.setAttribute('stroke-width', this['stroke-width']);\n			this.hasStroke = true;\n		} else if (key === 'stroke-width' && value === 0 && this.hasStroke) {\n			element.removeAttribute('stroke');\n			this.hasStroke = false;\n		}\n	};\n\n\n	/**\n	 * The default SVG renderer\n	 */\n	var SVGRenderer = function () {\n		this.init.apply(this, arguments);\n	};\n	SVGRenderer.prototype = {\n		Element: SVGElement,\n\n		/**\n		 * Initialize the SVGRenderer\n		 * @param {Object} container\n		 * @param {Number} width\n		 * @param {Number} height\n		 * @param {Boolean} forExport\n		 */\n		init: function (container, width, height, style, forExport) {\n			var renderer = this,\n				loc = location,\n				boxWrapper,\n				element,\n				desc;\n\n			boxWrapper = renderer.createElement('svg')\n				.attr({\n					version: '1.1'\n				})\n				.css(this.getStyle(style));\n			element = boxWrapper.element;\n			container.appendChild(element);\n\n			// For browsers other than IE, add the namespace attribute (#1978)\n			if (container.innerHTML.indexOf('xmlns') === -1) {\n				attr(element, 'xmlns', SVG_NS);\n			}\n\n			// object properties\n			renderer.isSVG = true;\n			renderer.box = element;\n			renderer.boxWrapper = boxWrapper;\n			renderer.alignedObjects = [];\n\n			// Page url used for internal references. #24, #672, #1070\n			renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?\n				loc.href\n					.replace(/#.*?$/, '') // remove the hash\n					.replace(/([\\('\\)])/g, '\\\\$1') // escape parantheses and quotes\n					.replace(/ /g, '%20') : // replace spaces (needed for Safari only)\n				'';\n\n			// Add description\n			desc = this.createElement('desc').add();\n			desc.element.appendChild(doc.createTextNode('Created with ' + PRODUCT + ' ' + VERSION));\n\n\n			renderer.defs = this.createElement('defs').add();\n			renderer.forExport = forExport;\n			renderer.gradients = {}; // Object where gradient SvgElements are stored\n			renderer.cache = {}; // Cache for numerical bounding boxes\n\n			renderer.setSize(width, height, false);\n\n\n\n			// Issue 110 workaround:\n			// In Firefox, if a div is positioned by percentage, its pixel position may land\n			// between pixels. The container itself doesn't display this, but an SVG element\n			// inside this container will be drawn at subpixel precision. In order to draw\n			// sharp lines, this must be compensated for. This doesn't seem to work inside\n			// iframes though (like in jsFiddle).\n			var subPixelFix, rect;\n			if (isFirefox && container.getBoundingClientRect) {\n				renderer.subPixelFix = subPixelFix = function () {\n					css(container, { left: 0, top: 0 });\n					rect = container.getBoundingClientRect();\n					css(container, {\n						left: (mathCeil(rect.left) - rect.left) + PX,\n						top: (mathCeil(rect.top) - rect.top) + PX\n					});\n				};\n\n				// run the fix now\n				subPixelFix();\n\n				// run it on resize\n				addEvent(win, 'resize', subPixelFix);\n			}\n		},\n\n		getStyle: function (style) {\n			return (this.style = extend({\n				fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif', // default font\n				fontSize: '12px'\n			}, style));\n		},\n\n		/**\n		 * Detect whether the renderer is hidden. This happens when one of the parent elements\n		 * has display: none. #608.\n		 */\n		isHidden: function () {\n			return !this.boxWrapper.getBBox().width;\n		},\n\n		/**\n		 * Destroys the renderer and its allocated members.\n		 */\n		destroy: function () {\n			var renderer = this,\n				rendererDefs = renderer.defs;\n			renderer.box = null;\n			renderer.boxWrapper = renderer.boxWrapper.destroy();\n\n			// Call destroy on all gradient elements\n			destroyObjectProperties(renderer.gradients || {});\n			renderer.gradients = null;\n\n			// Defs are null in VMLRenderer\n			// Otherwise, destroy them here.\n			if (rendererDefs) {\n				renderer.defs = rendererDefs.destroy();\n			}\n\n			// Remove sub pixel fix handler\n			// We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed\n			// See issue #982\n			if (renderer.subPixelFix) {\n				removeEvent(win, 'resize', renderer.subPixelFix);\n			}\n\n			renderer.alignedObjects = null;\n\n			return null;\n		},\n\n		/**\n		 * Create a wrapper for an SVG element\n		 * @param {Object} nodeName\n		 */\n		createElement: function (nodeName) {\n			var wrapper = new this.Element();\n			wrapper.init(this, nodeName);\n			return wrapper;\n		},\n\n		/**\n		 * Dummy function for use in canvas renderer\n		 */\n		draw: function () {},\n\n		/**\n		 * Parse a simple HTML string into SVG tspans\n		 *\n		 * @param {Object} textNode The parent text SVG node\n		 */\n		buildText: function (wrapper) {\n			var textNode = wrapper.element,\n				renderer = this,\n				forExport = renderer.forExport,\n				textStr = pick(wrapper.textStr, '').toString(),\n				hasMarkup = textStr.indexOf('<') !== -1,\n				lines,\n				childNodes = textNode.childNodes,\n				styleRegex,\n				hrefRegex,\n				parentX = attr(textNode, 'x'),\n				textStyles = wrapper.styles,\n				width = wrapper.textWidth,\n				textLineHeight = textStyles && textStyles.lineHeight,\n				textShadow = textStyles && textStyles.textShadow,\n				ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',\n				i = childNodes.length,\n				tempParent = width && !wrapper.added && this.box,\n				getLineHeight = function (tspan) {\n					return textLineHeight ? \n						pInt(textLineHeight) :\n						renderer.fontMetrics(\n							/(px|em)$/.test(tspan && tspan.style.fontSize) ?\n								tspan.style.fontSize :\n								((textStyles && textStyles.fontSize) || renderer.style.fontSize || 12),\n							tspan\n						).h;\n				},\n				unescapeAngleBrackets = function (inputStr) {\n					return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');\n				};\n\n			/// remove old text\n			while (i--) {\n				textNode.removeChild(childNodes[i]);\n			}\n\n			// Skip tspans, add text directly to text node. The forceTSpan is a hook \n			// used in text outline hack.\n			if (!hasMarkup && !textShadow && !ellipsis && textStr.indexOf(' ') === -1) {\n				textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));\n				return;\n\n			// Complex strings, add more logic\n			} else {\n\n				styleRegex = /<.*style=\"([^\"]+)\".*>/;\n				hrefRegex = /<.*href=\"(http[^\"]+)\".*>/;\n\n				if (tempParent) {\n					tempParent.appendChild(textNode); // attach it to the DOM to read offset width\n				}\n\n				if (hasMarkup) {\n					lines = textStr\n						.replace(/<(b|strong)>/g, '<span style=\"font-weight:bold\">')\n						.replace(/<(i|em)>/g, '<span style=\"font-style:italic\">')\n						.replace(/<a/g, '<span')\n						.replace(/<\\/(b|strong|i|em|a)>/g, '</span>')\n						.split(/<br.*?>/g);\n\n				} else {\n					lines = [textStr];\n				}\n\n\n				// remove empty line at end\n				if (lines[lines.length - 1] === '') {\n					lines.pop();\n				}\n\n				\n				// build the lines\n				each(lines, function (line, lineNo) {\n					var spans, spanNo = 0;\n\n					line = line.replace(/<span/g, '|||<span').replace(/<\\/span>/g, '</span>|||');\n					spans = line.split('|||');\n\n					each(spans, function (span) {\n						if (span !== '' || spans.length === 1) {\n							var attributes = {},\n								tspan = doc.createElementNS(SVG_NS, 'tspan'),\n								spanStyle; // #390\n							if (styleRegex.test(span)) {\n								spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');\n								attr(tspan, 'style', spanStyle);\n							}\n							if (hrefRegex.test(span) && !forExport) { // Not for export - #1529\n								attr(tspan, 'onclick', 'location.href=\\\"' + span.match(hrefRegex)[1] + '\\\"');\n								css(tspan, { cursor: 'pointer' });\n							}\n\n							span = unescapeAngleBrackets(span.replace(/<(.|\\n)*?>/g, '') || ' ');\n\n							// Nested tags aren't supported, and cause crash in Safari (#1596)\n							if (span !== ' ') {\n\n								// add the text node\n								tspan.appendChild(doc.createTextNode(span));\n\n								if (!spanNo) { // first span in a line, align it to the left\n									if (lineNo && parentX !== null) {\n										attributes.x = parentX;\n									}\n								} else {\n									attributes.dx = 0; // #16\n								}\n\n								// add attributes\n								attr(tspan, attributes);\n\n								// Append it\n								textNode.appendChild(tspan);\n\n								// first span on subsequent line, add the line height\n								if (!spanNo && lineNo) {\n\n									// allow getting the right offset height in exporting in IE\n									if (!hasSVG && forExport) {\n										css(tspan, { display: 'block' });\n									}\n\n									// Set the line height based on the font size of either\n									// the text element or the tspan element\n									attr(\n										tspan,\n										'dy',\n										getLineHeight(tspan)\n									);\n								}\n\n								/*if (width) {\n									renderer.breakText(wrapper, width);\n								}*/\n\n								// Check width and apply soft breaks or ellipsis\n								if (width) {\n									var words = span.replace(/([^\\^])-/g, '$1- ').split(' '), // #1273\n										hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && textStyles.whiteSpace !== 'nowrap'),\n										tooLong,\n										wasTooLong,\n										actualWidth,\n										rest = [],\n										dy = getLineHeight(tspan),\n										softLineNo = 1,\n										rotation = wrapper.rotation,\n										wordStr = span, // for ellipsis\n										cursor = wordStr.length, // binary search cursor\n										bBox;\n\n									while ((hasWhiteSpace || ellipsis) && (words.length || rest.length)) {\n										wrapper.rotation = 0; // discard rotation when computing box\n										bBox = wrapper.getBBox(true);\n										actualWidth = bBox.width;\n\n										// Old IE cannot measure the actualWidth for SVG elements (#2314)\n										if (!hasSVG && renderer.forExport) {\n											actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);\n										}\n\n										tooLong = actualWidth > width;\n\n										// For ellipsis, do a binary search for the correct string length\n										if (wasTooLong === undefined) {\n											wasTooLong = tooLong; // First time\n										}\n										if (ellipsis && wasTooLong) {\n											cursor /= 2;\n\n											if (wordStr === '' || (!tooLong && cursor < 0.5)) {\n												words = []; // All ok, break out\n											} else {\n												if (tooLong) {\n													wasTooLong = true;\n												}\n												wordStr = span.substring(0, wordStr.length + (tooLong ? -1 : 1) * mathCeil(cursor));\n												words = [wordStr + '\\u2026'];\n												tspan.removeChild(tspan.firstChild);\n											}\n\n										// Looping down, this is the first word sequence that is not too long,\n										// so we can move on to build the next line.\n										} else if (!tooLong || words.length === 1) {\n											words = rest;\n											rest = [];\n													\n											if (words.length) {\n												softLineNo++;\n												\n												tspan = doc.createElementNS(SVG_NS, 'tspan');\n												attr(tspan, {\n													dy: dy,\n													x: parentX\n												});\n												if (spanStyle) { // #390\n													attr(tspan, 'style', spanStyle);\n												}\n												textNode.appendChild(tspan);\n											}\n											if (actualWidth > width) { // a single word is pressing it out\n												width = actualWidth;\n											}\n										} else { // append to existing line tspan\n											tspan.removeChild(tspan.firstChild);\n											rest.unshift(words.pop());\n										}\n										if (words.length) {\n											tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));\n										}\n									}\n									if (wasTooLong) {\n										wrapper.attr('title', wrapper.textStr);\n									}\n									wrapper.rotation = rotation;\n								}\n\n								spanNo++;\n							}\n						}\n					});\n				});\n				if (tempParent) {\n					tempParent.removeChild(textNode); // attach it to the DOM to read offset width\n				}\n\n				// Apply the text shadow\n				if (textShadow && wrapper.applyTextShadow) {\n					wrapper.applyTextShadow(textShadow);\n				}\n			}\n		},\n\n		\n\n		/*\n		breakText: function (wrapper, width) {\n			var bBox = wrapper.getBBox(),\n				node = wrapper.element,\n				textLength = node.textContent.length,\n				pos = mathRound(width * textLength / bBox.width), // try this position first, based on average character width\n				increment = 0,\n				finalPos;\n\n			if (bBox.width > width) {\n				while (finalPos === undefined) {\n					textLength = node.getSubStringLength(0, pos);\n\n					if (textLength <= width) {\n						if (increment === -1) {\n							finalPos = pos;\n						} else {\n							increment = 1;\n						}\n					} else {\n						if (increment === 1) {\n							finalPos = pos - 1;\n						} else {\n							increment = -1;\n						}\n					}\n					pos += increment;\n				}\n			}\n			console.log(finalPos, node.getSubStringLength(0, finalPos))\n		},\n		*/\n\n		/** \n		 * Returns white for dark colors and black for bright colors\n		 */\n		getContrast: function (color) {\n			color = Color(color).rgba;\n			return color[0] + color[1] + color[2] > 384 ? '#000' : '#FFF';\n		},\n\n		/**\n		 * Create a button with preset states\n		 * @param {String} text\n		 * @param {Number} x\n		 * @param {Number} y\n		 * @param {Function} callback\n		 * @param {Object} normalState\n		 * @param {Object} hoverState\n		 * @param {Object} pressedState\n		 */\n		button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {\n			var label = this.label(text, x, y, shape, null, null, null, null, 'button'),\n				curState = 0,\n				stateOptions,\n				stateStyle,\n				normalStyle,\n				hoverStyle,\n				pressedStyle,\n				disabledStyle,\n				verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };\n\n			// Normal state - prepare the attributes\n			normalState = merge({\n				'stroke-width': 1,\n				stroke: '#CCCCCC',\n				fill: {\n					linearGradient: verticalGradient,\n					stops: [\n						[0, '#FEFEFE'],\n						[1, '#F6F6F6']\n					]\n				},\n				r: 2,\n				padding: 5,\n				style: {\n					color: 'black'\n				}\n			}, normalState);\n			normalStyle = normalState.style;\n			delete normalState.style;\n\n			// Hover state\n			hoverState = merge(normalState, {\n				stroke: '#68A',\n				fill: {\n					linearGradient: verticalGradient,\n					stops: [\n						[0, '#FFF'],\n						[1, '#ACF']\n					]\n				}\n			}, hoverState);\n			hoverStyle = hoverState.style;\n			delete hoverState.style;\n\n			// Pressed state\n			pressedState = merge(normalState, {\n				stroke: '#68A',\n				fill: {\n					linearGradient: verticalGradient,\n					stops: [\n						[0, '#9BD'],\n						[1, '#CDF']\n					]\n				}\n			}, pressedState);\n			pressedStyle = pressedState.style;\n			delete pressedState.style;\n\n			// Disabled state\n			disabledState = merge(normalState, {\n				style: {\n					color: '#CCC'\n				}\n			}, disabledState);\n			disabledStyle = disabledState.style;\n			delete disabledState.style;\n\n			// Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).\n			addEvent(label.element, isIE ? 'mouseover' : 'mouseenter', function () {\n				if (curState !== 3) {\n					label.attr(hoverState)\n						.css(hoverStyle);\n				}\n			});\n			addEvent(label.element, isIE ? 'mouseout' : 'mouseleave', function () {\n				if (curState !== 3) {\n					stateOptions = [normalState, hoverState, pressedState][curState];\n					stateStyle = [normalStyle, hoverStyle, pressedStyle][curState];\n					label.attr(stateOptions)\n						.css(stateStyle);\n				}\n			});\n\n			label.setState = function (state) {\n				label.state = curState = state;\n				if (!state) {\n					label.attr(normalState)\n						.css(normalStyle);\n				} else if (state === 2) {\n					label.attr(pressedState)\n						.css(pressedStyle);\n				} else if (state === 3) {\n					label.attr(disabledState)\n						.css(disabledStyle);\n				}\n			};\n\n			return label\n				.on('click', function () {\n					if (curState !== 3) {\n						callback.call(label);\n					}\n				})\n				.attr(normalState)\n				.css(extend({ cursor: 'default' }, normalStyle));\n		},\n\n		/**\n		 * Make a straight line crisper by not spilling out to neighbour pixels\n		 * @param {Array} points\n		 * @param {Number} width\n		 */\n		crispLine: function (points, width) {\n			// points format: [M, 0, 0, L, 100, 0]\n			// normalize to a crisp line\n			if (points[1] === points[4]) {\n				// Substract due to #1129. Now bottom and left axis gridlines behave the same.\n				points[1] = points[4] = mathRound(points[1]) - (width % 2 / 2);\n			}\n			if (points[2] === points[5]) {\n				points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);\n			}\n			return points;\n		},\n\n\n		/**\n		 * Draw a path\n		 * @param {Array} path An SVG path in array form\n		 */\n		path: function (path) {\n			var attr = {\n				fill: NONE\n			};\n			if (isArray(path)) {\n				attr.d = path;\n			} else if (isObject(path)) { // attributes\n				extend(attr, path);\n			}\n			return this.createElement('path').attr(attr);\n		},\n\n		/**\n		 * Draw and return an SVG circle\n		 * @param {Number} x The x position\n		 * @param {Number} y The y position\n		 * @param {Number} r The radius\n		 */\n		circle: function (x, y, r) {\n			var attr = isObject(x) ?\n				x :\n				{\n					x: x,\n					y: y,\n					r: r\n				},\n				wrapper = this.createElement('circle');\n\n			wrapper.xSetter = function (value) {\n				this.element.setAttribute('cx', value);\n			};\n			wrapper.ySetter = function (value) {\n				this.element.setAttribute('cy', value);\n			};\n			return wrapper.attr(attr);\n		},\n\n		/**\n		 * Draw and return an arc\n		 * @param {Number} x X position\n		 * @param {Number} y Y position\n		 * @param {Number} r Radius\n		 * @param {Number} innerR Inner radius like used in donut charts\n		 * @param {Number} start Starting angle\n		 * @param {Number} end Ending angle\n		 */\n		arc: function (x, y, r, innerR, start, end) {\n			var arc;\n\n			if (isObject(x)) {\n				y = x.y;\n				r = x.r;\n				innerR = x.innerR;\n				start = x.start;\n				end = x.end;\n				x = x.x;\n			}\n\n			// Arcs are defined as symbols for the ability to set\n			// attributes in attr and animate\n			arc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {\n				innerR: innerR || 0,\n				start: start || 0,\n				end: end || 0\n			});\n			arc.r = r; // #959\n			return arc;\n		},\n\n		/**\n		 * Draw and return a rectangle\n		 * @param {Number} x Left position\n		 * @param {Number} y Top position\n		 * @param {Number} width\n		 * @param {Number} height\n		 * @param {Number} r Border corner radius\n		 * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing\n		 */\n		rect: function (x, y, width, height, r, strokeWidth) {\n\n			r = isObject(x) ? x.r : r;\n\n			var wrapper = this.createElement('rect'),\n				attribs = isObject(x) ? x : x === UNDEFINED ? {} : {\n					x: x,\n					y: y,\n					width: mathMax(width, 0),\n					height: mathMax(height, 0)\n				};\n\n			if (strokeWidth !== UNDEFINED) {\n				attribs.strokeWidth = strokeWidth;\n				attribs = wrapper.crisp(attribs);\n			}\n\n			if (r) {\n				attribs.r = r;\n			}\n\n			wrapper.rSetter = function (value) {\n				attr(this.element, {\n					rx: value,\n					ry: value\n				});\n			};\n			\n			return wrapper.attr(attribs);\n		},\n\n		/**\n		 * Resize the box and re-align all aligned elements\n		 * @param {Object} width\n		 * @param {Object} height\n		 * @param {Boolean} animate\n		 *\n		 */\n		setSize: function (width, height, animate) {\n			var renderer = this,\n				alignedObjects = renderer.alignedObjects,\n				i = alignedObjects.length;\n\n			renderer.width = width;\n			renderer.height = height;\n\n			renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({\n				width: width,\n				height: height\n			});\n\n			while (i--) {\n				alignedObjects[i].align();\n			}\n		},\n\n		/**\n		 * Create a group\n		 * @param {String} name The group will be given a class name of 'highcharts-{name}'.\n		 *	 This can be used for styling and scripting.\n		 */\n		g: function (name) {\n			var elem = this.createElement('g');\n			return defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;\n		},\n\n		/**\n		 * Display an image\n		 * @param {String} src\n		 * @param {Number} x\n		 * @param {Number} y\n		 * @param {Number} width\n		 * @param {Number} height\n		 */\n		image: function (src, x, y, width, height) {\n			var attribs = {\n					preserveAspectRatio: NONE\n				},\n				elemWrapper;\n\n			// optional properties\n			if (arguments.length > 1) {\n				extend(attribs, {\n					x: x,\n					y: y,\n					width: width,\n					height: height\n				});\n			}\n\n			elemWrapper = this.createElement('image').attr(attribs);\n\n			// set the href in the xlink namespace\n			if (elemWrapper.element.setAttributeNS) {\n				elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',\n					'href', src);\n			} else {\n				// could be exporting in IE\n				// using href throws \"not supported\" in ie7 and under, requries regex shim to fix later\n				elemWrapper.element.setAttribute('hc-svg-href', src);\n			}\n			return elemWrapper;\n		},\n\n		/**\n		 * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.\n		 *\n		 * @param {Object} symbol\n		 * @param {Object} x\n		 * @param {Object} y\n		 * @param {Object} radius\n		 * @param {Object} options\n		 */\n		symbol: function (symbol, x, y, width, height, options) {\n\n			var obj,\n\n				// get the symbol definition function\n				symbolFn = this.symbols[symbol],\n\n				// check if there's a path defined for this symbol\n				path = symbolFn && symbolFn(\n					mathRound(x),\n					mathRound(y),\n					width,\n					height,\n					options\n				),\n\n				imageElement,\n				imageRegex = /^url\\((.*?)\\)$/,\n				imageSrc,\n				imageSize,\n				centerImage;\n\n			if (path) {\n\n				obj = this.path(path);\n				// expando properties for use in animate and attr\n				extend(obj, {\n					symbolName: symbol,\n					x: x,\n					y: y,\n					width: width,\n					height: height\n				});\n				if (options) {\n					extend(obj, options);\n				}\n\n\n			// image symbols\n			} else if (imageRegex.test(symbol)) {\n\n				// On image load, set the size and position\n				centerImage = function (img, size) {\n					if (img.element) { // it may be destroyed in the meantime (#1390)\n						img.attr({\n							width: size[0],\n							height: size[1]\n						});\n\n						if (!img.alignByTranslate) { // #185\n							img.translate(\n								mathRound((width - size[0]) / 2), // #1378\n								mathRound((height - size[1]) / 2)\n							);\n						}\n					}\n				};\n\n				imageSrc = symbol.match(imageRegex)[1];\n				imageSize = symbolSizes[imageSrc] || (options && options.width && options.height && [options.width, options.height]);\n\n				// Ireate the image synchronously, add attribs async\n				obj = this.image(imageSrc)\n					.attr({\n						x: x,\n						y: y\n					});\n				obj.isImg = true;\n\n				if (imageSize) {\n					centerImage(obj, imageSize);\n				} else {\n					// Initialize image to be 0 size so export will still function if there's no cached sizes.\n					obj.attr({ width: 0, height: 0 });\n\n					// Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,\n					// the created element must be assigned to a variable in order to load (#292).\n					imageElement = createElement('img', {\n						onload: function () {\n							centerImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);\n						},\n						src: imageSrc\n					});\n				}\n			}\n\n			return obj;\n		},\n\n		/**\n		 * An extendable collection of functions for defining symbol paths.\n		 */\n		symbols: {\n			'circle': function (x, y, w, h) {\n				var cpw = 0.166 * w;\n				return [\n					M, x + w / 2, y,\n					'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,\n					'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,\n					'Z'\n				];\n			},\n\n			'square': function (x, y, w, h) {\n				return [\n					M, x, y,\n					L, x + w, y,\n					x + w, y + h,\n					x, y + h,\n					'Z'\n				];\n			},\n\n			'triangle': function (x, y, w, h) {\n				return [\n					M, x + w / 2, y,\n					L, x + w, y + h,\n					x, y + h,\n					'Z'\n				];\n			},\n\n			'triangle-down': function (x, y, w, h) {\n				return [\n					M, x, y,\n					L, x + w, y,\n					x + w / 2, y + h,\n					'Z'\n				];\n			},\n			'diamond': function (x, y, w, h) {\n				return [\n					M, x + w / 2, y,\n					L, x + w, y + h / 2,\n					x + w / 2, y + h,\n					x, y + h / 2,\n					'Z'\n				];\n			},\n			'arc': function (x, y, w, h, options) {\n				var start = options.start,\n					radius = options.r || w || h,\n					end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)\n					innerRadius = options.innerR,\n					open = options.open,\n					cosStart = mathCos(start),\n					sinStart = mathSin(start),\n					cosEnd = mathCos(end),\n					sinEnd = mathSin(end),\n					longArc = options.end - start < mathPI ? 0 : 1;\n\n				return [\n					M,\n					x + radius * cosStart,\n					y + radius * sinStart,\n					'A', // arcTo\n					radius, // x radius\n					radius, // y radius\n					0, // slanting\n					longArc, // long or short arc\n					1, // clockwise\n					x + radius * cosEnd,\n					y + radius * sinEnd,\n					open ? M : L,\n					x + innerRadius * cosEnd,\n					y + innerRadius * sinEnd,\n					'A', // arcTo\n					innerRadius, // x radius\n					innerRadius, // y radius\n					0, // slanting\n					longArc, // long or short arc\n					0, // clockwise\n					x + innerRadius * cosStart,\n					y + innerRadius * sinStart,\n\n					open ? '' : 'Z' // close\n				];\n			},\n\n			/**\n			 * Callout shape used for default tooltips, also used for rounded rectangles in VML\n			 */\n			callout: function (x, y, w, h, options) {\n				var arrowLength = 6,\n					halfDistance = 6,\n					r = mathMin((options && options.r) || 0, w, h),\n					safeDistance = r + halfDistance,\n					anchorX = options && options.anchorX,\n					anchorY = options && options.anchorY,\n					path,\n					normalizer = mathRound(options.strokeWidth || 0) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors;\n\n				x += normalizer;\n				y += normalizer;\n				path = [\n					'M', x + r, y, \n					'L', x + w - r, y, // top side\n					'C', x + w, y, x + w, y, x + w, y + r, // top-right corner\n					'L', x + w, y + h - r, // right side\n					'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner\n					'L', x + r, y + h, // bottom side\n					'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner\n					'L', x, y + r, // left side\n					'C', x, y, x, y, x + r, y // top-right corner\n				];\n				\n				if (anchorX && anchorX > w && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace right side\n					path.splice(13, 3,\n						'L', x + w, anchorY - halfDistance, \n						x + w + arrowLength, anchorY,\n						x + w, anchorY + halfDistance,\n						x + w, y + h - r\n					);\n				} else if (anchorX && anchorX < 0 && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace left side\n					path.splice(33, 3, \n						'L', x, anchorY + halfDistance, \n						x - arrowLength, anchorY,\n						x, anchorY - halfDistance,\n						x, y + r\n					);\n				} else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom\n					path.splice(23, 3,\n						'L', anchorX + halfDistance, y + h,\n						anchorX, y + h + arrowLength,\n						anchorX - halfDistance, y + h,\n						x + r, y + h\n					);\n				} else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top\n					path.splice(3, 3,\n						'L', anchorX - halfDistance, y,\n						anchorX, y - arrowLength,\n						anchorX + halfDistance, y,\n						w - r, y\n					);\n				}\n				return path;\n			}\n		},\n\n		/**\n		 * Define a clipping rectangle\n		 * @param {String} id\n		 * @param {Number} x\n		 * @param {Number} y\n		 * @param {Number} width\n		 * @param {Number} height\n		 */\n		clipRect: function (x, y, width, height) {\n			var wrapper,\n				id = PREFIX + idCounter++,\n\n				clipPath = this.createElement('clipPath').attr({\n					id: id\n				}).add(this.defs);\n\n			wrapper = this.rect(x, y, width, height, 0).add(clipPath);\n			wrapper.id = id;\n			wrapper.clipPath = clipPath;\n			wrapper.count = 0;\n\n			return wrapper;\n		},\n\n\n		\n\n\n		/**\n		 * Add text to the SVG object\n		 * @param {String} str\n		 * @param {Number} x Left position\n		 * @param {Number} y Top position\n		 * @param {Boolean} useHTML Use HTML to render the text\n		 */\n		text: function (str, x, y, useHTML) {\n\n			// declare variables\n			var renderer = this,\n				fakeSVG = useCanVG || (!hasSVG && renderer.forExport),\n				wrapper,\n				attr = {};\n\n			if (useHTML && !renderer.forExport) {\n				return renderer.html(str, x, y);\n			}\n\n			attr.x = Math.round(x || 0); // X is always needed for line-wrap logic\n			if (y) {\n				attr.y = Math.round(y);\n			}\n			if (str || str === 0) {\n				attr.text = str;\n			}\n\n			wrapper = renderer.createElement('text')\n				.attr(attr);\n\n			// Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)\n			if (fakeSVG) {\n				wrapper.css({\n					position: ABSOLUTE\n				});\n			}\n\n			if (!useHTML) {\n				wrapper.xSetter = function (value, key, element) {\n					var tspans = element.getElementsByTagName('tspan'),\n						tspan,\n						parentVal = element.getAttribute(key),\n						i;\n					for (i = 0; i < tspans.length; i++) {\n						tspan = tspans[i];\n						// If the x values are equal, the tspan represents a linebreak\n						if (tspan.getAttribute(key) === parentVal) {\n							tspan.setAttribute(key, value);\n						}\n					}\n					element.setAttribute(key, value);\n				};\n			}\n			\n			return wrapper;\n		},\n\n		/**\n		 * Utility to return the baseline offset and total line height from the font size\n		 */\n		fontMetrics: function (fontSize, elem) {\n			fontSize = fontSize || this.style.fontSize;\n			if (elem && win.getComputedStyle) {\n				elem = elem.element || elem; // SVGElement\n				fontSize = win.getComputedStyle(elem, \"\").fontSize;\n			}\n			fontSize = /px/.test(fontSize) ? pInt(fontSize) : /em/.test(fontSize) ? parseFloat(fontSize) * 12 : 12;\n\n			// Empirical values found by comparing font size and bounding box height.\n			// Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/\n			var lineHeight = fontSize < 24 ? fontSize + 3 : mathRound(fontSize * 1.2),\n				baseline = mathRound(lineHeight * 0.8);\n\n			return {\n				h: lineHeight,\n				b: baseline,\n				f: fontSize\n			};\n		},\n\n		/**\n		 * Correct X and Y positioning of a label for rotation (#1764)\n		 */\n		rotCorr: function (baseline, rotation, alterY) {\n			var y = baseline;\n			if (rotation && alterY) {\n				y = mathMax(y * mathCos(rotation * deg2rad), 4);\n			}\n			return {\n				x: (-baseline / 3) * mathSin(rotation * deg2rad),\n				y: y\n			};\n		},\n\n		/**\n		 * Add a label, a text item that can hold a colored or gradient background\n		 * as well as a border and shadow.\n		 * @param {string} str\n		 * @param {Number} x\n		 * @param {Number} y\n		 * @param {String} shape\n		 * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the\n		 *	coordinates it should be pinned to\n		 * @param {Number} anchorY\n		 * @param {Boolean} baseline Whether to position the label relative to the text baseline,\n		 *	like renderer.text, or to the upper border of the rectangle.\n		 * @param {String} className Class name for the group\n		 */\n		label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {\n\n			var renderer = this,\n				wrapper = renderer.g(className),\n				text = renderer.text('', 0, 0, useHTML)\n					.attr({\n						zIndex: 1\n					}),\n					//.add(wrapper),\n				box,\n				bBox,\n				alignFactor = 0,\n				padding = 3,\n				paddingLeft = 0,\n				width,\n				height,\n				wrapperX,\n				wrapperY,\n				crispAdjust = 0,\n				deferredAttr = {},\n				baselineOffset,\n				needsBox;\n\n			/**\n			 * This function runs after the label is added to the DOM (when the bounding box is\n			 * available), and after the text of the label is updated to detect the new bounding\n			 * box and reflect it in the border box.\n			 */\n			function updateBoxSize() {\n				var boxX,\n					boxY,\n					style = text.element.style;\n\n				bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && defined(text.textStr) && \n					text.getBBox(); //#3295 && 3514 box failure when string equals 0\n				wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;\n				wrapper.height = (height || bBox.height || 0) + 2 * padding;\n\n				// update the label-scoped y offset\n				baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;\n\n				\n				if (needsBox) {\n\n					// create the border box if it is not already present\n					if (!box) {\n						boxX = mathRound(-alignFactor * padding);\n						boxY = baseline ? -baselineOffset : 0;\n\n						wrapper.box = box = shape ?\n							renderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height, deferredAttr) :\n							renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);\n						box.attr('fill', NONE).add(wrapper);\n					}\n\n					// apply the box attributes\n					if (!box.isImg) { // #1630\n						box.attr(extend({\n							width: mathRound(wrapper.width),\n							height: mathRound(wrapper.height)\n						}, deferredAttr));\n					}\n					deferredAttr = null;\n				}\n			}\n\n			/**\n			 * This function runs after setting text or padding, but only if padding is changed\n			 */\n			function updateTextPadding() {\n				var styles = wrapper.styles,\n					textAlign = styles && styles.textAlign,\n					x = paddingLeft + padding * (1 - alignFactor),\n					y;\n\n				// determin y based on the baseline\n				y = baseline ? 0 : baselineOffset;\n\n				// compensate for alignment\n				if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {\n					x += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);\n				}\n\n				// update if anything changed\n				if (x !== text.x || y !== text.y) {\n					text.attr('x', x);\n					if (y !== UNDEFINED) {\n						// As a workaround for #3649, use translation instead of y attribute. #3649\n						// is a rendering bug in WebKit for Retina (Mac, iOS, PhantomJS) that \n						// results in duplicated text when an y attribute is used in combination \n						// with a CSS text-style.\n						text.attr(text.element.nodeName === 'SPAN' ? 'y' : 'translateY', y);\n					}\n				}\n\n				// record current values\n				text.x = x;\n				text.y = y;\n			}\n\n			/**\n			 * Set a box attribute, or defer it if the box is not yet created\n			 * @param {Object} key\n			 * @param {Object} value\n			 */\n			function boxAttr(key, value) {\n				if (box) {\n					box.attr(key, value);\n				} else {\n					deferredAttr[key] = value;\n				}\n			}\n\n			/**\n			 * After the text element is added, get the desired size of the border box\n			 * and add it before the text in the DOM.\n			 */\n			wrapper.onAdd = function () {\n				text.add(wrapper);\n				wrapper.attr({\n					text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value\n					x: x,\n					y: y\n				});\n\n				if (box && defined(anchorX)) {\n					wrapper.attr({\n						anchorX: anchorX,\n						anchorY: anchorY\n					});\n				}\n			};\n\n			/*\n			 * Add specific attribute setters.\n			 */\n\n			// only change local variables\n			wrapper.widthSetter = function (value) {\n				width = value;\n			};\n			wrapper.heightSetter = function (value) {\n				height = value;\n			};\n			wrapper.paddingSetter =  function (value) {\n				if (defined(value) && value !== padding) {\n					padding = wrapper.padding = value;\n					updateTextPadding();\n				}\n			};\n			wrapper.paddingLeftSetter =  function (value) {\n				if (defined(value) && value !== paddingLeft) {\n					paddingLeft = value;\n					updateTextPadding();\n				}\n			};\n\n\n			// change local variable and prevent setting attribute on the group\n			wrapper.alignSetter = function (value) {\n				alignFactor = { left: 0, center: 0.5, right: 1 }[value];\n			};\n\n			// apply these to the box and the text alike\n			wrapper.textSetter = function (value) {\n				if (value !== UNDEFINED) {\n					text.textSetter(value);\n				}\n				updateBoxSize();\n				updateTextPadding();\n			};\n\n			// apply these to the box but not to the text\n			wrapper['stroke-widthSetter'] = function (value, key) {\n				if (value) {\n					needsBox = true;\n				}\n				crispAdjust = value % 2 / 2;\n				boxAttr(key, value);\n			};\n			wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {\n				if (key === 'fill' && value) {\n					needsBox = true;\n				}\n				boxAttr(key, value);\n			};\n			wrapper.anchorXSetter = function (value, key) {\n				anchorX = value;\n				boxAttr(key, value + crispAdjust - wrapperX);\n			};\n			wrapper.anchorYSetter = function (value, key) {\n				anchorY = value;\n				boxAttr(key, value - wrapperY);\n			};\n\n			// rename attributes\n			wrapper.xSetter = function (value) {\n				wrapper.x = value; // for animation getter\n				if (alignFactor) {\n					value -= alignFactor * ((width || bBox.width) + padding);\n				}\n				wrapperX = mathRound(value);\n				wrapper.attr('translateX', wrapperX);\n			};\n			wrapper.ySetter = function (value) {\n				wrapperY = wrapper.y = mathRound(value);\n				wrapper.attr('translateY', wrapperY);\n			};\n\n			// Redirect certain methods to either the box or the text\n			var baseCss = wrapper.css;\n			return extend(wrapper, {\n				/**\n				 * Pick up some properties and apply them to the text instead of the wrapper\n				 */\n				css: function (styles) {\n					if (styles) {\n						var textStyles = {};\n						styles = merge(styles); // create a copy to avoid altering the original object (#537)\n						each(wrapper.textProps, function (prop) {\n							if (styles[prop] !== UNDEFINED) {\n								textStyles[prop] = styles[prop];\n								delete styles[prop];\n							}\n						});\n						text.css(textStyles);\n					}\n					return baseCss.call(wrapper, styles);\n				},\n				/**\n				 * Return the bounding box of the box, not the group\n				 */\n				getBBox: function () {\n					return {\n						width: bBox.width + 2 * padding,\n						height: bBox.height + 2 * padding,\n						x: bBox.x - padding,\n						y: bBox.y - padding\n					};\n				},\n				/**\n				 * Apply the shadow to the box\n				 */\n				shadow: function (b) {\n					if (box) {\n						box.shadow(b);\n					}\n					return wrapper;\n				},\n				/**\n				 * Destroy and release memory.\n				 */\n				destroy: function () {\n\n					// Added by button implementation\n					removeEvent(wrapper.element, 'mouseenter');\n					removeEvent(wrapper.element, 'mouseleave');\n\n					if (text) {\n						text = text.destroy();\n					}\n					if (box) {\n						box = box.destroy();\n					}\n					// Call base implementation to destroy the rest\n					SVGElement.prototype.destroy.call(wrapper);\n\n					// Release local pointers (#1298)\n					wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;\n				}\n			});\n		}\n	}; // end SVGRenderer\n\n\n	// general renderer\n	Renderer = SVGRenderer;\n	// extend SvgElement for useHTML option\n	extend(SVGElement.prototype, {\n		/**\n		 * Apply CSS to HTML elements. This is used in text within SVG rendering and\n		 * by the VML renderer\n		 */\n		htmlCss: function (styles) {\n			var wrapper = this,\n				element = wrapper.element,\n				textWidth = styles && element.tagName === 'SPAN' && styles.width;\n\n			if (textWidth) {\n				delete styles.width;\n				wrapper.textWidth = textWidth;\n				wrapper.updateTransform();\n			}\n			if (styles && styles.textOverflow === 'ellipsis') {\n				styles.whiteSpace = 'nowrap';\n				styles.overflow = 'hidden';\n			}\n			wrapper.styles = extend(wrapper.styles, styles);\n			css(wrapper.element, styles);\n\n			return wrapper;\n		},\n\n		/**\n		 * VML and useHTML method for calculating the bounding box based on offsets\n		 * @param {Boolean} refresh Whether to force a fresh value from the DOM or to\n		 * use the cached value\n		 *\n		 * @return {Object} A hash containing values for x, y, width and height\n		 */\n\n		htmlGetBBox: function () {\n			var wrapper = this,\n				element = wrapper.element;\n\n			// faking getBBox in exported SVG in legacy IE\n			// faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)\n			if (element.nodeName === 'text') {\n				element.style.position = ABSOLUTE;\n			}\n\n			return {\n				x: element.offsetLeft,\n				y: element.offsetTop,\n				width: element.offsetWidth,\n				height: element.offsetHeight\n			};\n		},\n\n		/**\n		 * VML override private method to update elements based on internal\n		 * properties based on SVG transform\n		 */\n		htmlUpdateTransform: function () {\n			// aligning non added elements is expensive\n			if (!this.added) {\n				this.alignOnAdd = true;\n				return;\n			}\n\n			var wrapper = this,\n				renderer = wrapper.renderer,\n				elem = wrapper.element,\n				translateX = wrapper.translateX || 0,\n				translateY = wrapper.translateY || 0,\n				x = wrapper.x || 0,\n				y = wrapper.y || 0,\n				align = wrapper.textAlign || 'left',\n				alignCorrection = { left: 0, center: 0.5, right: 1 }[align],\n				shadows = wrapper.shadows,\n				styles = wrapper.styles;\n\n			// apply translate\n			css(elem, {\n				marginLeft: translateX,\n				marginTop: translateY\n			});\n			if (shadows) { // used in labels/tooltip\n				each(shadows, function (shadow) {\n					css(shadow, {\n						marginLeft: translateX + 1,\n						marginTop: translateY + 1\n					});\n				});\n			}\n\n			// apply inversion\n			if (wrapper.inverted) { // wrapper is a group\n				each(elem.childNodes, function (child) {\n					renderer.invertChild(child, elem);\n				});\n			}\n\n			if (elem.tagName === 'SPAN') {\n\n				var width,\n					rotation = wrapper.rotation,\n					baseline,\n					textWidth = pInt(wrapper.textWidth),\n					currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(',');\n\n				if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed\n\n\n					baseline = renderer.fontMetrics(elem.style.fontSize).b;\n\n					// Renderer specific handling of span rotation\n					if (defined(rotation)) {\n						wrapper.setSpanRotation(rotation, alignCorrection, baseline);\n					}\n\n					width = pick(wrapper.elemWidth, elem.offsetWidth);\n\n					// Update textWidth\n					if (width > textWidth && /[ \\-]/.test(elem.textContent || elem.innerText)) { // #983, #1254\n						css(elem, {\n							width: textWidth + PX,\n							display: 'block',\n							whiteSpace: (styles && styles.whiteSpace) || 'normal' // #3331\n						});\n						width = textWidth;\n					}\n\n					wrapper.getSpanCorrection(width, baseline, alignCorrection, rotation, align);\n				}\n\n				// apply position with correction\n				css(elem, {\n					left: (x + (wrapper.xCorr || 0)) + PX,\n					top: (y + (wrapper.yCorr || 0)) + PX\n				});\n\n				// force reflow in webkit to apply the left and top on useHTML element (#1249)\n				if (isWebKit) {\n					baseline = elem.offsetHeight; // assigned to baseline for JSLint purpose\n				}\n\n				// record current text transform\n				wrapper.cTT = currentTextTransform;\n			}\n		},\n\n		/**\n		 * Set the rotation of an individual HTML span\n		 */\n		setSpanRotation: function (rotation, alignCorrection, baseline) {\n			var rotationStyle = {},\n				cssTransformKey = isIE ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : isOpera ? '-o-transform' : '';\n\n			rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';\n			rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';\n			css(this.element, rotationStyle);\n		},\n\n		/**\n		 * Get the correction in X and Y positioning as the element is rotated.\n		 */\n		getSpanCorrection: function (width, baseline, alignCorrection) {\n			this.xCorr = -width * alignCorrection;\n			this.yCorr = -baseline;\n		}\n	});\n\n	// Extend SvgRenderer for useHTML option.\n	extend(SVGRenderer.prototype, {\n		/**\n		 * Create HTML text node. This is used by the VML renderer as well as the SVG\n		 * renderer through the useHTML option.\n		 *\n		 * @param {String} str\n		 * @param {Number} x\n		 * @param {Number} y\n		 */\n		html: function (str, x, y) {\n			var wrapper = this.createElement('span'),\n				element = wrapper.element,\n				renderer = wrapper.renderer;\n\n			// Text setter\n			wrapper.textSetter = function (value) {\n				if (value !== element.innerHTML) {\n					delete this.bBox;\n				}\n				element.innerHTML = this.textStr = value;\n			};\n\n			// Various setters which rely on update transform\n			wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {\n				if (key === 'align') {\n					key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.\n				}\n				wrapper[key] = value;\n				wrapper.htmlUpdateTransform();\n			};\n\n			// Set the default attributes\n			wrapper.attr({\n					text: str,\n					x: mathRound(x),\n					y: mathRound(y)\n				})\n				.css({\n					position: ABSOLUTE,\n					fontFamily: this.style.fontFamily,\n					fontSize: this.style.fontSize\n				});\n\n			// Keep the whiteSpace style outside the wrapper.styles collection\n			element.style.whiteSpace = 'nowrap';\n\n			// Use the HTML specific .css method\n			wrapper.css = wrapper.htmlCss;\n\n			// This is specific for HTML within SVG\n			if (renderer.isSVG) {\n				wrapper.add = function (svgGroupWrapper) {\n\n					var htmlGroup,\n						container = renderer.box.parentNode,\n						parentGroup,\n						parents = [];\n\n					this.parentGroup = svgGroupWrapper;\n\n					// Create a mock group to hold the HTML elements\n					if (svgGroupWrapper) {\n						htmlGroup = svgGroupWrapper.div;\n						if (!htmlGroup) {\n\n							// Read the parent chain into an array and read from top down\n							parentGroup = svgGroupWrapper;\n							while (parentGroup) {\n\n								parents.push(parentGroup);\n\n								// Move up to the next parent group\n								parentGroup = parentGroup.parentGroup;\n							}\n\n							// Ensure dynamically updating position when any parent is translated\n							each(parents.reverse(), function (parentGroup) {\n								var htmlGroupStyle;\n\n								// Create a HTML div and append it to the parent div to emulate\n								// the SVG group structure\n								htmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, {\n									className: attr(parentGroup.element, 'class')\n								}, {\n									position: ABSOLUTE,\n									left: (parentGroup.translateX || 0) + PX,\n									top: (parentGroup.translateY || 0) + PX\n								}, htmlGroup || container); // the top group is appended to container\n\n								// Shortcut\n								htmlGroupStyle = htmlGroup.style;\n\n								// Set listeners to update the HTML div's position whenever the SVG group\n								// position is changed\n								extend(parentGroup, {\n									translateXSetter: function (value, key) {\n										htmlGroupStyle.left = value + PX;\n										parentGroup[key] = value;\n										parentGroup.doTransform = true;\n									},\n									translateYSetter: function (value, key) {\n										htmlGroupStyle.top = value + PX;\n										parentGroup[key] = value;\n										parentGroup.doTransform = true;\n									},\n									visibilitySetter: function (value, key) {\n										htmlGroupStyle[key] = value;\n									}\n								});\n							});\n\n						}\n					} else {\n						htmlGroup = container;\n					}\n\n					htmlGroup.appendChild(element);\n\n					// Shared with VML:\n					wrapper.added = true;\n					if (wrapper.alignOnAdd) {\n						wrapper.htmlUpdateTransform();\n					}\n\n					return wrapper;\n				};\n			}\n			return wrapper;\n		}\n	});\n\n	/* ****************************************************************************\n	 *                                                                            *\n	 * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *\n	 *                                                                            *\n	 * For applications and websites that don't need IE support, like platform    *\n	 * targeted mobile apps and web apps, this code can be removed.               *\n	 *                                                                            *\n	 *****************************************************************************/\n\n	/**\n	 * @constructor\n	 */\n	var VMLRenderer, VMLElement;\n	if (!hasSVG && !useCanVG) {\n\n	/**\n	 * The VML element wrapper.\n	 */\n	VMLElement = {\n\n		/**\n		 * Initialize a new VML element wrapper. It builds the markup as a string\n		 * to minimize DOM traffic.\n		 * @param {Object} renderer\n		 * @param {Object} nodeName\n		 */\n		init: function (renderer, nodeName) {\n			var wrapper = this,\n				markup =  ['<', nodeName, ' filled=\"f\" stroked=\"f\"'],\n				style = ['position: ', ABSOLUTE, ';'],\n				isDiv = nodeName === DIV;\n\n			// divs and shapes need size\n			if (nodeName === 'shape' || isDiv) {\n				style.push('left:0;top:0;width:1px;height:1px;');\n			}\n			style.push('visibility: ', isDiv ? HIDDEN : VISIBLE);\n\n			markup.push(' style=\"', style.join(''), '\"/>');\n\n			// create element with default attributes and style\n			if (nodeName) {\n				markup = isDiv || nodeName === 'span' || nodeName === 'img' ?\n					markup.join('')\n					: renderer.prepVML(markup);\n				wrapper.element = createElement(markup);\n			}\n\n			wrapper.renderer = renderer;\n		},\n\n		/**\n		 * Add the node to the given parent\n		 * @param {Object} parent\n		 */\n		add: function (parent) {\n			var wrapper = this,\n				renderer = wrapper.renderer,\n				element = wrapper.element,\n				box = renderer.box,\n				inverted = parent && parent.inverted,\n\n				// get the parent node\n				parentNode = parent ?\n					parent.element || parent :\n					box;\n\n\n			// if the parent group is inverted, apply inversion on all children\n			if (inverted) { // only on groups\n				renderer.invertChild(element, parentNode);\n			}\n\n			// append it\n			parentNode.appendChild(element);\n\n			// align text after adding to be able to read offset\n			wrapper.added = true;\n			if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {\n				wrapper.updateTransform();\n			}\n\n			// fire an event for internal hooks\n			if (wrapper.onAdd) {\n				wrapper.onAdd();\n			}\n\n			return wrapper;\n		},\n\n		/**\n		 * VML always uses htmlUpdateTransform\n		 */\n		updateTransform: SVGElement.prototype.htmlUpdateTransform,\n\n		/**\n		 * Set the rotation of a span with oldIE's filter\n		 */\n		setSpanRotation: function () {\n			// Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented\n			// but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+\n			// has support for CSS3 transform. The getBBox method also needs to be updated\n			// to compensate for the rotation, like it currently does for SVG.\n			// Test case: http://jsfiddle.net/highcharts/Ybt44/\n\n			var rotation = this.rotation,\n				costheta = mathCos(rotation * deg2rad),\n				sintheta = mathSin(rotation * deg2rad);\n						\n			css(this.element, {\n				filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,\n					', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,\n					', sizingMethod=\\'auto expand\\')'].join('') : NONE\n			});\n		},\n\n		/**\n		 * Get the positioning correction for the span after rotating. \n		 */\n		getSpanCorrection: function (width, baseline, alignCorrection, rotation, align) {\n\n			var costheta = rotation ? mathCos(rotation * deg2rad) : 1,\n				sintheta = rotation ? mathSin(rotation * deg2rad) : 0,\n				height = pick(this.elemHeight, this.element.offsetHeight),\n				quad,\n				nonLeft = align && align !== 'left';\n\n			// correct x and y\n			this.xCorr = costheta < 0 && -width;\n			this.yCorr = sintheta < 0 && -height;\n\n			// correct for baseline and corners spilling out after rotation\n			quad = costheta * sintheta < 0;\n			this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);\n			this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);\n			// correct for the length/height of the text\n			if (nonLeft) {\n				this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);\n				if (rotation) {\n					this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);\n				}\n				css(this.element, {\n					textAlign: align\n				});\n			}\n		},\n\n		/**\n		 * Converts a subset of an SVG path definition to its VML counterpart. Takes an array\n		 * as the parameter and returns a string.\n		 */\n		pathToVML: function (value) {\n			// convert paths\n			var i = value.length,\n				path = [];\n\n			while (i--) {\n\n				// Multiply by 10 to allow subpixel precision.\n				// Substracting half a pixel seems to make the coordinates\n				// align with SVG, but this hasn't been tested thoroughly\n				if (isNumber(value[i])) {\n					path[i] = mathRound(value[i] * 10) - 5;\n				} else if (value[i] === 'Z') { // close the path\n					path[i] = 'x';\n				} else {\n					path[i] = value[i];\n\n					// When the start X and end X coordinates of an arc are too close,\n					// they are rounded to the same value above. In this case, substract or \n					// add 1 from the end X and Y positions. #186, #760, #1371, #1410.\n					if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {\n						// Start and end X\n						if (path[i + 5] === path[i + 7]) {\n							path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;\n						}\n						// Start and end Y\n						if (path[i + 6] === path[i + 8]) {\n							path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;\n						}\n					}\n				}\n			}\n\n			\n			// Loop up again to handle path shortcuts (#2132)\n			/*while (i++ < path.length) {\n				if (path[i] === 'H') { // horizontal line to\n					path[i] = 'L';\n					path.splice(i + 2, 0, path[i - 1]);\n				} else if (path[i] === 'V') { // vertical line to\n					path[i] = 'L';\n					path.splice(i + 1, 0, path[i - 2]);\n				}\n			}*/\n			return path.join(' ') || 'x';\n		},\n\n		/**\n		 * Set the element's clipping to a predefined rectangle\n		 *\n		 * @param {String} id The id of the clip rectangle\n		 */\n		clip: function (clipRect) {\n			var wrapper = this,\n				clipMembers,\n				cssRet;\n\n			if (clipRect) {\n				clipMembers = clipRect.members;\n				erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)\n				clipMembers.push(wrapper);\n				wrapper.destroyClip = function () {\n					erase(clipMembers, wrapper);\n				};\n				cssRet = clipRect.getCSS(wrapper);\n\n			} else {\n				if (wrapper.destroyClip) {\n					wrapper.destroyClip();\n				}\n				cssRet = { clip: docMode8 ? 'inherit' : 'rect(auto)' }; // #1214\n			}\n\n			return wrapper.css(cssRet);\n\n		},\n\n		/**\n		 * Set styles for the element\n		 * @param {Object} styles\n		 */\n		css: SVGElement.prototype.htmlCss,\n\n		/**\n		 * Removes a child either by removeChild or move to garbageBin.\n		 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n		 */\n		safeRemoveChild: function (element) {\n			// discardElement will detach the node from its parent before attaching it\n			// to the garbage bin. Therefore it is important that the node is attached and have parent.\n			if (element.parentNode) {\n				discardElement(element);\n			}\n		},\n\n		/**\n		 * Extend element.destroy by removing it from the clip members array\n		 */\n		destroy: function () {\n			if (this.destroyClip) {\n				this.destroyClip();\n			}\n\n			return SVGElement.prototype.destroy.apply(this);\n		},\n\n		/**\n		 * Add an event listener. VML override for normalizing event parameters.\n		 * @param {String} eventType\n		 * @param {Function} handler\n		 */\n		on: function (eventType, handler) {\n			// simplest possible event model for internal use\n			this.element['on' + eventType] = function () {\n				var evt = win.event;\n				evt.target = evt.srcElement;\n				handler(evt);\n			};\n			return this;\n		},\n\n		/**\n		 * In stacked columns, cut off the shadows so that they don't overlap\n		 */\n		cutOffPath: function (path, length) {\n\n			var len;\n\n			path = path.split(/[ ,]/);\n			len = path.length;\n\n			if (len === 9 || len === 11) {\n				path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;\n			}\n			return path.join(' ');\n		},\n\n		/**\n		 * Apply a drop shadow by copying elements and giving them different strokes\n		 * @param {Boolean|Object} shadowOptions\n		 */\n		shadow: function (shadowOptions, group, cutOff) {\n			var shadows = [],\n				i,\n				element = this.element,\n				renderer = this.renderer,\n				shadow,\n				elemStyle = element.style,\n				markup,\n				path = element.path,\n				strokeWidth,\n				modifiedPath,\n				shadowWidth,\n				shadowElementOpacity;\n\n			// some times empty paths are not strings\n			if (path && typeof path.value !== 'string') {\n				path = 'x';\n			}\n			modifiedPath = path;\n\n			if (shadowOptions) {\n				shadowWidth = pick(shadowOptions.width, 3);\n				shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n				for (i = 1; i <= 3; i++) {\n\n					strokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n\n					// Cut off shadows for stacked column items\n					if (cutOff) {\n						modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);\n					}\n\n					markup = ['<shape isShadow=\"true\" strokeweight=\"', strokeWidth,\n						'\" filled=\"false\" path=\"', modifiedPath,\n						'\" coordsize=\"10 10\" style=\"', element.style.cssText, '\" />'];\n\n					shadow = createElement(renderer.prepVML(markup),\n						null, {\n							left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),\n							top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)\n						}\n					);\n					if (cutOff) {\n						shadow.cutOff = strokeWidth + 1;\n					}\n\n					// apply the opacity\n					markup = ['<stroke color=\"', shadowOptions.color || 'black', '\" opacity=\"', shadowElementOpacity * i, '\"/>'];\n					createElement(renderer.prepVML(markup), null, null, shadow);\n\n\n					// insert it\n					if (group) {\n						group.element.appendChild(shadow);\n					} else {\n						element.parentNode.insertBefore(shadow, element);\n					}\n\n					// record it\n					shadows.push(shadow);\n\n				}\n\n				this.shadows = shadows;\n			}\n			return this;\n		},\n		updateShadows: noop, // Used in SVG only\n\n		setAttr: function (key, value) {\n			if (docMode8) { // IE8 setAttribute bug\n				this.element[key] = value;\n			} else {\n				this.element.setAttribute(key, value);\n			}\n		},\n		classSetter: function (value) {\n			// IE8 Standards mode has problems retrieving the className unless set like this\n			this.element.className = value;\n		},\n		dashstyleSetter: function (value, key, element) {\n			var strokeElem = element.getElementsByTagName('stroke')[0] ||\n				createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);\n			strokeElem[key] = value || 'solid';\n			this[key] = value; /* because changing stroke-width will change the dash length\n				and cause an epileptic effect */\n		},\n		dSetter: function (value, key, element) {\n			var i,\n				shadows = this.shadows;\n			value = value || [];\n			this.d = value.join && value.join(' '); // used in getter for animation\n\n			element.path = value = this.pathToVML(value);\n\n			// update shadows\n			if (shadows) {\n				i = shadows.length;\n				while (i--) {\n					shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;\n				}\n			}\n			this.setAttr(key, value);\n		},\n		fillSetter: function (value, key, element) {\n			var nodeName = element.nodeName;\n			if (nodeName === 'SPAN') { // text color\n				element.style.color = value;\n			} else if (nodeName !== 'IMG') { // #1336\n				element.filled = value !== NONE;\n				this.setAttr('fillcolor', this.renderer.color(value, element, key, this));\n			}\n		},\n		opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts\n		rotationSetter: function (value, key, element) {\n			var style = element.style;\n			this[key] = style[key] = value; // style is for #1873\n\n			// Correction for the 1x1 size of the shape container. Used in gauge needles.\n			style.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;\n			style.top = mathRound(mathCos(value * deg2rad)) + PX;\n		},\n		strokeSetter: function (value, key, element) {\n			this.setAttr('strokecolor', this.renderer.color(value, element, key));\n		},\n		'stroke-widthSetter': function (value, key, element) {\n			element.stroked = !!value; // VML \"stroked\" attribute\n			this[key] = value; // used in getter, issue #113\n			if (isNumber(value)) {\n				value += PX;\n			}\n			this.setAttr('strokeweight', value);\n		},\n		titleSetter: function (value, key) {\n			this.setAttr(key, value);\n		},\n		visibilitySetter: function (value, key, element) {\n\n			// Handle inherited visibility\n			if (value === 'inherit') {\n				value = VISIBLE;\n			}\n			\n			// Let the shadow follow the main element\n			if (this.shadows) {\n				each(this.shadows, function (shadow) {\n					shadow.style[key] = value;\n				});\n			}\n\n			// Instead of toggling the visibility CSS property, move the div out of the viewport.\n			// This works around #61 and #586\n			if (element.nodeName === 'DIV') {\n				value = value === HIDDEN ? '-999em' : 0;\n\n				// In order to redraw, IE7 needs the div to be visible when tucked away\n				// outside the viewport. So the visibility is actually opposite of\n				// the expected value. This applies to the tooltip only.\n				if (!docMode8) {\n					element.style[key] = value ? VISIBLE : HIDDEN;\n				}\n				key = 'top';\n			}\n			element.style[key] = value;\n		},\n		xSetter: function (value, key, element) {\n			this[key] = value; // used in getter\n\n			if (key === 'x') {\n				key = 'left';\n			} else if (key === 'y') {\n				key = 'top';\n			}/* else {\n				value = mathMax(0, value); // don't set width or height below zero (#311)\n			}*/\n\n			// clipping rectangle special\n			if (this.updateClipping) {\n				this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'\n				this.updateClipping();\n			} else {\n				// normal\n				element.style[key] = value;\n			}\n		},\n		zIndexSetter: function (value, key, element) {\n			element.style[key] = value;\n		}\n	};\n	Highcharts.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);\n\n	// Some shared setters\n	VMLElement.prototype.ySetter =\n		VMLElement.prototype.widthSetter = \n		VMLElement.prototype.heightSetter = \n		VMLElement.prototype.xSetter;\n\n\n	/**\n	 * The VML renderer\n	 */\n	var VMLRendererExtension = { // inherit SVGRenderer\n\n		Element: VMLElement,\n		isIE8: userAgent.indexOf('MSIE 8.0') > -1,\n\n\n		/**\n		 * Initialize the VMLRenderer\n		 * @param {Object} container\n		 * @param {Number} width\n		 * @param {Number} height\n		 */\n		init: function (container, width, height, style) {\n			var renderer = this,\n				boxWrapper,\n				box,\n				css;\n\n			renderer.alignedObjects = [];\n\n			boxWrapper = renderer.createElement(DIV)\n				.css(extend(this.getStyle(style), { position: RELATIVE}));\n			box = boxWrapper.element;\n			container.appendChild(boxWrapper.element);\n\n\n			// generate the containing box\n			renderer.isVML = true;\n			renderer.box = box;\n			renderer.boxWrapper = boxWrapper;\n			renderer.cache = {};\n\n\n			renderer.setSize(width, height, false);\n\n			// The only way to make IE6 and IE7 print is to use a global namespace. However,\n			// with IE8 the only way to make the dynamic shapes visible in screen and print mode\n			// seems to be to add the xmlns attribute and the behaviour style inline.\n			if (!doc.namespaces.hcv) {\n\n				doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');\n\n				// Setup default CSS (#2153, #2368, #2384)\n				css = 'hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke' +\n					'{ behavior:url(#default#VML); display: inline-block; } ';\n				try {\n					doc.createStyleSheet().cssText = css;\n				} catch (e) {\n					doc.styleSheets[0].cssText += css;\n				}\n\n			}\n		},\n\n\n		/**\n		 * Detect whether the renderer is hidden. This happens when one of the parent elements\n		 * has display: none\n		 */\n		isHidden: function () {\n			return !this.box.offsetWidth;\n		},\n\n		/**\n		 * Define a clipping rectangle. In VML it is accomplished by storing the values\n		 * for setting the CSS style to all associated members.\n		 *\n		 * @param {Number} x\n		 * @param {Number} y\n		 * @param {Number} width\n		 * @param {Number} height\n		 */\n		clipRect: function (x, y, width, height) {\n\n			// create a dummy element\n			var clipRect = this.createElement(),\n				isObj = isObject(x);\n\n			// mimic a rectangle with its style object for automatic updating in attr\n			return extend(clipRect, {\n				members: [],\n				count: 0,\n				left: (isObj ? x.x : x) + 1,\n				top: (isObj ? x.y : y) + 1,\n				width: (isObj ? x.width : width) - 1,\n				height: (isObj ? x.height : height) - 1,\n				getCSS: function (wrapper) {\n					var element = wrapper.element,\n						nodeName = element.nodeName,\n						isShape = nodeName === 'shape',\n						inverted = wrapper.inverted,\n						rect = this,\n						top = rect.top - (isShape ? element.offsetTop : 0),\n						left = rect.left,\n						right = left + rect.width,\n						bottom = top + rect.height,\n						ret = {\n							clip: 'rect(' +\n								mathRound(inverted ? left : top) + 'px,' +\n								mathRound(inverted ? bottom : right) + 'px,' +\n								mathRound(inverted ? right : bottom) + 'px,' +\n								mathRound(inverted ? top : left) + 'px)'\n						};\n\n					// issue 74 workaround\n					if (!inverted && docMode8 && nodeName === 'DIV') {\n						extend(ret, {\n							width: right + PX,\n							height: bottom + PX\n						});\n					}\n					return ret;\n				},\n\n				// used in attr and animation to update the clipping of all members\n				updateClipping: function () {\n					each(clipRect.members, function (member) {\n						if (member.element) { // Deleted series, like in stock/members/series-remove demo. Should be removed from members, but this will do.\n							member.css(clipRect.getCSS(member));\n						}\n					});\n				}\n			});\n\n		},\n\n\n		/**\n		 * Take a color and return it if it's a string, make it a gradient if it's a\n		 * gradient configuration object, and apply opacity.\n		 *\n		 * @param {Object} color The color or config object\n		 */\n		color: function (color, elem, prop, wrapper) {\n			var renderer = this,\n				colorObject,\n				regexRgba = /^rgba/,\n				markup,\n				fillType,\n				ret = NONE;\n\n			// Check for linear or radial gradient\n			if (color && color.linearGradient) {\n				fillType = 'gradient';\n			} else if (color && color.radialGradient) {\n				fillType = 'pattern';\n			}\n\n\n			if (fillType) {\n\n				var stopColor,\n					stopOpacity,\n					gradient = color.linearGradient || color.radialGradient,\n					x1,\n					y1,\n					x2,\n					y2,\n					opacity1,\n					opacity2,\n					color1,\n					color2,\n					fillAttr = '',\n					stops = color.stops,\n					firstStop,\n					lastStop,\n					colors = [],\n					addFillNode = function () {\n						// Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2\n						// are reversed.\n						markup = ['<fill colors=\"' + colors.join(',') + '\" opacity=\"', opacity2, '\" o:opacity2=\"', opacity1,\n							'\" type=\"', fillType, '\" ', fillAttr, 'focus=\"100%\" method=\"any\" />'];\n						createElement(renderer.prepVML(markup), null, null, elem);\n					};\n\n				// Extend from 0 to 1\n				firstStop = stops[0];\n				lastStop = stops[stops.length - 1];\n				if (firstStop[0] > 0) {\n					stops.unshift([\n						0,\n						firstStop[1]\n					]);\n				}\n				if (lastStop[0] < 1) {\n					stops.push([\n						1,\n						lastStop[1]\n					]);\n				}\n\n				// Compute the stops\n				each(stops, function (stop, i) {\n					if (regexRgba.test(stop[1])) {\n						colorObject = Color(stop[1]);\n						stopColor = colorObject.get('rgb');\n						stopOpacity = colorObject.get('a');\n					} else {\n						stopColor = stop[1];\n						stopOpacity = 1;\n					}\n\n					// Build the color attribute\n					colors.push((stop[0] * 100) + '% ' + stopColor);\n\n					// Only start and end opacities are allowed, so we use the first and the last\n					if (!i) {\n						opacity1 = stopOpacity;\n						color2 = stopColor;\n					} else {\n						opacity2 = stopOpacity;\n						color1 = stopColor;\n					}\n				});\n\n				// Apply the gradient to fills only.\n				if (prop === 'fill') {\n\n					// Handle linear gradient angle\n					if (fillType === 'gradient') {\n						x1 = gradient.x1 || gradient[0] || 0;\n						y1 = gradient.y1 || gradient[1] || 0;\n						x2 = gradient.x2 || gradient[2] || 0;\n						y2 = gradient.y2 || gradient[3] || 0;\n						fillAttr = 'angle=\"' + (90  - math.atan(\n							(y2 - y1) / // y vector\n							(x2 - x1) // x vector\n							) * 180 / mathPI) + '\"';\n\n						addFillNode();\n\n					// Radial (circular) gradient\n					} else {\n\n						var r = gradient.r,\n							sizex = r * 2,\n							sizey = r * 2,\n							cx = gradient.cx,\n							cy = gradient.cy,\n							radialReference = elem.radialReference,\n							bBox,\n							applyRadialGradient = function () {\n								if (radialReference) {\n									bBox = wrapper.getBBox();\n									cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;\n									cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;\n									sizex *= radialReference[2] / bBox.width;\n									sizey *= radialReference[2] / bBox.height;\n								}\n								fillAttr = 'src=\"' + defaultOptions.global.VMLRadialGradientURL + '\" ' +\n									'size=\"' + sizex + ',' + sizey + '\" ' +\n									'origin=\"0.5,0.5\" ' +\n									'position=\"' + cx + ',' + cy + '\" ' +\n									'color2=\"' + color2 + '\" ';\n\n								addFillNode();\n							};\n\n						// Apply radial gradient\n						if (wrapper.added) {\n							applyRadialGradient();\n						} else {\n							// We need to know the bounding box to get the size and position right\n							wrapper.onAdd = applyRadialGradient;\n						}\n\n						// The fill element's color attribute is broken in IE8 standards mode, so we\n						// need to set the parent shape's fillcolor attribute instead.\n						ret = color1;\n					}\n\n				// Gradients are not supported for VML stroke, return the first color. #722.\n				} else {\n					ret = stopColor;\n				}\n\n			// if the color is an rgba color, split it and add a fill node\n			// to hold the opacity component\n			} else if (regexRgba.test(color) && elem.tagName !== 'IMG') {\n\n				colorObject = Color(color);\n\n				markup = ['<', prop, ' opacity=\"', colorObject.get('a'), '\"/>'];\n				createElement(this.prepVML(markup), null, null, elem);\n\n				ret = colorObject.get('rgb');\n\n\n			} else {\n				var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node\n				if (propNodes.length) {\n					propNodes[0].opacity = 1;\n					propNodes[0].type = 'solid';\n				}\n				ret = color;\n			}\n\n			return ret;\n		},\n\n		/**\n		 * Take a VML string and prepare it for either IE8 or IE6/IE7.\n		 * @param {Array} markup A string array of the VML markup to prepare\n		 */\n		prepVML: function (markup) {\n			var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',\n				isIE8 = this.isIE8;\n\n			markup = markup.join('');\n\n			if (isIE8) { // add xmlns and style inline\n				markup = markup.replace('/>', ' xmlns=\"urn:schemas-microsoft-com:vml\" />');\n				if (markup.indexOf('style=\"') === -1) {\n					markup = markup.replace('/>', ' style=\"' + vmlStyle + '\" />');\n				} else {\n					markup = markup.replace('style=\"', 'style=\"' + vmlStyle);\n				}\n\n			} else { // add namespace\n				markup = markup.replace('<', '<hcv:');\n			}\n\n			return markup;\n		},\n\n		/**\n		 * Create rotated and aligned text\n		 * @param {String} str\n		 * @param {Number} x\n		 * @param {Number} y\n		 */\n		text: SVGRenderer.prototype.html,\n\n		/**\n		 * Create and return a path element\n		 * @param {Array} path\n		 */\n		path: function (path) {\n			var attr = {\n				// subpixel precision down to 0.1 (width and height = 1px)\n				coordsize: '10 10'\n			};\n			if (isArray(path)) {\n				attr.d = path;\n			} else if (isObject(path)) { // attributes\n				extend(attr, path);\n			}\n			// create the shape\n			return this.createElement('shape').attr(attr);\n		},\n\n		/**\n		 * Create and return a circle element. In VML circles are implemented as\n		 * shapes, which is faster than v:oval\n		 * @param {Number} x\n		 * @param {Number} y\n		 * @param {Number} r\n		 */\n		circle: function (x, y, r) {\n			var circle = this.symbol('circle');\n			if (isObject(x)) {\n				r = x.r;\n				y = x.y;\n				x = x.x;\n			}\n			circle.isCircle = true; // Causes x and y to mean center (#1682)\n			circle.r = r;\n			return circle.attr({ x: x, y: y });\n		},\n\n		/**\n		 * Create a group using an outer div and an inner v:group to allow rotating\n		 * and flipping. A simple v:group would have problems with positioning\n		 * child HTML elements and CSS clip.\n		 *\n		 * @param {String} name The name of the group\n		 */\n		g: function (name) {\n			var wrapper,\n				attribs;\n\n			// set the class name\n			if (name) {\n				attribs = { 'className': PREFIX + name, 'class': PREFIX + name };\n			}\n\n			// the div to hold HTML and clipping\n			wrapper = this.createElement(DIV).attr(attribs);\n\n			return wrapper;\n		},\n\n		/**\n		 * VML override to create a regular HTML image\n		 * @param {String} src\n		 * @param {Number} x\n		 * @param {Number} y\n		 * @param {Number} width\n		 * @param {Number} height\n		 */\n		image: function (src, x, y, width, height) {\n			var obj = this.createElement('img')\n				.attr({ src: src });\n\n			if (arguments.length > 1) {\n				obj.attr({\n					x: x,\n					y: y,\n					width: width,\n					height: height\n				});\n			}\n			return obj;\n		},\n\n		/**\n		 * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems\n		 */\n		createElement: function (nodeName) {\n			return nodeName === 'rect' ? this.symbol(nodeName) : SVGRenderer.prototype.createElement.call(this, nodeName);	\n		},\n\n		/**\n		 * In the VML renderer, each child of an inverted div (group) is inverted\n		 * @param {Object} element\n		 * @param {Object} parentNode\n		 */\n		invertChild: function (element, parentNode) {\n			var ren = this,\n				parentStyle = parentNode.style,\n				imgStyle = element.tagName === 'IMG' && element.style; // #1111\n\n			css(element, {\n				flip: 'x',\n				left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),\n				top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),\n				rotation: -90\n			});\n\n			// Recursively invert child elements, needed for nested composite shapes like box plots and error bars. #1680, #1806.\n			each(element.childNodes, function (child) {\n				ren.invertChild(child, element);\n			});\n		},\n\n		/**\n		 * Symbol definitions that override the parent SVG renderer's symbols\n		 *\n		 */\n		symbols: {\n			// VML specific arc function\n			arc: function (x, y, w, h, options) {\n				var start = options.start,\n					end = options.end,\n					radius = options.r || w || h,\n					innerRadius = options.innerR,\n					cosStart = mathCos(start),\n					sinStart = mathSin(start),\n					cosEnd = mathCos(end),\n					sinEnd = mathSin(end),\n					ret;\n\n				if (end - start === 0) { // no angle, don't show it.\n					return ['x'];\n				}\n\n				ret = [\n					'wa', // clockwise arc to\n					x - radius, // left\n					y - radius, // top\n					x + radius, // right\n					y + radius, // bottom\n					x + radius * cosStart, // start x\n					y + radius * sinStart, // start y\n					x + radius * cosEnd, // end x\n					y + radius * sinEnd  // end y\n				];\n\n				if (options.open && !innerRadius) {\n					ret.push(\n						'e',\n						M,\n						x,// - innerRadius,\n						y// - innerRadius\n					);\n				}\n\n				ret.push(\n					'at', // anti clockwise arc to\n					x - innerRadius, // left\n					y - innerRadius, // top\n					x + innerRadius, // right\n					y + innerRadius, // bottom\n					x + innerRadius * cosEnd, // start x\n					y + innerRadius * sinEnd, // start y\n					x + innerRadius * cosStart, // end x\n					y + innerRadius * sinStart, // end y\n					'x', // finish path\n					'e' // close\n				);\n\n				ret.isArc = true;\n				return ret;\n\n			},\n			// Add circle symbol path. This performs significantly faster than v:oval.\n			circle: function (x, y, w, h, wrapper) {\n\n				if (wrapper) {\n					w = h = 2 * wrapper.r;\n				}\n\n				// Center correction, #1682\n				if (wrapper && wrapper.isCircle) {\n					x -= w / 2;\n					y -= h / 2;\n				}\n\n				// Return the path\n				return [\n					'wa', // clockwisearcto\n					x, // left\n					y, // top\n					x + w, // right\n					y + h, // bottom\n					x + w, // start x\n					y + h / 2,     // start y\n					x + w, // end x\n					y + h / 2,     // end y\n					//'x', // finish path\n					'e' // close\n				];\n			},\n			/**\n			 * Add rectangle symbol path which eases rotation and omits arcsize problems\n			 * compared to the built-in VML roundrect shape. When borders are not rounded,\n			 * use the simpler square path, else use the callout path without the arrow.\n			 */\n			rect: function (x, y, w, h, options) {\n				return SVGRenderer.prototype.symbols[\n					!defined(options) || !options.r ? 'square' : 'callout'\n				].call(0, x, y, w, h, options);\n			}\n		}\n	};\n	Highcharts.VMLRenderer = VMLRenderer = function () {\n		this.init.apply(this, arguments);\n	};\n	VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);\n\n		// general renderer\n		Renderer = VMLRenderer;\n	}\n\n	// This method is used with exporting in old IE, when emulating SVG (see #2314)\n	SVGRenderer.prototype.measureSpanWidth = function (text, styles) {\n		var measuringSpan = doc.createElement('span'),\n			offsetWidth,\n		textNode = doc.createTextNode(text);\n\n		measuringSpan.appendChild(textNode);\n		css(measuringSpan, styles);\n		this.box.appendChild(measuringSpan);\n		offsetWidth = measuringSpan.offsetWidth;\n		discardElement(measuringSpan); // #2463\n		return offsetWidth;\n	};\n\n\n	/* ****************************************************************************\n	 *                                                                            *\n	 * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *\n	 *                                                                            *\n	 *****************************************************************************/\n	/* ****************************************************************************\n	 *                                                                            *\n	 * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *\n	 * TARGETING THAT SYSTEM.                                                     *\n	 *                                                                            *\n	 *****************************************************************************/\n	var CanVGRenderer,\n		CanVGController;\n\n	if (useCanVG) {\n		/**\n		 * The CanVGRenderer is empty from start to keep the source footprint small.\n		 * When requested, the CanVGController downloads the rest of the source packaged\n		 * together with the canvg library.\n		 */\n		Highcharts.CanVGRenderer = CanVGRenderer = function () {\n			// Override the global SVG namespace to fake SVG/HTML that accepts CSS\n			SVG_NS = 'http://www.w3.org/1999/xhtml';\n		};\n\n		/**\n		 * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but \n		 * the implementation from SvgRenderer will not be merged in until first render.\n		 */\n		CanVGRenderer.prototype.symbols = {};\n\n		/**\n		 * Handles on demand download of canvg rendering support.\n		 */\n		CanVGController = (function () {\n			// List of renderering calls\n			var deferredRenderCalls = [];\n\n			/**\n			 * When downloaded, we are ready to draw deferred charts.\n			 */\n			function drawDeferred() {\n				var callLength = deferredRenderCalls.length,\n					callIndex;\n\n				// Draw all pending render calls\n				for (callIndex = 0; callIndex < callLength; callIndex++) {\n					deferredRenderCalls[callIndex]();\n				}\n				// Clear the list\n				deferredRenderCalls = [];\n			}\n\n			return {\n				push: function (func, scriptLocation) {\n					// Only get the script once\n					if (deferredRenderCalls.length === 0) {\n						getScript(scriptLocation, drawDeferred);\n					}\n					// Register render call\n					deferredRenderCalls.push(func);\n				}\n			};\n		}());\n\n		Renderer = CanVGRenderer;\n	} // end CanVGRenderer\n\n	/* ****************************************************************************\n	 *                                                                            *\n	 * END OF ANDROID < 3 SPECIFIC CODE                                           *\n	 *                                                                            *\n	 *****************************************************************************/\n\n	/**\n	 * The Tick class\n	 */\n	function Tick(axis, pos, type, noLabel) {\n		this.axis = axis;\n		this.pos = pos;\n		this.type = type || '';\n		this.isNew = true;\n\n		if (!type && !noLabel) {\n			this.addLabel();\n		}\n	}\n\n	Tick.prototype = {\n		/**\n		 * Write the tick label\n		 */\n		addLabel: function () {\n			var tick = this,\n				axis = tick.axis,\n				options = axis.options,\n				chart = axis.chart,\n				categories = axis.categories,\n				names = axis.names,\n				pos = tick.pos,\n				labelOptions = options.labels,\n				str,\n				tickPositions = axis.tickPositions,\n				isFirst = pos === tickPositions[0],\n				isLast = pos === tickPositions[tickPositions.length - 1],\n				value = categories ?\n					pick(categories[pos], names[pos], pos) :\n					pos,\n				label = tick.label,\n				tickPositionInfo = tickPositions.info,\n				dateTimeLabelFormat;\n\n			// Set the datetime label format. If a higher rank is set for this position, use that. If not,\n			// use the general format.\n			if (axis.isDatetimeAxis && tickPositionInfo) {\n				dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];\n			}\n			// set properties for access in render method\n			tick.isFirst = isFirst;\n			tick.isLast = isLast;\n\n			// get the string\n			str = axis.labelFormatter.call({\n				axis: axis,\n				chart: chart,\n				isFirst: isFirst,\n				isLast: isLast,\n				dateTimeLabelFormat: dateTimeLabelFormat,\n				value: axis.isLog ? correctFloat(lin2log(value)) : value\n			});\n\n			// prepare CSS\n			//css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };\n			\n			// first call\n			if (!defined(label)) {\n\n				tick.label = label =\n					defined(str) && labelOptions.enabled ?\n						chart.renderer.text(\n								str,\n								0,\n								0,\n								labelOptions.useHTML\n							)\n							//.attr(attr)\n							// without position absolute, IE export sometimes is wrong\n							.css(merge(labelOptions.style))\n							.add(axis.labelGroup) :\n						null;\n				tick.labelLength = label && label.getBBox().width; // Un-rotated length\n				tick.rotation = 0; // Base value to detect change for new calls to getBBox\n\n			// update\n			} else if (label) {\n				label.attr({ text: str });\n			}\n		},\n\n		/**\n		 * Get the offset height or width of the label\n		 */\n		getLabelSize: function () {\n			return this.label ?\n				this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :\n				0;\n		},\n\n		/**\n		 * Handle the label overflow by adjusting the labels to the left and right edge, or\n		 * hide them if they collide into the neighbour label.\n		 */\n		handleOverflow: function (xy) {\n			var axis = this.axis,\n				pxPos = xy.x,\n				chartWidth = axis.chart.chartWidth,\n				spacing = axis.chart.spacing,\n				leftBound = pick(axis.labelLeft, spacing[3]),\n				rightBound = pick(axis.labelRight, chartWidth - spacing[1]),\n				label = this.label,\n				rotation = this.rotation,\n				factor = { left: 0, center: 0.5, right: 1 }[axis.labelAlign],\n				labelWidth = label.getBBox().width,\n				slotWidth = axis.slotWidth,\n				leftPos,\n				rightPos,\n				textWidth;\n\n			// Check if the label overshoots the chart spacing box. If it does, move it.\n			// If it now overshoots the slotWidth, add ellipsis.\n			if (!rotation) {\n				leftPos = pxPos - factor * labelWidth;\n				rightPos = pxPos + factor * labelWidth;\n\n				if (leftPos < leftBound) {\n					slotWidth -= leftBound - leftPos;\n					xy.x = leftBound;\n					label.attr({ align: 'left' });				\n				} else if (rightPos > rightBound) {\n					slotWidth -= rightPos - rightBound;\n					xy.x = rightBound;\n					label.attr({ align: 'right' });\n				}\n\n				if (labelWidth > slotWidth) {\n					textWidth = slotWidth;\n				}\n			\n\n			// Add ellipsis to prevent rotated labels to be clipped against the edge of the chart\n			} else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {\n				textWidth = mathRound(pxPos / mathCos(rotation * deg2rad) - leftBound);\n			} else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {\n				textWidth = mathRound((chartWidth - pxPos) / mathCos(rotation * deg2rad));\n			}\n\n			if (textWidth) {\n				label.css({\n					width: textWidth,\n					textOverflow: 'ellipsis'\n				});\n			}\n		},\n\n		/**\n		 * Get the x and y position for ticks and labels\n		 */\n		getPosition: function (horiz, pos, tickmarkOffset, old) {\n			var axis = this.axis,\n				chart = axis.chart,\n				cHeight = (old && chart.oldChartHeight) || chart.chartHeight;\n\n			return {\n				x: horiz ?\n					axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :\n					axis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),\n\n				y: horiz ?\n					cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :\n					cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB\n			};\n\n		},\n\n		/**\n		 * Get the x, y position of the tick label\n		 */\n		getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n			var axis = this.axis,\n				transA = axis.transA,\n				reversed = axis.reversed,\n				staggerLines = axis.staggerLines,\n				rotCorr = axis.tickRotCorr || { x: 0, y: 0 },\n				yOffset = pick(labelOptions.y, rotCorr.y + (axis.side === 2 ? 8 : -(label.getBBox().height / 2))),\n				line;\n\n			x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?\n				tickmarkOffset * transA * (reversed ? -1 : 1) : 0);\n			y = y + yOffset - (tickmarkOffset && !horiz ?\n				tickmarkOffset * transA * (reversed ? 1 : -1) : 0);\n\n			// Correct for staggered labels\n			if (staggerLines) {\n				line = (index / (step || 1) % staggerLines);\n				y += line * (axis.labelOffset / staggerLines);\n			}\n\n			return {\n				x: x,\n				y: mathRound(y)\n			};\n		},\n\n		/**\n		 * Extendible method to return the path of the marker\n		 */\n		getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {\n			return renderer.crispLine([\n					M,\n					x,\n					y,\n					L,\n					x + (horiz ? 0 : -tickLength),\n					y + (horiz ? tickLength : 0)\n				], tickWidth);\n		},\n\n		/**\n		 * Put everything in place\n		 *\n		 * @param index {Number}\n		 * @param old {Boolean} Use old coordinates to prepare an animation into new position\n		 */\n		render: function (index, old, opacity) {\n			var tick = this,\n				axis = tick.axis,\n				options = axis.options,\n				chart = axis.chart,\n				renderer = chart.renderer,\n				horiz = axis.horiz,\n				type = tick.type,\n				label = tick.label,\n				pos = tick.pos,\n				labelOptions = options.labels,\n				gridLine = tick.gridLine,\n				gridPrefix = type ? type + 'Grid' : 'grid',\n				tickPrefix = type ? type + 'Tick' : 'tick',\n				gridLineWidth = options[gridPrefix + 'LineWidth'],\n				gridLineColor = options[gridPrefix + 'LineColor'],\n				dashStyle = options[gridPrefix + 'LineDashStyle'],\n				tickLength = options[tickPrefix + 'Length'],\n				tickWidth = options[tickPrefix + 'Width'] || 0,\n				tickColor = options[tickPrefix + 'Color'],\n				tickPosition = options[tickPrefix + 'Position'],\n				gridLinePath,\n				mark = tick.mark,\n				markPath,\n				step = /*axis.labelStep || */labelOptions.step,\n				attribs,\n				show = true,\n				tickmarkOffset = axis.tickmarkOffset,\n				xy = tick.getPosition(horiz, pos, tickmarkOffset, old),\n				x = xy.x,\n				y = xy.y,\n				reverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687\n\n			opacity = pick(opacity, 1);\n			this.isActive = true;\n\n			// create the grid line\n			if (gridLineWidth) {\n				gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);\n\n				if (gridLine === UNDEFINED) {\n					attribs = {\n						stroke: gridLineColor,\n						'stroke-width': gridLineWidth\n					};\n					if (dashStyle) {\n						attribs.dashstyle = dashStyle;\n					}\n					if (!type) {\n						attribs.zIndex = 1;\n					}\n					if (old) {\n						attribs.opacity = 0;\n					}\n					tick.gridLine = gridLine =\n						gridLineWidth ?\n							renderer.path(gridLinePath)\n								.attr(attribs).add(axis.gridGroup) :\n							null;\n				}\n\n				// If the parameter 'old' is set, the current call will be followed\n				// by another call, therefore do not do any animations this time\n				if (!old && gridLine && gridLinePath) {\n					gridLine[tick.isNew ? 'attr' : 'animate']({\n						d: gridLinePath,\n						opacity: opacity\n					});\n				}\n			}\n\n			// create the tick mark\n			if (tickWidth && tickLength) {\n\n				// negate the length\n				if (tickPosition === 'inside') {\n					tickLength = -tickLength;\n				}\n				if (axis.opposite) {\n					tickLength = -tickLength;\n				}\n\n				markPath = tick.getMarkPath(x, y, tickLength, tickWidth * reverseCrisp, horiz, renderer);\n				if (mark) { // updating\n					mark.animate({\n						d: markPath,\n						opacity: opacity\n					});\n				} else { // first time\n					tick.mark = renderer.path(\n						markPath\n					).attr({\n						stroke: tickColor,\n						'stroke-width': tickWidth,\n						opacity: opacity\n					}).add(axis.axisGroup);\n				}\n			}\n\n			// the label is created on init - now move it into place\n			if (label && !isNaN(x)) {\n				label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);\n\n				// Apply show first and show last. If the tick is both first and last, it is\n				// a single centered tick, in which case we show the label anyway (#2100).\n				if ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||\n						(tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {\n					show = false;\n\n				// Handle label overflow and show or hide accordingly\n				} else if (horiz && !axis.isRadial && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {\n					tick.handleOverflow(xy);\n				}\n\n				// apply step\n				if (step && index % step) {\n					// show those indices dividable by step\n					show = false;\n				}\n\n				// Set the new position, and show or hide\n				if (show && !isNaN(xy.y)) {\n					xy.opacity = opacity;\n					label[tick.isNew ? 'attr' : 'animate'](xy);\n					tick.isNew = false;\n				} else {\n					label.attr('y', -9999); // #1338\n				}\n			}\n		},\n\n		/**\n		 * Destructor for the tick prototype\n		 */\n		destroy: function () {\n			destroyObjectProperties(this, this.axis);\n		}\n	};\n\n	/**\n	 * The object wrapper for plot lines and plot bands\n	 * @param {Object} options\n	 */\n	Highcharts.PlotLineOrBand = function (axis, options) {\n		this.axis = axis;\n\n		if (options) {\n			this.options = options;\n			this.id = options.id;\n		}\n	};\n\n	Highcharts.PlotLineOrBand.prototype = {\n		\n		/**\n		 * Render the plot line or plot band. If it is already existing,\n		 * move it.\n		 */\n		render: function () {\n			var plotLine = this,\n				axis = plotLine.axis,\n				horiz = axis.horiz,\n				options = plotLine.options,\n				optionsLabel = options.label,\n				label = plotLine.label,\n				width = options.width,\n				to = options.to,\n				from = options.from,\n				isBand = defined(from) && defined(to),\n				value = options.value,\n				dashStyle = options.dashStyle,\n				svgElem = plotLine.svgElem,\n				path = [],\n				addEvent,\n				eventType,\n				xs,\n				ys,\n				x,\n				y,\n				color = options.color,\n				zIndex = options.zIndex,\n				events = options.events,\n				attribs = {},\n				renderer = axis.chart.renderer;\n\n			// logarithmic conversion\n			if (axis.isLog) {\n				from = log2lin(from);\n				to = log2lin(to);\n				value = log2lin(value);\n			}\n\n			// plot line\n			if (width) {\n				path = axis.getPlotLinePath(value, width);\n				attribs = {\n					stroke: color,\n					'stroke-width': width\n				};\n				if (dashStyle) {\n					attribs.dashstyle = dashStyle;\n				}\n			} else if (isBand) { // plot band\n\n				path = axis.getPlotBandPath(from, to, options);\n				if (color) {\n					attribs.fill = color;\n				}\n				if (options.borderWidth) {\n					attribs.stroke = options.borderColor;\n					attribs['stroke-width'] = options.borderWidth;\n				}\n			} else {\n				return;\n			}\n			// zIndex\n			if (defined(zIndex)) {\n				attribs.zIndex = zIndex;\n			}\n\n			// common for lines and bands\n			if (svgElem) {\n				if (path) {\n					svgElem.animate({\n						d: path\n					}, null, svgElem.onGetPath);\n				} else {\n					svgElem.hide();\n					svgElem.onGetPath = function () {\n						svgElem.show();\n					};\n					if (label) {\n						plotLine.label = label = label.destroy();\n					}\n				}\n			} else if (path && path.length) {\n				plotLine.svgElem = svgElem = renderer.path(path)\n					.attr(attribs).add();\n\n				// events\n				if (events) {\n					addEvent = function (eventType) {\n						svgElem.on(eventType, function (e) {\n							events[eventType].apply(plotLine, [e]);\n						});\n					};\n					for (eventType in events) {\n						addEvent(eventType);\n					}\n				}\n			}\n\n			// the plot band/line label\n			if (optionsLabel && defined(optionsLabel.text) && path && path.length && axis.width > 0 && axis.height > 0) {\n				// apply defaults\n				optionsLabel = merge({\n					align: horiz && isBand && 'center',\n					x: horiz ? !isBand && 4 : 10,\n					verticalAlign : !horiz && isBand && 'middle',\n					y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,\n					rotation: horiz && !isBand && 90\n				}, optionsLabel);\n\n				// add the SVG element\n				if (!label) {\n					attribs = {\n						align: optionsLabel.textAlign || optionsLabel.align,\n						rotation: optionsLabel.rotation\n					};\n					if (defined(zIndex)) {\n						attribs.zIndex = zIndex;\n					}\n					plotLine.label = label = renderer.text(\n							optionsLabel.text,\n							0,\n							0,\n							optionsLabel.useHTML\n						)\n						.attr(attribs)\n						.css(optionsLabel.style)\n						.add();\n				}\n\n				// get the bounding box and align the label\n				// #3000 changed to better handle choice between plotband or plotline\n				xs = [path[1], path[4], (isBand ? path[6] : path[1])];\n				ys = [path[2], path[5], (isBand ? path[7] : path[2])];\n				x = arrayMin(xs);\n				y = arrayMin(ys);\n\n				label.align(optionsLabel, false, {\n					x: x,\n					y: y,\n					width: arrayMax(xs) - x,\n					height: arrayMax(ys) - y\n				});\n				label.show();\n\n			} else if (label) { // move out of sight\n				label.hide();\n			}\n\n			// chainable\n			return plotLine;\n		},\n\n		/**\n		 * Remove the plot line or band\n		 */\n		destroy: function () {\n			// remove it from the lookup\n			erase(this.axis.plotLinesAndBands, this);\n			\n			delete this.axis;\n			destroyObjectProperties(this);\n		}\n	};\n\n	/**\n	 * Object with members for extending the Axis prototype\n	 */\n\n	AxisPlotLineOrBandExtension = {\n\n		/**\n		 * Create the path for a plot band\n		 */ \n		getPlotBandPath: function (from, to) {\n			var toPath = this.getPlotLinePath(to, null, null, true),\n				path = this.getPlotLinePath(from, null, null, true);\n\n			if (path && toPath && path.toString() !== toPath.toString()) { // #3836\n				path.push(\n					toPath[4],\n					toPath[5],\n					toPath[1],\n					toPath[2]\n				);\n			} else { // outside the axis area\n				path = null;\n			}\n			\n			return path;\n		},\n\n		addPlotBand: function (options) {\n			return this.addPlotBandOrLine(options, 'plotBands');\n		},\n		\n		addPlotLine: function (options) {\n			return this.addPlotBandOrLine(options, 'plotLines');\n		},\n\n		/**\n		 * Add a plot band or plot line after render time\n		 *\n		 * @param options {Object} The plotBand or plotLine configuration object\n		 */\n		addPlotBandOrLine: function (options, coll) {\n			var obj = new Highcharts.PlotLineOrBand(this, options).render(),\n				userOptions = this.userOptions;\n\n			if (obj) { // #2189\n				// Add it to the user options for exporting and Axis.update\n				if (coll) {\n					userOptions[coll] = userOptions[coll] || [];\n					userOptions[coll].push(options); \n				}\n				this.plotLinesAndBands.push(obj); \n			}\n			\n			return obj;\n		},\n\n		/**\n		 * Remove a plot band or plot line from the chart by id\n		 * @param {Object} id\n		 */\n		removePlotBandOrLine: function (id) {\n			var plotLinesAndBands = this.plotLinesAndBands,\n				options = this.options,\n				userOptions = this.userOptions,\n				i = plotLinesAndBands.length;\n			while (i--) {\n				if (plotLinesAndBands[i].id === id) {\n					plotLinesAndBands[i].destroy();\n				}\n			}\n			each([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {\n				i = arr.length;\n				while (i--) {\n					if (arr[i].id === id) {\n						erase(arr, arr[i]);\n					}\n				}\n			});\n		}\n	};\n\n	/**\n	 * Create a new axis object\n	 * @param {Object} chart\n	 * @param {Object} options\n	 */\n	var Axis = Highcharts.Axis = function () {\n		this.init.apply(this, arguments);\n	};\n\n	Axis.prototype = {\n\n		/**\n		 * Default options for the X axis - the Y axis has extended defaults\n		 */\n		defaultOptions: {\n			// allowDecimals: null,\n			// alternateGridColor: null,\n			// categories: [],\n			dateTimeLabelFormats: {\n				millisecond: '%H:%M:%S.%L',\n				second: '%H:%M:%S',\n				minute: '%H:%M',\n				hour: '%H:%M',\n				day: '%e. %b',\n				week: '%e. %b',\n				month: '%b \\'%y',\n				year: '%Y'\n			},\n			endOnTick: false,\n			gridLineColor: '#D8D8D8',\n			// gridLineDashStyle: 'solid',\n			// gridLineWidth: 0,\n			// reversed: false,\n\n			labels: {\n				enabled: true,\n				// rotation: 0,\n				// align: 'center',\n				// step: null,\n				style: {\n					color: '#606060',\n					cursor: 'default',\n					fontSize: '11px'\n				},\n				x: 0,\n				y: 15\n				/*formatter: function () {\n					return this.value;\n				},*/\n			},\n			lineColor: '#C0D0E0',\n			lineWidth: 1,\n			//linkedTo: null,\n			//max: undefined,\n			//min: undefined,\n			minPadding: 0.01,\n			maxPadding: 0.01,\n			//minRange: null,\n			minorGridLineColor: '#E0E0E0',\n			// minorGridLineDashStyle: null,\n			minorGridLineWidth: 1,\n			minorTickColor: '#A0A0A0',\n			//minorTickInterval: null,\n			minorTickLength: 2,\n			minorTickPosition: 'outside', // inside or outside\n			//minorTickWidth: 0,\n			//opposite: false,\n			//offset: 0,\n			//plotBands: [{\n			//	events: {},\n			//	zIndex: 1,\n			//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }\n			//}],\n			//plotLines: [{\n			//	events: {}\n			//  dashStyle: {}\n			//	zIndex:\n			//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }\n			//}],\n			//reversed: false,\n			// showFirstLabel: true,\n			// showLastLabel: true,\n			startOfWeek: 1,\n			startOnTick: false,\n			tickColor: '#C0D0E0',\n			//tickInterval: null,\n			tickLength: 10,\n			tickmarkPlacement: 'between', // on or between\n			tickPixelInterval: 100,\n			tickPosition: 'outside',\n			tickWidth: 1,\n			title: {\n				//text: null,\n				align: 'middle', // low, middle or high\n				//margin: 0 for horizontal, 10 for vertical axes,\n				//rotation: 0,\n				//side: 'outside',\n				style: {\n					color: '#707070'\n				}\n				//x: 0,\n				//y: 0\n			},\n			type: 'linear' // linear, logarithmic or datetime\n		},\n\n		/**\n		 * This options set extends the defaultOptions for Y axes\n		 */\n		defaultYAxisOptions: {\n			endOnTick: true,\n			gridLineWidth: 1,\n			tickPixelInterval: 72,\n			showLastLabel: true,\n			labels: {\n				x: -8,\n				y: 3\n			},\n			lineWidth: 0,\n			maxPadding: 0.05,\n			minPadding: 0.05,\n			startOnTick: true,\n			tickWidth: 0,\n			title: {\n				rotation: 270,\n				text: 'Values'\n			},\n			stackLabels: {\n				enabled: false,\n				//align: dynamic,\n				//y: dynamic,\n				//x: dynamic,\n				//verticalAlign: dynamic,\n				//textAlign: dynamic,\n				//rotation: 0,\n				formatter: function () {\n					return Highcharts.numberFormat(this.total, -1);\n				},\n				style: merge(defaultPlotOptions.line.dataLabels.style, { color: '#000000' })\n			}\n		},\n\n		/**\n		 * These options extend the defaultOptions for left axes\n		 */\n		defaultLeftAxisOptions: {\n			labels: {\n				x: -15,\n				y: null\n			},\n			title: {\n				rotation: 270\n			}\n		},\n\n		/**\n		 * These options extend the defaultOptions for right axes\n		 */\n		defaultRightAxisOptions: {\n			labels: {\n				x: 15,\n				y: null\n			},\n			title: {\n				rotation: 90\n			}\n		},\n\n		/**\n		 * These options extend the defaultOptions for bottom axes\n		 */\n		defaultBottomAxisOptions: {\n			labels: {\n				autoRotation: [-45],\n				x: 0,\n				y: null // based on font size\n				// overflow: undefined,\n				// staggerLines: null\n			},\n			title: {\n				rotation: 0\n			}\n		},\n		/**\n		 * These options extend the defaultOptions for top axes\n		 */\n		defaultTopAxisOptions: {\n			labels: {\n				autoRotation: [-45],\n				x: 0,\n				y: -15\n				// overflow: undefined\n				// staggerLines: null\n			},\n			title: {\n				rotation: 0\n			}\n		},\n\n		/**\n		 * Initialize the axis\n		 */\n		init: function (chart, userOptions) {\n\n\n			var isXAxis = userOptions.isX,\n				axis = this;\n\n			// Flag, is the axis horizontal\n			axis.horiz = chart.inverted ? !isXAxis : isXAxis;\n\n			// Flag, isXAxis\n			axis.isXAxis = isXAxis;\n			axis.coll = isXAxis ? 'xAxis' : 'yAxis';\n\n			axis.opposite = userOptions.opposite; // needed in setOptions\n			axis.side = userOptions.side || (axis.horiz ?\n					(axis.opposite ? 0 : 2) : // top : bottom\n					(axis.opposite ? 1 : 3));  // right : left\n\n			axis.setOptions(userOptions);\n\n\n			var options = this.options,\n				type = options.type,\n				isDatetimeAxis = type === 'datetime';\n\n			axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format\n\n\n			// Flag, stagger lines or not\n			axis.userOptions = userOptions;\n\n			//axis.axisTitleMargin = UNDEFINED,// = options.title.margin,\n			axis.minPixelPadding = 0;\n			//axis.ignoreMinPadding = UNDEFINED; // can be set to true by a column or bar series\n			//axis.ignoreMaxPadding = UNDEFINED;\n\n			axis.chart = chart;\n			axis.reversed = options.reversed;\n			axis.zoomEnabled = options.zoomEnabled !== false;\n\n			// Initial categories\n			axis.categories = options.categories || type === 'category';\n			axis.names = axis.names || []; // Preserve on update (#3830)\n\n			// Elements\n			//axis.axisGroup = UNDEFINED;\n			//axis.gridGroup = UNDEFINED;\n			//axis.axisTitle = UNDEFINED;\n			//axis.axisLine = UNDEFINED;\n\n			// Shorthand types\n			axis.isLog = type === 'logarithmic';\n			axis.isDatetimeAxis = isDatetimeAxis;\n\n			// Flag, if axis is linked to another axis\n			axis.isLinked = defined(options.linkedTo);\n			// Linked axis.\n			//axis.linkedParent = UNDEFINED;\n\n			// Tick positions\n			//axis.tickPositions = UNDEFINED; // array containing predefined positions\n			// Tick intervals\n			//axis.tickInterval = UNDEFINED;\n			//axis.minorTickInterval = UNDEFINED;\n\n			\n			// Major ticks\n			axis.ticks = {};\n			axis.labelEdge = [];\n			// Minor ticks\n			axis.minorTicks = {};\n\n			// List of plotLines/Bands\n			axis.plotLinesAndBands = [];\n\n			// Alternate bands\n			axis.alternateBands = {};\n\n			// Axis metrics\n			//axis.left = UNDEFINED;\n			//axis.top = UNDEFINED;\n			//axis.width = UNDEFINED;\n			//axis.height = UNDEFINED;\n			//axis.bottom = UNDEFINED;\n			//axis.right = UNDEFINED;\n			//axis.transA = UNDEFINED;\n			//axis.transB = UNDEFINED;\n			//axis.oldTransA = UNDEFINED;\n			axis.len = 0;\n			//axis.oldMin = UNDEFINED;\n			//axis.oldMax = UNDEFINED;\n			//axis.oldUserMin = UNDEFINED;\n			//axis.oldUserMax = UNDEFINED;\n			//axis.oldAxisLength = UNDEFINED;\n			axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;\n			axis.range = options.range;\n			axis.offset = options.offset || 0;\n\n\n			// Dictionary for stacks\n			axis.stacks = {};\n			axis.oldStacks = {};\n			\n			// Min and max in the data\n			//axis.dataMin = UNDEFINED,\n			//axis.dataMax = UNDEFINED,\n\n			// The axis range\n			axis.max = null;\n			axis.min = null;\n\n			// User set min and max\n			//axis.userMin = UNDEFINED,\n			//axis.userMax = UNDEFINED,\n\n			// Crosshair options\n			axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);\n			// Run Axis\n\n			var eventType,\n				events = axis.options.events;\n\n			// Register\n			if (inArray(axis, chart.axes) === -1) { // don't add it again on Axis.update()\n				if (isXAxis && !this.isColorAxis) { // #2713\n					chart.axes.splice(chart.xAxis.length, 0, axis);\n				} else {\n					chart.axes.push(axis);\n				}\n\n				chart[axis.coll].push(axis);\n			}\n\n			axis.series = axis.series || []; // populated by Series\n\n			// inverted charts have reversed xAxes as default\n			if (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {\n				axis.reversed = true;\n			}\n\n			axis.removePlotBand = axis.removePlotBandOrLine;\n			axis.removePlotLine = axis.removePlotBandOrLine;\n\n\n			// register event listeners\n			for (eventType in events) {\n				addEvent(axis, eventType, events[eventType]);\n			}\n\n			// extend logarithmic axis\n			if (axis.isLog) {\n				axis.val2lin = log2lin;\n				axis.lin2val = lin2log;\n			}\n		},\n\n		/**\n		 * Merge and set options\n		 */\n		setOptions: function (userOptions) {\n			this.options = merge(\n				this.defaultOptions,\n				this.isXAxis ? {} : this.defaultYAxisOptions,\n				[this.defaultTopAxisOptions, this.defaultRightAxisOptions,\n					this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],\n				merge(\n					defaultOptions[this.coll], // if set in setOptions (#1053)\n					userOptions\n				)\n			);\n		},\n\n		/**\n		 * The default label formatter. The context is a special config object for the label.\n		 */\n		defaultLabelFormatter: function () {\n			var axis = this.axis,\n				value = this.value,\n				categories = axis.categories,\n				dateTimeLabelFormat = this.dateTimeLabelFormat,\n				numericSymbols = defaultOptions.lang.numericSymbols,\n				i = numericSymbols && numericSymbols.length,\n				multi,\n				ret,\n				formatOption = axis.options.labels.format,\n\n				// make sure the same symbol is added for all labels on a linear axis\n				numericSymbolDetector = axis.isLog ? value : axis.tickInterval;\n\n			if (formatOption) {\n				ret = format(formatOption, this);\n\n			} else if (categories) {\n				ret = value;\n\n			} else if (dateTimeLabelFormat) { // datetime axis\n				ret = dateFormat(dateTimeLabelFormat, value);\n\n			} else if (i && numericSymbolDetector >= 1000) {\n				// Decide whether we should add a numeric symbol like k (thousands) or M (millions).\n				// If we are to enable this in tooltip or other places as well, we can move this\n				// logic to the numberFormatter and enable it by a parameter.\n				while (i-- && ret === UNDEFINED) {\n					multi = Math.pow(1000, i + 1);\n					if (numericSymbolDetector >= multi && numericSymbols[i] !== null) {\n						ret = Highcharts.numberFormat(value / multi, -1) + numericSymbols[i];\n					}\n				}\n			}\n\n			if (ret === UNDEFINED) {\n				if (mathAbs(value) >= 10000) { // add thousands separators\n					ret = Highcharts.numberFormat(value, 0);\n\n				} else { // small numbers\n					ret = Highcharts.numberFormat(value, -1, UNDEFINED, ''); // #2466\n				}\n			}\n\n			return ret;\n		},\n\n		/**\n		 * Get the minimum and maximum for the series of each axis\n		 */\n		getSeriesExtremes: function () {\n			var axis = this,\n				chart = axis.chart;\n\n			axis.hasVisibleSeries = false;\n\n			// Reset properties in case we're redrawing (#3353)\n			axis.dataMin = axis.dataMax = axis.ignoreMinPadding = axis.ignoreMaxPadding = null;\n			\n			if (axis.buildStacks) {\n				axis.buildStacks();\n			}\n\n			// loop through this axis' series\n			each(axis.series, function (series) {\n\n				if (series.visible || !chart.options.chart.ignoreHiddenSeries) {\n\n					var seriesOptions = series.options,\n						xData,\n						threshold = seriesOptions.threshold,\n						seriesDataMin,\n						seriesDataMax;\n\n					axis.hasVisibleSeries = true;\n\n					// Validate threshold in logarithmic axes\n					if (axis.isLog && threshold <= 0) {\n						threshold = null;\n					}\n\n					// Get dataMin and dataMax for X axes\n					if (axis.isXAxis) {\n						xData = series.xData;\n						if (xData.length) {\n							axis.dataMin = mathMin(pick(axis.dataMin, xData[0]), arrayMin(xData));\n							axis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));\n						}\n\n					// Get dataMin and dataMax for Y axes, as well as handle stacking and processed data\n					} else {\n\n						// Get this particular series extremes\n						series.getExtremes();\n						seriesDataMax = series.dataMax;\n						seriesDataMin = series.dataMin;\n\n						// Get the dataMin and dataMax so far. If percentage is used, the min and max are\n						// always 0 and 100. If seriesDataMin and seriesDataMax is null, then series\n						// doesn't have active y data, we continue with nulls\n						if (defined(seriesDataMin) && defined(seriesDataMax)) {\n							axis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);\n							axis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);\n						}\n\n						// Adjust to threshold\n						if (defined(threshold)) {\n							if (axis.dataMin >= threshold) {\n								axis.dataMin = threshold;\n								axis.ignoreMinPadding = true;\n							} else if (axis.dataMax < threshold) {\n								axis.dataMax = threshold;\n								axis.ignoreMaxPadding = true;\n							}\n						}\n					}\n				}\n			});\n		},\n\n		/**\n		 * Translate from axis value to pixel position on the chart, or back\n		 *\n		 */\n		translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {\n			var axis = this,\n				sign = 1,\n				cvsOffset = 0,\n				localA = old ? axis.oldTransA : axis.transA,\n				localMin = old ? axis.oldMin : axis.min,\n				returnValue,\n				minPixelPadding = axis.minPixelPadding,\n				doPostTranslate = (axis.doPostTranslate || (axis.isLog && handleLog)) && axis.lin2val;\n\n			if (!localA) {\n				localA = axis.transA;\n			}\n\n			// In vertical axes, the canvas coordinates start from 0 at the top like in\n			// SVG.\n			if (cvsCoord) {\n				sign *= -1; // canvas coordinates inverts the value\n				cvsOffset = axis.len;\n			}\n\n			// Handle reversed axis\n			if (axis.reversed) {\n				sign *= -1;\n				cvsOffset -= sign * (axis.sector || axis.len);\n			}\n\n			// From pixels to value\n			if (backwards) { // reverse translation\n\n				val = val * sign + cvsOffset;\n				val -= minPixelPadding;\n				returnValue = val / localA + localMin; // from chart pixel to value\n				if (doPostTranslate) { // log and ordinal axes\n					returnValue = axis.lin2val(returnValue);\n				}\n\n			// From value to pixels\n			} else {\n				if (doPostTranslate) { // log and ordinal axes\n					val = axis.val2lin(val);\n				}\n				if (pointPlacement === 'between') {\n					pointPlacement = 0.5;\n				}\n				returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +\n					(isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);\n			}\n\n			return returnValue;\n		},\n\n		/**\n		 * Utility method to translate an axis value to pixel position.\n		 * @param {Number} value A value in terms of axis units\n		 * @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart\n		 *        or just the axis/pane itself.\n		 */\n		toPixels: function (value, paneCoordinates) {\n			return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);\n		},\n\n		/*\n		 * Utility method to translate a pixel position in to an axis value\n		 * @param {Number} pixel The pixel value coordinate\n		 * @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the\n		 *        axis/pane itself.\n		 */\n		toValue: function (pixel, paneCoordinates) {\n			return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);\n		},\n\n		/**\n		 * Create the path for a plot line that goes from the given value on\n		 * this axis, across the plot to the opposite side\n		 * @param {Number} value\n		 * @param {Number} lineWidth Used for calculation crisp line\n		 * @param {Number] old Use old coordinates (for resizing and rescaling)\n		 */\n		getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {\n			var axis = this,\n				chart = axis.chart,\n				axisLeft = axis.left,\n				axisTop = axis.top,\n				x1,\n				y1,\n				x2,\n				y2,\n				cHeight = (old && chart.oldChartHeight) || chart.chartHeight,\n				cWidth = (old && chart.oldChartWidth) || chart.chartWidth,\n				skip,\n				transB = axis.transB,\n				/**\n				 * Check if x is between a and b. If not, either move to a/b or skip, \n				 * depending on the force parameter.\n				 */\n				between = function (x, a, b) {\n					if (x < a || x > b) {\n						if (force) {\n							x = mathMin(mathMax(a, x), b);\n						} else {\n							skip = true;\n						}\n					}\n					return x;\n				};\n\n			translatedValue = pick(translatedValue, axis.translate(value, null, null, old));\n			x1 = x2 = mathRound(translatedValue + transB);\n			y1 = y2 = mathRound(cHeight - translatedValue - transB);\n\n			if (isNaN(translatedValue)) { // no min or max\n				skip = true;\n\n			} else if (axis.horiz) {\n				y1 = axisTop;\n				y2 = cHeight - axis.bottom;\n				x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);\n			} else {\n				x1 = axisLeft;\n				x2 = cWidth - axis.right;\n				y1 = y2 = between(y1, axisTop, axisTop + axis.height);\n			}\n			return skip && !force ?\n				null :\n				chart.renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 1);\n		},\n\n		/**\n		 * Set the tick positions of a linear axis to round values like whole tens or every five.\n		 */\n		getLinearTickPositions: function (tickInterval, min, max) {\n			var pos,\n				lastPos,\n				roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),\n				roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),\n				tickPositions = [];\n\n			// For single points, add a tick regardless of the relative position (#2662)\n			if (min === max && isNumber(min)) {\n				return [min];\n			}\n\n			// Populate the intermediate values\n			pos = roundedMin;\n			while (pos <= roundedMax) {\n\n				// Place the tick on the rounded value\n				tickPositions.push(pos);\n\n				// Always add the raw tickInterval, not the corrected one.\n				pos = correctFloat(pos + tickInterval);\n\n				// If the interval is not big enough in the current min - max range to actually increase\n				// the loop variable, we need to break out to prevent endless loop. Issue #619\n				if (pos === lastPos) {\n					break;\n				}\n\n				// Record the last value\n				lastPos = pos;\n			}\n			return tickPositions;\n		},\n\n		/**\n		 * Return the minor tick positions. For logarithmic axes, reuse the same logic\n		 * as for major ticks.\n		 */\n		getMinorTickPositions: function () {\n			var axis = this,\n				options = axis.options,\n				tickPositions = axis.tickPositions,\n				minorTickInterval = axis.minorTickInterval,\n				minorTickPositions = [],\n				pos,\n				i,\n				min = axis.min,\n				max = axis.max,\n				range = max - min,\n				len;\n\n			// If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.\n			if (range && range / minorTickInterval < axis.len / 3) { // #3875\n\n				if (axis.isLog) {\n					len = tickPositions.length;\n					for (i = 1; i < len; i++) {\n						minorTickPositions = minorTickPositions.concat(\n							axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)\n						);\n					}\n				} else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314\n					minorTickPositions = minorTickPositions.concat(\n						axis.getTimeTicks(\n							axis.normalizeTimeTickInterval(minorTickInterval),\n							min,\n							max,\n							options.startOfWeek\n						)\n					);\n				} else {\n					for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {\n						minorTickPositions.push(pos);\n					}\n				}\n			}\n\n			axis.trimTicks(minorTickPositions); // #3652 #3743\n			return minorTickPositions;\n		},\n\n		/**\n		 * Adjust the min and max for the minimum range. Keep in mind that the series data is\n		 * not yet processed, so we don't have information on data cropping and grouping, or\n		 * updated axis.pointRange or series.pointRange. The data can't be processed until\n		 * we have finally established min and max.\n		 */\n		adjustForMinRange: function () {\n			var axis = this,\n				options = axis.options,\n				min = axis.min,\n				max = axis.max,\n				zoomOffset,\n				spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,\n				closestDataRange,\n				i,\n				distance,\n				xData,\n				loopLength,\n				minArgs,\n				maxArgs;\n\n			// Set the automatic minimum range based on the closest point distance\n			if (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {\n\n				if (defined(options.min) || defined(options.max)) {\n					axis.minRange = null; // don't do this again\n\n				} else {\n\n					// Find the closest distance between raw data points, as opposed to\n					// closestPointRange that applies to processed points (cropped and grouped)\n					each(axis.series, function (series) {\n						xData = series.xData;\n						loopLength = series.xIncrement ? 1 : xData.length - 1;\n						for (i = loopLength; i > 0; i--) {\n							distance = xData[i] - xData[i - 1];\n							if (closestDataRange === UNDEFINED || distance < closestDataRange) {\n								closestDataRange = distance;\n							}\n						}\n					});\n					axis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);\n				}\n			}\n\n			// if minRange is exceeded, adjust\n			if (max - min < axis.minRange) {\n				var minRange = axis.minRange;\n				zoomOffset = (minRange - max + min) / 2;\n\n				// if min and max options have been set, don't go beyond it\n				minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];\n				if (spaceAvailable) { // if space is available, stay within the data range\n					minArgs[2] = axis.dataMin;\n				}\n				min = arrayMax(minArgs);\n\n				maxArgs = [min + minRange, pick(options.max, min + minRange)];\n				if (spaceAvailable) { // if space is availabe, stay within the data range\n					maxArgs[2] = axis.dataMax;\n				}\n\n				max = arrayMin(maxArgs);\n\n				// now if the max is adjusted, adjust the min back\n				if (max - min < minRange) {\n					minArgs[0] = max - minRange;\n					minArgs[1] = pick(options.min, max - minRange);\n					min = arrayMax(minArgs);\n				}\n			}\n\n			// Record modified extremes\n			axis.min = min;\n			axis.max = max;\n		},\n\n		/**\n		 * Update translation information\n		 */\n		setAxisTranslation: function (saveOld) {\n			var axis = this,\n				range = axis.max - axis.min,\n				pointRange = axis.axisPointRange || 0,\n				closestPointRange,\n				minPointOffset = 0,\n				pointRangePadding = 0,\n				linkedParent = axis.linkedParent,\n				ordinalCorrection,\n				hasCategories = !!axis.categories,\n				transA = axis.transA,\n				isXAxis = axis.isXAxis;\n\n			// Adjust translation for padding. Y axis with categories need to go through the same (#1784).\n			if (isXAxis || hasCategories || pointRange) {\n				if (linkedParent) {\n					minPointOffset = linkedParent.minPointOffset;\n					pointRangePadding = linkedParent.pointRangePadding;\n\n				} else {\n					each(axis.series, function (series) {\n						var seriesPointRange = hasCategories ? 1 : (isXAxis ? series.pointRange : (axis.axisPointRange || 0)), // #2806\n							pointPlacement = series.options.pointPlacement,\n							seriesClosestPointRange = series.closestPointRange;\n\n						if (seriesPointRange > range) { // #1446\n							seriesPointRange = 0;\n						}\n						pointRange = mathMax(pointRange, seriesPointRange);\n\n						if (!axis.single) {\n							// minPointOffset is the value padding to the left of the axis in order to make\n							// room for points with a pointRange, typically columns. When the pointPlacement option\n							// is 'between' or 'on', this padding does not apply.\n							minPointOffset = mathMax(\n								minPointOffset,\n								isString(pointPlacement) ? 0 : seriesPointRange / 2\n							);\n\n							// Determine the total padding needed to the length of the axis to make room for the\n							// pointRange. If the series' pointPlacement is 'on', no padding is added.\n							pointRangePadding = mathMax(\n								pointRangePadding,\n								pointPlacement === 'on' ? 0 : seriesPointRange\n							);\n						}\n\n						// Set the closestPointRange\n						if (!series.noSharedTooltip && defined(seriesClosestPointRange)) {\n							closestPointRange = defined(closestPointRange) ?\n								mathMin(closestPointRange, seriesClosestPointRange) :\n								seriesClosestPointRange;\n						}\n					});\n				}\n\n				// Record minPointOffset and pointRangePadding\n				ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853\n				axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;\n				axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;\n\n				// pointRange means the width reserved for each point, like in a column chart\n				axis.pointRange = mathMin(pointRange, range);\n\n				// closestPointRange means the closest distance between points. In columns\n				// it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange\n				// is some other value\n				if (isXAxis) {\n					axis.closestPointRange = closestPointRange;\n				}\n			}\n\n			// Secondary values\n			if (saveOld) {\n				axis.oldTransA = transA;\n			}\n			axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);\n			axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend\n			axis.minPixelPadding = transA * minPointOffset;\n		},\n\n		/**\n		 * Set the tick positions to round values and optionally extend the extremes\n		 * to the nearest tick\n		 */\n		setTickInterval: function (secondPass) {\n			var axis = this,\n				chart = axis.chart,\n				options = axis.options,\n				isLog = axis.isLog,\n				isDatetimeAxis = axis.isDatetimeAxis,\n				isXAxis = axis.isXAxis,\n				isLinked = axis.isLinked,\n				maxPadding = options.maxPadding,\n				minPadding = options.minPadding,\n				length,\n				linkedParentExtremes,\n				tickIntervalOption = options.tickInterval,\n				minTickInterval,\n				tickPixelIntervalOption = options.tickPixelInterval,\n				categories = axis.categories;\n\n			if (!isDatetimeAxis && !categories && !isLinked) {\n				this.getTickAmount();\n			}\n\n			// linked axis gets the extremes from the parent axis\n			if (isLinked) {\n				axis.linkedParent = chart[axis.coll][options.linkedTo];\n				linkedParentExtremes = axis.linkedParent.getExtremes();\n				axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);\n				axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);\n				if (options.type !== axis.linkedParent.options.type) {\n					error(11, 1); // Can't link axes of different type\n				}\n			} else { // initial min and max from the extreme data values\n				axis.min = pick(axis.userMin, options.min, axis.dataMin);\n				axis.max = pick(axis.userMax, options.max, axis.dataMax);\n			}\n\n			if (isLog) {\n				if (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978\n					error(10, 1); // Can't plot negative values on log axis\n				}\n				axis.min = correctFloat(log2lin(axis.min)); // correctFloat cures #934\n				axis.max = correctFloat(log2lin(axis.max));\n			}\n\n			// handle zoomed range\n			if (axis.range && defined(axis.max)) {\n				axis.userMin = axis.min = mathMax(axis.min, axis.max - axis.range); // #618\n				axis.userMax = axis.max;\n\n				axis.range = null;  // don't use it when running setExtremes\n			}\n\n			// Hook for adjusting this.min and this.max. Used by bubble series.\n			if (axis.beforePadding) {\n				axis.beforePadding();\n			}\n\n			// adjust min and max for the minimum range\n			axis.adjustForMinRange();\n\n			// Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding\n			// into account, we do this after computing tick interval (#1337).\n			if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {\n				length = axis.max - axis.min;\n				if (length) {\n					if (!defined(options.min) && !defined(axis.userMin) && minPadding && (axis.dataMin < 0 || !axis.ignoreMinPadding)) {\n						axis.min -= length * minPadding;\n					}\n					if (!defined(options.max) && !defined(axis.userMax)  && maxPadding && (axis.dataMax > 0 || !axis.ignoreMaxPadding)) {\n						axis.max += length * maxPadding;\n					}\n				}\n			}\n\n			// Stay within floor and ceiling\n			if (isNumber(options.floor)) {\n				axis.min = mathMax(axis.min, options.floor);\n			}\n			if (isNumber(options.ceiling)) {\n				axis.max = mathMin(axis.max, options.ceiling);\n			}\n\n			// get tickInterval\n			if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {\n				axis.tickInterval = 1;\n			} else if (isLinked && !tickIntervalOption &&\n					tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {\n				axis.tickInterval = axis.linkedParent.tickInterval;\n			} else {\n				axis.tickInterval = pick(\n					tickIntervalOption,\n					this.tickAmount ? ((axis.max - axis.min) / mathMax(this.tickAmount - 1, 1)) : undefined,\n					categories ? // for categoried axis, 1 is default, for linear axis use tickPix\n						1 :\n						// don't let it be more than the data range\n						(axis.max - axis.min) * tickPixelIntervalOption / mathMax(axis.len, tickPixelIntervalOption)\n				);\n			}\n\n			// Now we're finished detecting min and max, crop and group series data. This\n			// is in turn needed in order to find tick positions in ordinal axes.\n			if (isXAxis && !secondPass) {\n				each(axis.series, function (series) {\n					series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);\n				});\n			}\n\n			// set the translation factor used in translate function\n			axis.setAxisTranslation(true);\n\n			// hook for ordinal axes and radial axes\n			if (axis.beforeSetTickPositions) {\n				axis.beforeSetTickPositions();\n			}\n\n			// hook for extensions, used in Highstock ordinal axes\n			if (axis.postProcessTickInterval) {\n				axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);\n			}\n\n			// In column-like charts, don't cramp in more ticks than there are points (#1943)\n			if (axis.pointRange) {\n				axis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);\n			}\n\n			// Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.\n			minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);\n			if (!tickIntervalOption && axis.tickInterval < minTickInterval) {\n				axis.tickInterval = minTickInterval;\n			}\n\n			// for linear axes, get magnitude and normalize the interval\n			if (!isDatetimeAxis && !isLog) { // linear\n				if (!tickIntervalOption) {\n					axis.tickInterval = normalizeTickInterval(\n						axis.tickInterval, \n						null, \n						getMagnitude(axis.tickInterval), \n						// If the tick interval is between 0.5 and 5 and the axis max is in the order of\n						// thousands, chances are we are dealing with years. Don't allow decimals. #3363.\n						pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)),\n						!!this.tickAmount\n					);\n				}\n			}\n\n			// Prevent ticks from getting so close that we can't draw the labels\n			if (!this.tickAmount && this.len) { // Color axis with disabled legend has no length\n				axis.tickInterval = axis.unsquish();\n			}\n\n			this.setTickPositions();\n		},\n\n		/**\n		 * Now we have computed the normalized tickInterval, get the tick positions\n		 */\n		setTickPositions: function () {\n\n			var options = this.options,\n				tickPositions,\n				tickPositionsOption = options.tickPositions,\n				tickPositioner = options.tickPositioner,\n				startOnTick = options.startOnTick,\n				endOnTick = options.endOnTick,\n				single;\n\n			// Set the tickmarkOffset\n			this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' && \n				this.tickInterval === 1) ? 0.5 : 0; // #3202\n\n\n			// get minorTickInterval\n			this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?\n				this.tickInterval / 5 : options.minorTickInterval;\n\n			// Find the tick positions\n			this.tickPositions = tickPositions = options.tickPositions && options.tickPositions.slice(); // Work on a copy (#1565)\n			if (!tickPositions) {\n\n				if (this.isDatetimeAxis) {\n					tickPositions = this.getTimeTicks(\n						this.normalizeTimeTickInterval(this.tickInterval, options.units),\n						this.min,\n						this.max,\n						options.startOfWeek,\n						this.ordinalPositions,\n						this.closestPointRange,\n						true\n					);\n				} else if (this.isLog) {\n					tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);\n				} else {\n					tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);\n				}\n\n				this.tickPositions = tickPositions;\n\n				// Run the tick positioner callback, that allows modifying auto tick positions.\n				if (tickPositioner) {\n					tickPositioner = tickPositioner.apply(this, [this.min, this.max]);\n					if (tickPositioner) {\n						this.tickPositions = tickPositions = tickPositioner;\n					}\n				}\n\n			}\n\n			if (!this.isLinked) {\n\n				// reset min/max or remove extremes based on start/end on tick\n				this.trimTicks(tickPositions, startOnTick, endOnTick);\n\n				// When there is only one point, or all points have the same value on this axis, then min\n				// and max are equal and tickPositions.length is 0 or 1. In this case, add some padding\n				// in order to center the point, but leave it with one tick. #1337.\n				if (this.min === this.max && defined(this.min) && !this.tickAmount) {\n					// Substract half a unit (#2619, #2846, #2515, #3390)\n					single = true;\n					this.min -= 0.5;\n					this.max += 0.5;\n				}\n				this.single = single;\n\n				if (!tickPositionsOption && !tickPositioner) {\n					this.adjustTickAmount();\n				}\n			}\n		},\n\n		/**\n		 * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max\n		 */\n		trimTicks: function (tickPositions, startOnTick, endOnTick) {\n			var roundedMin = tickPositions[0],\n				roundedMax = tickPositions[tickPositions.length - 1],\n				minPointOffset = this.minPointOffset || 0;\n				\n			if (startOnTick) {\n				this.min = roundedMin;\n			} else if (this.min - minPointOffset > roundedMin) {\n				tickPositions.shift();\n			}\n\n			if (endOnTick) {\n				this.max = roundedMax;\n			} else if (this.max + minPointOffset < roundedMax) {\n				tickPositions.pop();\n			}\n\n			// If no tick are left, set one tick in the middle (#3195) \n			if (tickPositions.length === 0 && defined(roundedMin)) {\n				tickPositions.push((roundedMax + roundedMin) / 2);\n			}		\n		},\n\n		/**\n		 * Set the max ticks of either the x and y axis collection\n		 */\n		getTickAmount: function () {\n			var others = {}, // Whether there is another axis to pair with this one\n				hasOther,\n				options = this.options,\n				tickAmount = options.tickAmount,\n				tickPixelInterval = options.tickPixelInterval;\n\n			if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&\n					!this.isLog && options.startOnTick && options.endOnTick) {\n				tickAmount = 2;\n			}\n\n			if (!tickAmount && this.chart.options.chart.alignTicks !== false && options.alignTicks !== false) {\n				// Check if there are multiple axes in the same pane\n				each(this.chart[this.coll], function (axis) {\n					var options = axis.options,\n						horiz = axis.horiz,\n						key = [horiz ? options.left : options.top, horiz ? options.width : options.height, options.pane].join(',');\n					\n					if (others[key]) {\n						hasOther = true;\n					} else {\n						others[key] = 1;\n					}\n				});\n\n				if (hasOther) {\n					// Add 1 because 4 tick intervals require 5 ticks (including first and last)\n					tickAmount = mathCeil(this.len / tickPixelInterval) + 1;\n				}\n			}\n\n			// For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This\n			// prevents the axis from adding ticks that are too far away from the data extremes.\n			if (tickAmount < 4) {\n				this.finalTickAmt = tickAmount;\n				tickAmount = 5;\n			}\n			\n			this.tickAmount = tickAmount;\n		},\n\n		/**\n		 * When using multiple axes, adjust the number of ticks to match the highest\n		 * number of ticks in that group\n		 */\n		adjustTickAmount: function () {\n			var tickInterval = this.tickInterval,\n				tickPositions = this.tickPositions,\n				tickAmount = this.tickAmount,\n				finalTickAmt = this.finalTickAmt,\n				currentTickAmount = tickPositions && tickPositions.length,\n				i,\n				len;\n\n			if (currentTickAmount < tickAmount) { // TODO: Check #3411\n				while (tickPositions.length < tickAmount) {\n					tickPositions.push(correctFloat(\n						tickPositions[tickPositions.length - 1] + tickInterval\n					));\n				}\n				this.transA *= (currentTickAmount - 1) / (tickAmount - 1);\n				this.max = tickPositions[tickPositions.length - 1];\n\n			// We have too many ticks, run second pass to try to reduce ticks\n			} else if (currentTickAmount > tickAmount) {\n				this.tickInterval *= 2;\n				this.setTickPositions();\n			}\n\n			// The finalTickAmt property is set in getTickAmount\n			if (defined(finalTickAmt)) {\n				i = len = tickPositions.length;\n				while (i--) {\n					if (\n						(finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick\n						(finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last\n					) {\n						tickPositions.splice(i, 1);\n					}	\n				}\n				this.finalTickAmt = UNDEFINED;\n			}\n		},\n\n		/**\n		 * Set the scale based on data min and max, user set min and max or options\n		 *\n		 */\n		setScale: function () {\n			var axis = this,\n				stacks = axis.stacks,\n				type,\n				i,\n				isDirtyData,\n				isDirtyAxisLength;\n\n			axis.oldMin = axis.min;\n			axis.oldMax = axis.max;\n			axis.oldAxisLength = axis.len;\n\n			// set the new axisLength\n			axis.setAxisSize();\n			//axisLength = horiz ? axisWidth : axisHeight;\n			isDirtyAxisLength = axis.len !== axis.oldAxisLength;\n\n			// is there new data?\n			each(axis.series, function (series) {\n				if (series.isDirtyData || series.isDirty ||\n						series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well\n					isDirtyData = true;\n				}\n			});\n\n			// do we really need to go through all this?\n			if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||\n				axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax) {\n\n				// reset stacks\n				if (!axis.isXAxis) {\n					for (type in stacks) {\n						for (i in stacks[type]) {\n							stacks[type][i].total = null;\n							stacks[type][i].cum = 0;\n						}\n					}\n				}\n\n				axis.forceRedraw = false;\n\n				// get data extremes if needed\n				axis.getSeriesExtremes();\n\n				// get fixed positions based on tickInterval\n				axis.setTickInterval();\n\n				// record old values to decide whether a rescale is necessary later on (#540)\n				axis.oldUserMin = axis.userMin;\n				axis.oldUserMax = axis.userMax;\n\n				// Mark as dirty if it is not already set to dirty and extremes have changed. #595.\n				if (!axis.isDirty) {\n					axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;\n				}\n			} else if (!axis.isXAxis) {\n				if (axis.oldStacks) {\n					stacks = axis.stacks = axis.oldStacks;\n				}\n\n				// reset stacks\n				for (type in stacks) {\n					for (i in stacks[type]) {\n						stacks[type][i].cum = stacks[type][i].total;\n					}\n				}\n			}\n		},\n\n		/**\n		 * Set the extremes and optionally redraw\n		 * @param {Number} newMin\n		 * @param {Number} newMax\n		 * @param {Boolean} redraw\n		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n		 *    configuration\n		 * @param {Object} eventArguments\n		 *\n		 */\n		setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {\n			var axis = this,\n				chart = axis.chart;\n\n			redraw = pick(redraw, true); // defaults to true\n\n			each(axis.series, function (serie) {\n				delete serie.kdTree;\n			});\n\n			// Extend the arguments with min and max\n			eventArguments = extend(eventArguments, {\n				min: newMin,\n				max: newMax\n			});\n\n			// Fire the event\n			fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler\n\n				axis.userMin = newMin;\n				axis.userMax = newMax;\n				axis.eventArgs = eventArguments;\n\n				// Mark for running afterSetExtremes\n				axis.isDirtyExtremes = true;\n\n				// redraw\n				if (redraw) {\n					chart.redraw(animation);\n				}\n			});\n		},\n\n		/**\n		 * Overridable method for zooming chart. Pulled out in a separate method to allow overriding\n		 * in stock charts.\n		 */\n		zoom: function (newMin, newMax) {\n			var dataMin = this.dataMin,\n				dataMax = this.dataMax,\n				options = this.options;\n\n			// Prevent pinch zooming out of range. Check for defined is for #1946. #1734.\n			if (!this.allowZoomOutside) {\n				if (defined(dataMin) && newMin <= mathMin(dataMin, pick(options.min, dataMin))) {\n					newMin = UNDEFINED;\n				}\n				if (defined(dataMax) && newMax >= mathMax(dataMax, pick(options.max, dataMax))) {\n					newMax = UNDEFINED;\n				}\n			}\n\n			// In full view, displaying the reset zoom button is not required\n			this.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;\n\n			// Do it\n			this.setExtremes(\n				newMin,\n				newMax,\n				false,\n				UNDEFINED,\n				{ trigger: 'zoom' }\n			);\n			return true;\n		},\n\n		/**\n		 * Update the axis metrics\n		 */\n		setAxisSize: function () {\n			var chart = this.chart,\n				options = this.options,\n				offsetLeft = options.offsetLeft || 0,\n				offsetRight = options.offsetRight || 0,\n				horiz = this.horiz,\n				width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight),\n				height = pick(options.height, chart.plotHeight),\n				top = pick(options.top, chart.plotTop),\n				left = pick(options.left, chart.plotLeft + offsetLeft),\n				percentRegex = /%$/;\n\n			// Check for percentage based input values\n			if (percentRegex.test(height)) {\n				height = parseFloat(height) / 100 * chart.plotHeight;\n			}\n			if (percentRegex.test(top)) {\n				top = parseFloat(top) / 100 * chart.plotHeight + chart.plotTop;\n			}\n\n			// Expose basic values to use in Series object and navigator\n			this.left = left;\n			this.top = top;\n			this.width = width;\n			this.height = height;\n			this.bottom = chart.chartHeight - height - top;\n			this.right = chart.chartWidth - width - left;\n\n			// Direction agnostic properties\n			this.len = mathMax(horiz ? width : height, 0); // mathMax fixes #905\n			this.pos = horiz ? left : top; // distance from SVG origin\n		},\n\n		/**\n		 * Get the actual axis extremes\n		 */\n		getExtremes: function () {\n			var axis = this,\n				isLog = axis.isLog;\n\n			return {\n				min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,\n				max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,\n				dataMin: axis.dataMin,\n				dataMax: axis.dataMax,\n				userMin: axis.userMin,\n				userMax: axis.userMax\n			};\n		},\n\n		/**\n		 * Get the zero plane either based on zero or on the min or max value.\n		 * Used in bar and area plots\n		 */\n		getThreshold: function (threshold) {\n			var axis = this,\n				isLog = axis.isLog;\n\n			var realMin = isLog ? lin2log(axis.min) : axis.min,\n				realMax = isLog ? lin2log(axis.max) : axis.max;\n\n			if (realMin > threshold || threshold === null) {\n				threshold = realMin;\n			} else if (realMax < threshold) {\n				threshold = realMax;\n			}\n\n			return axis.translate(threshold, 0, 1, 0, 1);\n		},\n\n		/**\n		 * Compute auto alignment for the axis label based on which side the axis is on\n		 * and the given rotation for the label\n		 */\n		autoLabelAlign: function (rotation) {\n			var ret,\n				angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;\n\n			if (angle > 15 && angle < 165) {\n				ret = 'right';\n			} else if (angle > 195 && angle < 345) {\n				ret = 'left';\n			} else {\n				ret = 'center';\n			}\n			return ret;\n		},\n\n		/**\n		 * Prevent the ticks from getting so close we can't draw the labels. On a horizontal\n		 * axis, this is handled by rotating the labels, removing ticks and adding ellipsis. \n		 * On a vertical axis remove ticks and add ellipsis.\n		 */\n		unsquish: function () {\n			var chart = this.chart,\n				ticks = this.ticks,\n				labelOptions = this.options.labels,\n				horiz = this.horiz,\n				tickInterval = this.tickInterval,\n				newTickInterval = tickInterval,\n				slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),\n				rotation,\n				rotationOption = labelOptions.rotation,\n				labelMetrics = chart.renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),\n				step,\n				bestScore = Number.MAX_VALUE,\n				autoRotation,\n				// Return the multiple of tickInterval that is needed to avoid collision\n				getStep = function (spaceNeeded) {\n					var step = spaceNeeded / (slotSize || 1);\n					step = step > 1 ? mathCeil(step) : 1;\n					return step * tickInterval;\n				};\n			\n			if (horiz) {\n				autoRotation = defined(rotationOption) ? \n					[rotationOption] :\n					slotSize < 80 && !labelOptions.staggerLines && !labelOptions.step && labelOptions.autoRotation;\n\n				if (autoRotation) {\n\n					// Loop over the given autoRotation options, and determine which gives the best score. The \n					// best score is that with the lowest number of steps and a rotation closest to horizontal.\n					each(autoRotation, function (rot) {\n						var score;\n\n						if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891\n						\n							step = getStep(mathAbs(labelMetrics.h / mathSin(deg2rad * rot)));\n\n							score = step + mathAbs(rot / 360);\n\n							if (score < bestScore) {\n								bestScore = score;\n								rotation = rot;\n								newTickInterval = step;\n							}\n						}\n					});\n				}\n\n			} else {\n				newTickInterval = getStep(labelMetrics.h);\n			}\n\n			this.autoRotation = autoRotation;\n			this.labelRotation = rotation;\n\n			return newTickInterval;\n		},\n\n		renderUnsquish: function () {\n			var chart = this.chart,\n				renderer = chart.renderer,\n				tickPositions = this.tickPositions,\n				ticks = this.ticks,\n				labelOptions = this.options.labels,\n				horiz = this.horiz,\n				margin = chart.margin,\n				slotWidth = this.slotWidth = (horiz && !labelOptions.step && !labelOptions.rotation &&\n					((this.staggerLines || 1) * chart.plotWidth) / tickPositions.length) ||\n					(!horiz && ((margin[3] && (margin[3] - chart.spacing[3])) || chart.chartWidth * 0.33)), // #1580, #1931,\n				innerWidth = mathMax(1, mathRound(slotWidth - 2 * (labelOptions.padding || 5))),\n				attr = {},\n				labelMetrics = renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),\n				css,\n				labelLength = 0,\n				label,\n				i,\n				pos;\n\n			// Set rotation option unless it is \"auto\", like in gauges\n			if (!isString(labelOptions.rotation)) {\n				attr.rotation = labelOptions.rotation;\n			}\n			\n			// Handle auto rotation on horizontal axis\n			if (this.autoRotation) {\n\n				// Get the longest label length\n				each(tickPositions, function (tick) {\n					tick = ticks[tick];\n					if (tick && tick.labelLength > labelLength) {\n						labelLength = tick.labelLength;\n					}\n				});\n				\n				// Apply rotation only if the label is too wide for the slot, and\n				// the label is wider than its height.\n				if (labelLength > innerWidth && labelLength > labelMetrics.h) {\n					attr.rotation = this.labelRotation;\n				} else {\n					this.labelRotation = 0;\n				}\n\n			// Handle word-wrap or ellipsis on vertical axis\n			} else if (slotWidth) {\n				// For word-wrap or ellipsis\n				css = { width: innerWidth + PX, textOverflow: 'clip' };\n\n				// On vertical axis, only allow word wrap if there is room for more lines.\n				i = tickPositions.length;\n				while (!horiz && i--) {\n					pos = tickPositions[i];\n					label = ticks[pos].label;\n					if (label) {\n						if (this.len / tickPositions.length - 4 < label.getBBox().height) {\n							label.specCss = { textOverflow: 'ellipsis' };\n						}\n					}\n				}\n			}\n\n\n			// Add ellipsis if the label length is significantly longer than ideal\n			if (attr.rotation) {\n				css = { \n					width: (labelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + PX,\n					textOverflow: 'ellipsis'\n				};\n			}\n\n			// Set the explicit or automatic label alignment\n			this.labelAlign = attr.align = labelOptions.align || this.autoLabelAlign(this.labelRotation);\n\n			// Apply general and specific CSS\n			each(tickPositions, function (pos) {\n				var tick = ticks[pos],\n					label = tick && tick.label;\n				if (label) {\n					if (css) {\n						label.css(merge(css, label.specCss));\n					}\n					delete label.specCss;\n					label.attr(attr);\n					tick.rotation = attr.rotation;\n				}\n			});\n\n			// TODO: Why not part of getLabelPosition?\n			this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side === 2);\n		},\n\n		/**\n		 * Render the tick labels to a preliminary position to get their sizes\n		 */\n		getOffset: function () {\n			var axis = this,\n				chart = axis.chart,\n				renderer = chart.renderer,\n				options = axis.options,\n				tickPositions = axis.tickPositions,\n				ticks = axis.ticks,\n				horiz = axis.horiz,\n				side = axis.side,\n				invertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,\n				hasData,\n				showAxis,\n				titleOffset = 0,\n				titleOffsetOption,\n				titleMargin = 0,\n				axisTitleOptions = options.title,\n				labelOptions = options.labels,\n				labelOffset = 0, // reset\n				labelOffsetPadded,\n				axisOffset = chart.axisOffset,\n				clipOffset = chart.clipOffset,\n				directionFactor = [-1, 1, 1, -1][side],\n				n,\n				lineHeightCorrection;\n\n			// For reuse in Axis.render\n			axis.hasData = hasData = (axis.hasVisibleSeries || (defined(axis.min) && defined(axis.max) && !!tickPositions));\n			axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);\n\n			// Set/reset staggerLines\n			axis.staggerLines = axis.horiz && labelOptions.staggerLines;\n\n			// Create the axisGroup and gridGroup elements on first iteration\n			if (!axis.axisGroup) {\n				axis.gridGroup = renderer.g('grid')\n					.attr({ zIndex: options.gridZIndex || 1 })\n					.add();\n				axis.axisGroup = renderer.g('axis')\n					.attr({ zIndex: options.zIndex || 2 })\n					.add();\n				axis.labelGroup = renderer.g('axis-labels')\n					.attr({ zIndex: labelOptions.zIndex || 7 })\n					.addClass(PREFIX + axis.coll.toLowerCase() + '-labels')\n					.add();\n			}\n\n			if (hasData || axis.isLinked) {\n				\n				// Generate ticks\n				each(tickPositions, function (pos) {\n					if (!ticks[pos]) {\n						ticks[pos] = new Tick(axis, pos);\n					} else {\n						ticks[pos].addLabel(); // update labels depending on tick interval\n					}\n				});\n\n				axis.renderUnsquish();\n\n				each(tickPositions, function (pos) {\n					// left side must be align: right and right side must have align: left for labels\n					if (side === 0 || side === 2 || { 1: 'left', 3: 'right' }[side] === axis.labelAlign) {\n\n						// get the highest offset\n						labelOffset = mathMax(\n							ticks[pos].getLabelSize(),\n							labelOffset\n						);\n					}\n				});\n\n				if (axis.staggerLines) {\n					labelOffset *= axis.staggerLines;\n					axis.labelOffset = labelOffset;\n				}\n\n\n			} else { // doesn't have data\n				for (n in ticks) {\n					ticks[n].destroy();\n					delete ticks[n];\n				}\n			}\n\n			if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {\n				if (!axis.axisTitle) {\n					axis.axisTitle = renderer.text(\n						axisTitleOptions.text,\n						0,\n						0,\n						axisTitleOptions.useHTML\n					)\n					.attr({\n						zIndex: 7,\n						rotation: axisTitleOptions.rotation || 0,\n						align:\n							axisTitleOptions.textAlign ||\n							{ low: 'left', middle: 'center', high: 'right' }[axisTitleOptions.align]\n					})\n					.addClass(PREFIX + this.coll.toLowerCase() + '-title')\n					.css(axisTitleOptions.style)\n					.add(axis.axisGroup);\n					axis.axisTitle.isNew = true;\n				}\n\n				if (showAxis) {\n					titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];\n					titleOffsetOption = axisTitleOptions.offset;\n					titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);\n				}\n\n				// hide or show the title depending on whether showEmpty is set\n				axis.axisTitle[showAxis ? 'show' : 'hide']();\n			}\n\n			// handle automatic or user set offset\n			axis.offset = directionFactor * pick(options.offset, axisOffset[side]);\n\n			axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar\n			lineHeightCorrection = side === 2 ? axis.tickRotCorr.y : 0;\n			labelOffsetPadded = labelOffset + titleMargin +\n				(labelOffset && (directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + 8) : labelOptions.x) - lineHeightCorrection));\n			axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);\n\n			axisOffset[side] = mathMax(\n				axisOffset[side],\n				axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,\n				labelOffsetPadded // #3027\n			);\n			clipOffset[invertedSide] = mathMax(clipOffset[invertedSide], mathFloor(options.lineWidth / 2) * 2);\n		},\n\n		/**\n		 * Get the path for the axis line\n		 */\n		getLinePath: function (lineWidth) {\n			var chart = this.chart,\n				opposite = this.opposite,\n				offset = this.offset,\n				horiz = this.horiz,\n				lineLeft = this.left + (opposite ? this.width : 0) + offset,\n				lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;\n\n			if (opposite) {\n				lineWidth *= -1; // crispify the other way - #1480, #1687\n			}\n\n			return chart.renderer.crispLine([\n					M,\n					horiz ?\n						this.left :\n						lineLeft,\n					horiz ?\n						lineTop :\n						this.top,\n					L,\n					horiz ?\n						chart.chartWidth - this.right :\n						lineLeft,\n					horiz ?\n						lineTop :\n						chart.chartHeight - this.bottom\n				], lineWidth);\n		},\n\n		/**\n		 * Position the title\n		 */\n		getTitlePosition: function () {\n			// compute anchor points for each of the title align options\n			var horiz = this.horiz,\n				axisLeft = this.left,\n				axisTop = this.top,\n				axisLength = this.len,\n				axisTitleOptions = this.options.title,\n				margin = horiz ? axisLeft : axisTop,\n				opposite = this.opposite,\n				offset = this.offset,\n				fontSize = pInt(axisTitleOptions.style.fontSize || 12),\n\n				// the position in the length direction of the axis\n				alongAxis = {\n					low: margin + (horiz ? 0 : axisLength),\n					middle: margin + axisLength / 2,\n					high: margin + (horiz ? axisLength : 0)\n				}[axisTitleOptions.align],\n\n				// the position in the perpendicular direction of the axis\n				offAxis = (horiz ? axisTop + this.height : axisLeft) +\n					(horiz ? 1 : -1) * // horizontal axis reverses the margin\n					(opposite ? -1 : 1) * // so does opposite axes\n					this.axisTitleMargin +\n					(this.side === 2 ? fontSize : 0);\n\n			return {\n				x: horiz ?\n					alongAxis :\n					offAxis + (opposite ? this.width : 0) + offset +\n						(axisTitleOptions.x || 0), // x\n				y: horiz ?\n					offAxis - (opposite ? this.height : 0) + offset :\n					alongAxis + (axisTitleOptions.y || 0) // y\n			};\n		},\n\n		/**\n		 * Render the axis\n		 */\n		render: function () {\n			var axis = this,\n				chart = axis.chart,\n				renderer = chart.renderer,\n				options = axis.options,\n				isLog = axis.isLog,\n				isLinked = axis.isLinked,\n				tickPositions = axis.tickPositions,\n				axisTitle = axis.axisTitle,			\n				ticks = axis.ticks,\n				minorTicks = axis.minorTicks,\n				alternateBands = axis.alternateBands,\n				stackLabelOptions = options.stackLabels,\n				alternateGridColor = options.alternateGridColor,\n				tickmarkOffset = axis.tickmarkOffset,\n				lineWidth = options.lineWidth,\n				linePath,\n				hasRendered = chart.hasRendered,\n				slideInTicks = hasRendered && defined(axis.oldMin) && !isNaN(axis.oldMin),\n				hasData = axis.hasData,\n				showAxis = axis.showAxis,\n				from,\n				to;\n\n			// Reset\n			axis.labelEdge.length = 0;\n			//axis.justifyToPlot = overflow === 'justify';\n			axis.overlap = false;\n\n			// Mark all elements inActive before we go over and mark the active ones\n			each([ticks, minorTicks, alternateBands], function (coll) {\n				var pos;\n				for (pos in coll) {\n					coll[pos].isActive = false;\n				}\n			});\n\n			// If the series has data draw the ticks. Else only the line and title\n			if (hasData || isLinked) {\n\n				// minor ticks\n				if (axis.minorTickInterval && !axis.categories) {\n					each(axis.getMinorTickPositions(), function (pos) {\n						if (!minorTicks[pos]) {\n							minorTicks[pos] = new Tick(axis, pos, 'minor');\n						}\n\n						// render new ticks in old position\n						if (slideInTicks && minorTicks[pos].isNew) {\n							minorTicks[pos].render(null, true);\n						}\n\n						minorTicks[pos].render(null, false, 1);\n					});\n				}\n\n				// Major ticks. Pull out the first item and render it last so that\n				// we can get the position of the neighbour label. #808.\n				if (tickPositions.length) { // #1300\n					each(tickPositions, function (pos, i) {\n\n						// linked axes need an extra check to find out if\n						if (!isLinked || (pos >= axis.min && pos <= axis.max)) {\n\n							if (!ticks[pos]) {\n								ticks[pos] = new Tick(axis, pos);\n							}\n\n							// render new ticks in old position\n							if (slideInTicks && ticks[pos].isNew) {\n								ticks[pos].render(i, true, 0.1);\n							}\n\n							ticks[pos].render(i);\n						}\n\n					});\n					// In a categorized axis, the tick marks are displayed between labels. So\n					// we need to add a tick mark and grid line at the left edge of the X axis.\n					if (tickmarkOffset && (axis.min === 0 || axis.single)) {\n						if (!ticks[-1]) {\n							ticks[-1] = new Tick(axis, -1, null, true);\n						}\n						ticks[-1].render(-1);\n					}\n\n				}\n\n				// alternate grid color\n				if (alternateGridColor) {\n					each(tickPositions, function (pos, i) {\n						if (i % 2 === 0 && pos < axis.max) {\n							if (!alternateBands[pos]) {\n								alternateBands[pos] = new Highcharts.PlotLineOrBand(axis);\n							}\n							from = pos + tickmarkOffset; // #949\n							to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max;\n							alternateBands[pos].options = {\n								from: isLog ? lin2log(from) : from,\n								to: isLog ? lin2log(to) : to,\n								color: alternateGridColor\n							};\n							alternateBands[pos].render();\n							alternateBands[pos].isActive = true;\n						}\n					});\n				}\n\n				// custom plot lines and bands\n				if (!axis._addedPlotLB) { // only first time\n					each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {\n						axis.addPlotBandOrLine(plotLineOptions);\n					});\n					axis._addedPlotLB = true;\n				}\n\n			} // end if hasData\n\n			// Remove inactive ticks\n			each([ticks, minorTicks, alternateBands], function (coll) {\n				var pos,\n					i,\n					forDestruction = [],\n					delay = globalAnimation ? globalAnimation.duration || 500 : 0,\n					destroyInactiveItems = function () {\n						i = forDestruction.length;\n						while (i--) {\n							// When resizing rapidly, the same items may be destroyed in different timeouts,\n							// or the may be reactivated\n							if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {\n								coll[forDestruction[i]].destroy();\n								delete coll[forDestruction[i]];\n							}\n						}\n\n					};\n\n				for (pos in coll) {\n\n					if (!coll[pos].isActive) {\n						// Render to zero opacity\n						coll[pos].render(pos, false, 0);\n						coll[pos].isActive = false;\n						forDestruction.push(pos);\n					}\n				}\n\n				// When the objects are finished fading out, destroy them\n				if (coll === alternateBands || !chart.hasRendered || !delay) {\n					destroyInactiveItems();\n				} else if (delay) {\n					setTimeout(destroyInactiveItems, delay);\n				}\n			});\n\n			// Static items. As the axis group is cleared on subsequent calls\n			// to render, these items are added outside the group.\n			// axis line\n			if (lineWidth) {\n				linePath = axis.getLinePath(lineWidth);\n				if (!axis.axisLine) {\n					axis.axisLine = renderer.path(linePath)\n						.attr({\n							stroke: options.lineColor,\n							'stroke-width': lineWidth,\n							zIndex: 7\n						})\n						.add(axis.axisGroup);\n				} else {\n					axis.axisLine.animate({ d: linePath });\n				}\n\n				// show or hide the line depending on options.showEmpty\n				axis.axisLine[showAxis ? 'show' : 'hide']();\n			}\n\n			if (axisTitle && showAxis) {\n\n				axisTitle[axisTitle.isNew ? 'attr' : 'animate'](\n					axis.getTitlePosition()\n				);\n				axisTitle.isNew = false;\n			}\n\n			// Stacked totals:\n			if (stackLabelOptions && stackLabelOptions.enabled) {\n				axis.renderStackTotals();\n			}\n			// End stacked totals\n\n			axis.isDirty = false;\n		},\n\n		/**\n		 * Redraw the axis to reflect changes in the data or axis extremes\n		 */\n		redraw: function () {\n			\n			// render the axis\n			this.render();\n\n			// move plot lines and bands\n			each(this.plotLinesAndBands, function (plotLine) {\n				plotLine.render();\n			});\n\n			// mark associated series as dirty and ready for redraw\n			each(this.series, function (series) {\n				series.isDirty = true;\n			});\n\n		},\n\n		/**\n		 * Destroys an Axis instance.\n		 */\n		destroy: function (keepEvents) {\n			var axis = this,\n				stacks = axis.stacks,\n				stackKey,\n				plotLinesAndBands = axis.plotLinesAndBands,\n				i;\n\n			// Remove the events\n			if (!keepEvents) {\n				removeEvent(axis);\n			}\n\n			// Destroy each stack total\n			for (stackKey in stacks) {\n				destroyObjectProperties(stacks[stackKey]);\n\n				stacks[stackKey] = null;\n			}\n\n			// Destroy collections\n			each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {\n				destroyObjectProperties(coll);\n			});\n			i = plotLinesAndBands.length;\n			while (i--) { // #1975\n				plotLinesAndBands[i].destroy();\n			}\n\n			// Destroy local variables\n			each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'cross', 'gridGroup', 'labelGroup'], function (prop) {\n				if (axis[prop]) {\n					axis[prop] = axis[prop].destroy();\n				}\n			});\n\n			// Destroy crosshair\n			if (this.cross) {\n				this.cross.destroy();\n			}\n		},\n\n		/**\n		 * Draw the crosshair\n		 */\n		drawCrosshair: function (e, point) { // docs: Missing docs for Axis.crosshair. Also for properties.\n\n			var path,\n				options = this.crosshair,\n				animation = options.animation,\n				pos,\n				attribs,\n				categorized;\n			\n			if (\n				// Disabled in options\n				!this.crosshair || \n				// Snap\n				((defined(point) || !pick(this.crosshair.snap, true)) === false)\n			) {\n				this.hideCrosshair();\n			\n			} else {			\n\n				// Get the path\n				if (!pick(options.snap, true)) {\n					pos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);\n				} else if (defined(point)) {\n					/*jslint eqeq: true*/\n					pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834\n					/*jslint eqeq: false*/\n				}\n\n				if (this.isRadial) {\n					path = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y)) || null; // #3189\n				} else {\n					path = this.getPlotLinePath(null, null, null, null, pos) || null; // #3189\n				}\n\n				if (path === null) {\n					this.hideCrosshair();\n					return;\n				}\n\n				// Draw the cross\n				if (this.cross) {\n					this.cross\n						.attr({ visibility: VISIBLE })[animation ? 'animate' : 'attr']({ d: path }, animation);\n				} else {\n					categorized = this.categories && !this.isRadial;\n					attribs = {\n						'stroke-width': options.width || (categorized ? this.transA : 1),\n						stroke: options.color || (categorized ? 'rgba(155,200,255,0.2)' : '#C0C0C0'),\n						zIndex: options.zIndex || 2\n					};\n					if (options.dashStyle) {\n						attribs.dashstyle = options.dashStyle;\n					}\n					this.cross = this.chart.renderer.path(path).attr(attribs).add();\n				}\n\n			}\n\n		},\n\n		/**\n		 *	Hide the crosshair.\n		 */\n		hideCrosshair: function () {\n			if (this.cross) {\n				this.cross.hide();\n			}\n		}\n	}; // end Axis\n\n	extend(Axis.prototype, AxisPlotLineOrBandExtension);\n\n	/**\n	 * Set the tick positions to a time unit that makes sense, for example\n	 * on the first of each month or on every Monday. Return an array\n	 * with the time positions. Used in datetime axes as well as for grouping\n	 * data on a datetime axis.\n	 *\n	 * @param {Object} normalizedInterval The interval in axis values (ms) and the count\n	 * @param {Number} min The minimum in axis values\n	 * @param {Number} max The maximum in axis values\n	 * @param {Number} startOfWeek\n	 */\n	Axis.prototype.getTimeTicks = function (normalizedInterval, min, max, startOfWeek) {\n		var tickPositions = [],\n			i,\n			higherRanks = {},\n			useUTC = defaultOptions.global.useUTC,\n			minYear, // used in months and years as a basis for Date.UTC()\n			minDate = new Date(min - getTZOffset(min)),\n			interval = normalizedInterval.unitRange,\n			count = normalizedInterval.count;\n\n		if (defined(min)) { // #1300\n			minDate.setMilliseconds(interval >= timeUnits.second ? 0 :\n				count * mathFloor(minDate.getMilliseconds() / count)); // #3652, #3654\n\n			if (interval >= timeUnits.second) { // second\n				minDate.setSeconds(interval >= timeUnits.minute ? 0 :\n					count * mathFloor(minDate.getSeconds() / count));\n			}\n		\n			if (interval >= timeUnits.minute) { // minute\n				minDate[setMinutes](interval >= timeUnits.hour ? 0 :\n					count * mathFloor(minDate[getMinutes]() / count));\n			}\n		\n			if (interval >= timeUnits.hour) { // hour\n				minDate[setHours](interval >= timeUnits.day ? 0 :\n					count * mathFloor(minDate[getHours]() / count));\n			}\n		\n			if (interval >= timeUnits.day) { // day\n				minDate[setDate](interval >= timeUnits.month ? 1 :\n					count * mathFloor(minDate[getDate]() / count));\n			}\n		\n			if (interval >= timeUnits.month) { // month\n				minDate[setMonth](interval >= timeUnits.year ? 0 :\n					count * mathFloor(minDate[getMonth]() / count));\n				minYear = minDate[getFullYear]();\n			}\n		\n			if (interval >= timeUnits.year) { // year\n				minYear -= minYear % count;\n				minDate[setFullYear](minYear);\n			}\n		\n			// week is a special case that runs outside the hierarchy\n			if (interval === timeUnits.week) {\n				// get start of current week, independent of count\n				minDate[setDate](minDate[getDate]() - minDate[getDay]() +\n					pick(startOfWeek, 1));\n			}\n		\n		\n			// get tick positions\n			i = 1;\n			if (timezoneOffset || getTimezoneOffset) {\n				minDate = minDate.getTime();\n				minDate = new Date(minDate + getTZOffset(minDate));\n			}\n			minYear = minDate[getFullYear]();\n			var time = minDate.getTime(),\n				minMonth = minDate[getMonth](),\n				minDateDate = minDate[getDate](),\n				localTimezoneOffset = (timeUnits.day + \n						(useUTC ? getTZOffset(minDate) : minDate.getTimezoneOffset() * 60 * 1000)\n					) % timeUnits.day; // #950, #3359\n		\n			// iterate and add tick positions at appropriate values\n			while (time < max) {\n				tickPositions.push(time);\n		\n				// if the interval is years, use Date.UTC to increase years\n				if (interval === timeUnits.year) {\n					time = makeTime(minYear + i * count, 0);\n		\n				// if the interval is months, use Date.UTC to increase months\n				} else if (interval === timeUnits.month) {\n					time = makeTime(minYear, minMonth + i * count);\n		\n				// if we're using global time, the interval is not fixed as it jumps\n				// one hour at the DST crossover\n				} else if (!useUTC && (interval === timeUnits.day || interval === timeUnits.week)) {\n					time = makeTime(minYear, minMonth, minDateDate +\n						i * count * (interval === timeUnits.day ? 1 : 7));\n		\n				// else, the interval is fixed and we use simple addition\n				} else {\n					time += interval * count;\n				}\n		\n				i++;\n			}\n		\n			// push the last time\n			tickPositions.push(time);\n\n\n			// mark new days if the time is dividible by day (#1649, #1760)\n			each(grep(tickPositions, function (time) {\n				return interval <= timeUnits.hour && time % timeUnits.day === localTimezoneOffset;\n			}), function (time) {\n				higherRanks[time] = 'day';\n			});\n		}\n\n\n		// record information on the chosen unit - for dynamic label formatter\n		tickPositions.info = extend(normalizedInterval, {\n			higherRanks: higherRanks,\n			totalRange: interval * count\n		});\n\n		return tickPositions;\n	};\n\n	/**\n	 * Get a normalized tick interval for dates. Returns a configuration object with\n	 * unit range (interval), count and name. Used to prepare data for getTimeTicks. \n	 * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs\n	 * of segments in stock charts, the normalizing logic was extracted in order to \n	 * prevent it for running over again for each segment having the same interval. \n	 * #662, #697.\n	 */\n	Axis.prototype.normalizeTimeTickInterval = function (tickInterval, unitsOption) {\n		var units = unitsOption || [[\n					'millisecond', // unit name\n					[1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n				], [\n					'second',\n					[1, 2, 5, 10, 15, 30]\n				], [\n					'minute',\n					[1, 2, 5, 10, 15, 30]\n				], [\n					'hour',\n					[1, 2, 3, 4, 6, 8, 12]\n				], [\n					'day',\n					[1, 2]\n				], [\n					'week',\n					[1, 2]\n				], [\n					'month',\n					[1, 2, 3, 4, 6]\n				], [\n					'year',\n					null\n				]],\n			unit = units[units.length - 1], // default unit is years\n			interval = timeUnits[unit[0]],\n			multiples = unit[1],\n			count,\n			i;\n			\n		// loop through the units to find the one that best fits the tickInterval\n		for (i = 0; i < units.length; i++) {\n			unit = units[i];\n			interval = timeUnits[unit[0]];\n			multiples = unit[1];\n\n\n			if (units[i + 1]) {\n				// lessThan is in the middle between the highest multiple and the next unit.\n				var lessThan = (interval * multiples[multiples.length - 1] +\n							timeUnits[units[i + 1][0]]) / 2;\n\n				// break and keep the current unit\n				if (tickInterval <= lessThan) {\n					break;\n				}\n			}\n		}\n\n		// prevent 2.5 years intervals, though 25, 250 etc. are allowed\n		if (interval === timeUnits.year && tickInterval < 5 * interval) {\n			multiples = [1, 2, 5];\n		}\n\n		// get the count\n		count = normalizeTickInterval(\n			tickInterval / interval, \n			multiples,\n			unit[0] === 'year' ? mathMax(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360\n		);\n		\n		return {\n			unitRange: interval,\n			count: count,\n			unitName: unit[0]\n		};\n	};/**\n	 * Methods defined on the Axis prototype\n	 */\n\n	/**\n	 * Set the tick positions of a logarithmic axis\n	 */\n	Axis.prototype.getLogTickPositions = function (interval, min, max, minor) {\n		var axis = this,\n			options = axis.options,\n			axisLength = axis.len,\n			// Since we use this method for both major and minor ticks,\n			// use a local variable and return the result\n			positions = []; \n		\n		// Reset\n		if (!minor) {\n			axis._minorAutoInterval = null;\n		}\n		\n		// First case: All ticks fall on whole logarithms: 1, 10, 100 etc.\n		if (interval >= 0.5) {\n			interval = mathRound(interval);\n			positions = axis.getLinearTickPositions(interval, min, max);\n			\n		// Second case: We need intermediary ticks. For example \n		// 1, 2, 4, 6, 8, 10, 20, 40 etc. \n		} else if (interval >= 0.08) {\n			var roundedMin = mathFloor(min),\n				intermediate,\n				i,\n				j,\n				len,\n				pos,\n				lastPos,\n				break2;\n				\n			if (interval > 0.3) {\n				intermediate = [1, 2, 4];\n			} else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc\n				intermediate = [1, 2, 4, 6, 8];\n			} else { // 0.1 equals ten minor ticks per 1, 10, 100 etc\n				intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n			}\n			\n			for (i = roundedMin; i < max + 1 && !break2; i++) {\n				len = intermediate.length;\n				for (j = 0; j < len && !break2; j++) {\n					pos = log2lin(lin2log(i) * intermediate[j]);\n					if (pos > min && (!minor || lastPos <= max) && lastPos !== UNDEFINED) { // #1670, lastPos is #3113\n						positions.push(lastPos);\n					}\n					\n					if (lastPos > max) {\n						break2 = true;\n					}\n					lastPos = pos;\n				}\n			}\n			\n		// Third case: We are so deep in between whole logarithmic values that\n		// we might as well handle the tick positions like a linear axis. For\n		// example 1.01, 1.02, 1.03, 1.04.\n		} else {\n			var realMin = lin2log(min),\n				realMax = lin2log(max),\n				tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],\n				filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,\n				tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),\n				totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;\n			\n			interval = pick(\n				filteredTickIntervalOption,\n				axis._minorAutoInterval,\n				(realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)\n			);\n			\n			interval = normalizeTickInterval(\n				interval, \n				null, \n				getMagnitude(interval)\n			);\n			\n			positions = map(axis.getLinearTickPositions(\n				interval, \n				realMin,\n				realMax	\n			), log2lin);\n			\n			if (!minor) {\n				axis._minorAutoInterval = interval / 5;\n			}\n		}\n		\n		// Set the axis-level tickInterval variable \n		if (!minor) {\n			axis.tickInterval = interval;\n		}\n		return positions;\n	};/**\n	 * The tooltip object\n	 * @param {Object} chart The chart instance\n	 * @param {Object} options Tooltip options\n	 */\n	var Tooltip = Highcharts.Tooltip = function () {\n		this.init.apply(this, arguments);\n	};\n\n	Tooltip.prototype = {\n\n		init: function (chart, options) {\n\n			var borderWidth = options.borderWidth,\n				style = options.style,\n				padding = pInt(style.padding);\n\n			// Save the chart and options\n			this.chart = chart;\n			this.options = options;\n\n			// Keep track of the current series\n			//this.currentSeries = UNDEFINED;\n\n			// List of crosshairs\n			this.crosshairs = [];\n\n			// Current values of x and y when animating\n			this.now = { x: 0, y: 0 };\n\n			// The tooltip is initially hidden\n			this.isHidden = true;\n\n\n			// create the label		\n			this.label = chart.renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip')\n				.attr({\n					padding: padding,\n					fill: options.backgroundColor,\n					'stroke-width': borderWidth,\n					r: options.borderRadius,\n					zIndex: 8\n				})\n				.css(style)\n				.css({ padding: 0 }) // Remove it from VML, the padding is applied as an attribute instead (#1117)\n				.add()\n				.attr({ y: -9999 }); // #2301, #2657\n\n			// When using canVG the shadow shows up as a gray circle\n			// even if the tooltip is hidden.\n			if (!useCanVG) {\n				this.label.shadow(options.shadow);\n			}\n\n			// Public property for getting the shared state.\n			this.shared = options.shared;\n		},\n\n		/**\n		 * Destroy the tooltip and its elements.\n		 */\n		destroy: function () {\n			// Destroy and clear local variables\n			if (this.label) {\n				this.label = this.label.destroy();\n			}\n			clearTimeout(this.hideTimer);\n			clearTimeout(this.tooltipTimeout);\n		},\n\n		/**\n		 * Provide a soft movement for the tooltip\n		 *\n		 * @param {Number} x\n		 * @param {Number} y\n		 * @private\n		 */\n		move: function (x, y, anchorX, anchorY) {\n			var tooltip = this,\n				now = tooltip.now,\n				animate = tooltip.options.animation !== false && !tooltip.isHidden && \n					// When we get close to the target position, abort animation and land on the right place (#3056)\n					(mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1),\n				skipAnchor = tooltip.followPointer || tooltip.len > 1;\n\n			// Get intermediate values for animation\n			extend(now, {\n				x: animate ? (2 * now.x + x) / 3 : x,\n				y: animate ? (now.y + y) / 2 : y,\n				anchorX: skipAnchor ? UNDEFINED : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,\n				anchorY: skipAnchor ? UNDEFINED : animate ? (now.anchorY + anchorY) / 2 : anchorY\n			});\n\n			// Move to the intermediate value\n			tooltip.label.attr(now);\n\n			\n			// Run on next tick of the mouse tracker\n			if (animate) {\n			\n				// Never allow two timeouts\n				clearTimeout(this.tooltipTimeout);\n				\n				// Set the fixed interval ticking for the smooth tooltip\n				this.tooltipTimeout = setTimeout(function () {\n					// The interval function may still be running during destroy, so check that the chart is really there before calling.\n					if (tooltip) {\n						tooltip.move(x, y, anchorX, anchorY);\n					}\n				}, 32);\n				\n			}\n		},\n\n		/**\n		 * Hide the tooltip\n		 */\n		hide: function (delay) {\n			var tooltip = this,\n				hoverPoints;\n			\n			clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)\n			if (!this.isHidden) {\n				hoverPoints = this.chart.hoverPoints;\n\n				this.hideTimer = setTimeout(function () {\n					tooltip.label.fadeOut();\n					tooltip.isHidden = true;\n				}, pick(delay, this.options.hideDelay, 500));\n\n				// hide previous hoverPoints and set new\n				if (hoverPoints) {\n					each(hoverPoints, function (point) {\n						point.setState();\n					});\n				}\n\n				this.chart.hoverPoints = null;\n				this.chart.hoverSeries = null;\n			}\n		},\n		\n		/** \n		 * Extendable method to get the anchor position of the tooltip\n		 * from a point or set of points\n		 */\n		getAnchor: function (points, mouseEvent) {\n			var ret,\n				chart = this.chart,\n				inverted = chart.inverted,\n				plotTop = chart.plotTop,\n				plotLeft = chart.plotLeft,\n				plotX = 0,\n				plotY = 0,\n				yAxis,\n				xAxis;\n			\n			points = splat(points);\n			\n			// Pie uses a special tooltipPos\n			ret = points[0].tooltipPos;\n			\n			// When tooltip follows mouse, relate the position to the mouse\n			if (this.followPointer && mouseEvent) {\n				if (mouseEvent.chartX === UNDEFINED) {\n					mouseEvent = chart.pointer.normalize(mouseEvent);\n				}\n				ret = [\n					mouseEvent.chartX - chart.plotLeft,\n					mouseEvent.chartY - plotTop\n				];\n			}\n			// When shared, use the average position\n			if (!ret) {\n				each(points, function (point) {\n					yAxis = point.series.yAxis;\n					xAxis = point.series.xAxis;\n					plotX += point.plotX  + (!inverted && xAxis ? xAxis.left - plotLeft : 0); \n					plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +\n						(!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151\n				});\n				\n				plotX /= points.length;\n				plotY /= points.length;\n				\n				ret = [\n					inverted ? chart.plotWidth - plotY : plotX,\n					this.shared && !inverted && points.length > 1 && mouseEvent ? \n						mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)\n						inverted ? chart.plotHeight - plotX : plotY\n				];\n			}\n\n			return map(ret, mathRound);\n		},\n		\n		/**\n		 * Place the tooltip in a chart without spilling over\n		 * and not covering the point it self.\n		 */\n		getPosition: function (boxWidth, boxHeight, point) {\n			\n			var chart = this.chart,\n				distance = this.distance,\n				ret = {},\n				h = point.h,\n				swapped,\n				first = ['y', chart.chartHeight, boxHeight, point.plotY + chart.plotTop],\n				second = ['x', chart.chartWidth, boxWidth, point.plotX + chart.plotLeft],\n				// The far side is right or bottom\n				preferFarSide = pick(point.ttBelow, (chart.inverted && !point.negative) || (!chart.inverted && point.negative)),\n				/**\n				 * Handle the preferred dimension. When the preferred dimension is tooltip\n				 * on top or bottom of the point, it will look for space there.\n				 */\n				firstDimension = function (dim, outerSize, innerSize, point) {\n					var roomLeft = innerSize < point - distance,\n						roomRight = point + distance + innerSize < outerSize,\n						alignedLeft = point - distance - innerSize,\n						alignedRight = point + distance;\n\n					if (preferFarSide && roomRight) {\n						ret[dim] = alignedRight;\n					} else if (!preferFarSide && roomLeft) {\n						ret[dim] = alignedLeft;\n					} else if (roomLeft) {\n						ret[dim] = alignedLeft - h < 0 ? alignedLeft : alignedLeft - h;\n					} else if (roomRight) {\n						ret[dim] = alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h;\n					} else {\n						return false;\n					}\n				},\n				/**\n				 * Handle the secondary dimension. If the preferred dimension is tooltip\n				 * on top or bottom of the point, the second dimension is to align the tooltip\n				 * above the point, trying to align center but allowing left or right\n				 * align within the chart box.\n				 */\n				secondDimension = function (dim, outerSize, innerSize, point) {\n					// Too close to the edge, return false and swap dimensions\n					if (point < distance || point > outerSize - distance) {\n						return false;\n					\n					// Align left/top\n					} else if (point < innerSize / 2) {\n						ret[dim] = 1;\n					// Align right/bottom\n					} else if (point > outerSize - innerSize / 2) {\n						ret[dim] = outerSize - innerSize - 2;\n					// Align center\n					} else {\n						ret[dim] = point - innerSize / 2;\n					}\n				},\n				/**\n				 * Swap the dimensions \n				 */\n				swap = function (count) {\n					var temp = first;\n					first = second;\n					second = temp;\n					swapped = count;\n				},\n				run = function () {\n					if (firstDimension.apply(0, first) !== false) {\n						if (secondDimension.apply(0, second) === false && !swapped) {\n							swap(true);\n							run();\n						}\n					} else if (!swapped) {\n						swap(true);\n						run();\n					} else {\n						ret.x = ret.y = 0;\n					}\n				};\n\n			// Under these conditions, prefer the tooltip on the side of the point\n			if (chart.inverted || this.len > 1) {\n				swap();\n			}\n			run();\n\n			return ret;\n		\n		},\n\n		/**\n		 * In case no user defined formatter is given, this will be used. Note that the context\n		 * here is an object holding point, series, x, y etc.\n		 */\n		defaultFormatter: function (tooltip) {\n			var items = this.points || splat(this),\n				s;\n\n			// build the header\n			s = [tooltip.tooltipFooterHeaderFormatter(items[0])]; //#3397: abstraction to enable formatting of footer and header\n\n			// build the values\n			s = s.concat(tooltip.bodyFormatter(items));\n\n			// footer\n			s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true)); //#3397: abstraction to enable formatting of footer and header\n\n			return s.join('');\n		},\n\n		/**\n		 * Refresh the tooltip's text and position.\n		 * @param {Object} point\n		 */\n		refresh: function (point, mouseEvent) {\n			var tooltip = this,\n				chart = tooltip.chart,\n				label = tooltip.label,\n				options = tooltip.options,\n				x,\n				y,\n				anchor,\n				textConfig = {},\n				text,\n				pointConfig = [],\n				formatter = options.formatter || tooltip.defaultFormatter,\n				hoverPoints = chart.hoverPoints,\n				borderColor,\n				shared = tooltip.shared,\n				currentSeries;\n				\n			clearTimeout(this.hideTimer);\n			\n			// get the reference point coordinates (pie charts use tooltipPos)\n			tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;\n			anchor = tooltip.getAnchor(point, mouseEvent);\n			x = anchor[0];\n			y = anchor[1];\n\n			// shared tooltip, array is sent over\n			if (shared && !(point.series && point.series.noSharedTooltip)) {\n				\n				// hide previous hoverPoints and set new\n				\n				chart.hoverPoints = point;\n				if (hoverPoints) {\n					each(hoverPoints, function (point) {\n						point.setState();\n					});\n				}\n\n				each(point, function (item) {\n					item.setState(HOVER_STATE);\n\n					pointConfig.push(item.getLabelConfig());\n				});\n\n				textConfig = {\n					x: point[0].category,\n					y: point[0].y\n				};\n				textConfig.points = pointConfig;\n				this.len = pointConfig.length;\n				point = point[0];\n\n			// single point tooltip\n			} else {\n				textConfig = point.getLabelConfig();\n			}\n			text = formatter.call(textConfig, tooltip);\n\n			// register the current series\n			currentSeries = point.series;\n			this.distance = pick(currentSeries.tooltipOptions.distance, 16);\n\n			// update the inner HTML\n			if (text === false) {\n				this.hide();\n			} else {\n\n				// show it\n				if (tooltip.isHidden) {\n					stop(label);\n					label.attr('opacity', 1).show();\n				}\n\n				// update text\n				label.attr({\n					text: text\n				});\n\n				// set the stroke color of the box\n				borderColor = options.borderColor || point.color || currentSeries.color || '#606060';\n				label.attr({\n					stroke: borderColor\n				});\n				tooltip.updatePosition({ \n					plotX: x, \n					plotY: y, \n					negative: point.negative, \n					ttBelow: point.ttBelow, \n					h: (point.shapeArgs && point.shapeArgs.height) || 0\n				});\n			\n				this.isHidden = false;\n			}\n			fireEvent(chart, 'tooltipRefresh', {\n					text: text,\n					x: x + chart.plotLeft,\n					y: y + chart.plotTop,\n					borderColor: borderColor\n				});\n		},\n		\n		/**\n		 * Find the new position and perform the move\n		 */\n		updatePosition: function (point) {\n			var chart = this.chart,\n				label = this.label, \n				pos = (this.options.positioner || this.getPosition).call(\n					this,\n					label.width,\n					label.height,\n					point\n				);\n\n			// do the move\n			this.move(\n				mathRound(pos.x), \n				mathRound(pos.y), \n				point.plotX + chart.plotLeft, \n				point.plotY + chart.plotTop\n			);\n		},\n\n		/** \n		 * Get the best X date format based on the closest point range on the axis.\n		 */\n		getXDateFormat: function (point, options, xAxis) {\n			var xDateFormat,\n				dateTimeLabelFormats = options.dateTimeLabelFormats,\n				closestPointRange = xAxis && xAxis.closestPointRange,\n				n,\n				blank = '01-01 00:00:00.000',\n				strpos = {\n					millisecond: 15,\n					second: 12,\n					minute: 9,\n					hour: 6,\n					day: 3\n				},\n				date,\n				lastN;\n\n			if (closestPointRange) {\n				date = dateFormat('%m-%d %H:%M:%S.%L', point.x);\n				for (n in timeUnits) {\n\n					// If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format\n					if (closestPointRange === timeUnits.week && +dateFormat('%w', point.x) === xAxis.options.startOfWeek && \n							date.substr(6) === blank.substr(6)) {\n						n = 'week';\n						break;\n\n					// The first format that is too great for the range\n					} else if (timeUnits[n] > closestPointRange) {\n						n = lastN;\n						break;\n					\n					// If the point is placed every day at 23:59, we need to show\n					// the minutes as well. #2637.\n					} else if (strpos[n] && date.substr(strpos[n]) !== blank.substr(strpos[n])) {\n						break;\n					}\n\n					// Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition\n					if (n !== 'week') {\n						lastN = n;\n					}\n				}\n				\n				if (n) {\n					xDateFormat = dateTimeLabelFormats[n];\n				}\n			} else {\n				xDateFormat = dateTimeLabelFormats.day;\n			}\n\n			return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581\n		},\n\n		/**\n		 * Format the footer/header of the tooltip\n		 * #3397: abstraction to enable formatting of footer and header\n		 */\n		tooltipFooterHeaderFormatter: function (point, isFooter) {\n			var footOrHead = isFooter ? 'footer' : 'header',\n				series = point.series,\n				tooltipOptions = series.tooltipOptions,\n				xDateFormat = tooltipOptions.xDateFormat,\n				xAxis = series.xAxis,\n				isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(point.key),\n				formatString = tooltipOptions[footOrHead+'Format'];\n\n			// Guess the best date format based on the closest point distance (#568, #3418)\n			if (isDateTime && !xDateFormat) {\n				xDateFormat = this.getXDateFormat(point, tooltipOptions, xAxis);\n			}\n\n			// Insert the footer date format if any\n			if (isDateTime && xDateFormat) {\n				formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');\n			}\n\n			return format(formatString, {\n				point: point,\n				series: series\n			});\n		},\n\n		/**\n	     * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,\n	     * abstracting this functionality allows to easily overwrite and extend it. \n		 */\n		bodyFormatter: function (items) {\n	        return map(items, function (item) {\n	            var tooltipOptions = item.series.tooltipOptions;\n	            return (tooltipOptions.pointFormatter || item.point.tooltipFormatter).call(item.point, tooltipOptions.pointFormat);\n	        });\n	    }\n	    \n	};\n\n	var hoverChartIndex;\n\n	// Global flag for touch support\n	hasTouch = doc.documentElement.ontouchstart !== UNDEFINED;\n\n	/**\n	 * The mouse tracker object. All methods starting with \"on\" are primary DOM event handlers. \n	 * Subsequent methods should be named differently from what they are doing.\n	 * @param {Object} chart The Chart instance\n	 * @param {Object} options The root options object\n	 */\n	var Pointer = Highcharts.Pointer = function (chart, options) {\n		this.init(chart, options);\n	};\n\n	Pointer.prototype = {\n		/**\n		 * Initialize Pointer\n		 */\n		init: function (chart, options) {\n			\n			var chartOptions = options.chart,\n				chartEvents = chartOptions.events,\n				zoomType = useCanVG ? '' : chartOptions.zoomType,\n				inverted = chart.inverted,\n				zoomX,\n				zoomY;\n\n			// Store references\n			this.options = options;\n			this.chart = chart;\n			\n			// Zoom status\n			this.zoomX = zoomX = /x/.test(zoomType);\n			this.zoomY = zoomY = /y/.test(zoomType);\n			this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);\n			this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);\n			this.hasZoom = zoomX || zoomY;\n\n			// Do we need to handle click on a touch device?\n			this.runChartClick = chartEvents && !!chartEvents.click;\n\n			this.pinchDown = [];\n			this.lastValidTouch = {};\n\n			if (Highcharts.Tooltip && options.tooltip.enabled) {\n				chart.tooltip = new Tooltip(chart, options.tooltip);\n				this.followTouchMove = pick(options.tooltip.followTouchMove, true);\n			}\n\n			this.setDOMEvents();\n		}, \n\n		/**\n		 * Add crossbrowser support for chartX and chartY\n		 * @param {Object} e The event object in standard browsers\n		 */\n		normalize: function (e, chartPosition) {\n			var chartX,\n				chartY,\n				ePos;\n\n			// common IE normalizing\n			e = e || window.event;\n\n			// Framework specific normalizing (#1165)\n			e = washMouseEvent(e);\n\n			// More IE normalizing, needs to go after washMouseEvent\n			if (!e.target) {\n				e.target = e.srcElement;\n			}\n			\n			// iOS (#2757)\n			ePos = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;\n\n			// Get mouse position\n			if (!chartPosition) {\n				this.chartPosition = chartPosition = offset(this.chart.container);\n			}\n\n			// chartX and chartY\n			if (ePos.pageX === UNDEFINED) { // IE < 9. #886.\n				chartX = mathMax(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is \n					// for IE10 quirks mode within framesets\n				chartY = e.y;\n			} else {\n				chartX = ePos.pageX - chartPosition.left;\n				chartY = ePos.pageY - chartPosition.top;\n			}\n\n			return extend(e, {\n				chartX: mathRound(chartX),\n				chartY: mathRound(chartY)\n			});\n		},\n\n		/**\n		 * Get the click position in terms of axis values.\n		 *\n		 * @param {Object} e A pointer event\n		 */\n		getCoordinates: function (e) {\n			var coordinates = {\n					xAxis: [],\n					yAxis: []\n				};\n\n			each(this.chart.axes, function (axis) {\n				coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({\n					axis: axis,\n					value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])\n				});\n			});\n			return coordinates;\n		},\n		\n		/**\n		 * With line type charts with a single tracker, get the point closest to the mouse.\n		 * Run Point.onMouseOver and display tooltip for the point or points.\n		 */\n		runPointActions: function (e) {\n\n			var pointer = this,\n				chart = pointer.chart,\n				series = chart.series,\n				tooltip = chart.tooltip,\n				shared = tooltip ? tooltip.shared : false,\n				followPointer,\n				//point,\n				//points,\n				hoverPoint = chart.hoverPoint,\n				hoverSeries = chart.hoverSeries,\n				i,\n				//j,\n				distance = chart.chartWidth,\n				rdistance = chart.chartWidth,\n				anchor,\n				noSharedTooltip,\n				kdpoints = [],\n				kdpoint,\n				kdpointT;\n\n			// For hovering over the empty parts of the plot area (hoverSeries is undefined). \n			// If there is one series with point tracking (combo chart), don't go to nearest neighbour.\n			if (!shared && !hoverSeries) {\n				for (i = 0; i < series.length; i++) {\n					if (series[i].directTouch || !series[i].options.stickyTracking) {\n						series = [];\n					}\n				}\n			}\n\n			// Handle shared tooltip or cases where a series is not yet hovered\n			if (!(hoverSeries && hoverSeries.noSharedTooltip) && (shared || !hoverSeries)) { // #3821 \n				// Find nearest points on all series\n				each(series, function (s) {\n					// Skip hidden series\n					noSharedTooltip = s.noSharedTooltip && shared;\n					if (s.visible && !noSharedTooltip && pick(s.options.enableMouseTracking, true)) { // #3821\n						kdpointT = s.searchPoint(e); // #3828\n						if (kdpointT) {\n							kdpoints.push(kdpointT);\n						}\n					}\n				});\n				// Find absolute nearest point\n				each(kdpoints, function (p) {\n					if (p && defined(p.plotX) && defined(p.plotY)) {\n						if ((p.dist.distX < distance) || ((p.dist.distX === distance || p.series.kdDimensions > 1) && p.dist.distR < rdistance)) {\n							distance = p.dist.distX;\n							rdistance = p.dist.distR;\n							kdpoint = p;\n						}\n					}\n				});	\n\n			// Handle non-shared tooltips\n			} else {\n				// If it has a hoverPoint and that series requires direct touch (like columns), use the hoverPoint (#3899).\n				// Otherwise, search the k-d tree (like scatter).\n				kdpoint = (hoverSeries.directTouch && hoverPoint) || (hoverSeries && hoverSeries.searchPoint(e));\n			}\n\n			// Refresh tooltip for kdpoint if new hover point or tooltip was hidden // #3926\n			if (kdpoint && (kdpoint !== hoverPoint || (tooltip && tooltip.isHidden))) {\n				// Draw tooltip if necessary\n				if (shared && !kdpoint.series.noSharedTooltip) {\n					i = kdpoints.length;\n					while (i--) {\n						if (kdpoints[i].clientX !== kdpoint.clientX || (kdpoints[i].series.noSharedTooltip || false)) {\n							kdpoints.splice(i, 1);\n						}\n					}\n					if (kdpoints.length && tooltip) {\n						tooltip.refresh(kdpoints, e);\n					}\n\n					// do mouseover on all points except the closest\n					each(kdpoints, function (point) {\n						if (point !== kdpoint) { \n							point.onMouseOver(e);\n						}\n					});				\n					kdpoint.onMouseOver(e); // #3919 do mouseover on the closest point last to ensure it is the hoverpoint\n				} else {\n					if (tooltip) { \n						tooltip.refresh(kdpoint, e);\n					}\n					kdpoint.onMouseOver(e); \n				}\n			\n			// Update positions (regardless of kdpoint or hoverPoint)\n			} else {\n				followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;\n				if (tooltip && followPointer && !tooltip.isHidden) {\n					anchor = tooltip.getAnchor([{}], e);\n					tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });			\n				}\n			}\n\n			// Start the event listener to pick up the tooltip \n			if (tooltip && !pointer._onDocumentMouseMove) {\n				pointer._onDocumentMouseMove = function (e) {\n					if (charts[hoverChartIndex]) {\n						charts[hoverChartIndex].pointer.onDocumentMouseMove(e);\n					}\n				};\n				addEvent(doc, 'mousemove', pointer._onDocumentMouseMove);\n			}\n			\n			// Crosshair\n			each(chart.axes, function (axis) {\n				axis.drawCrosshair(e, pick(kdpoint, hoverPoint));\n			});	\n					\n		},\n\n\n\n		/**\n		 * Reset the tracking by hiding the tooltip, the hover series state and the hover point\n		 * \n		 * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible\n		 */\n		reset: function (allowMove, delay) {\n			var pointer = this,\n				chart = pointer.chart,\n				hoverSeries = chart.hoverSeries,\n				hoverPoint = chart.hoverPoint,\n				tooltip = chart.tooltip,\n				tooltipPoints = tooltip && tooltip.shared ? chart.hoverPoints : hoverPoint;\n				\n			// Narrow in allowMove\n			allowMove = allowMove && tooltip && tooltipPoints;\n				\n			// Check if the points have moved outside the plot area, #1003		\n			if (allowMove  && splat(tooltipPoints)[0].plotX === UNDEFINED) {\n				allowMove = false;\n			}	\n			// Just move the tooltip, #349\n			if (allowMove) {\n				tooltip.refresh(tooltipPoints);\n				if (hoverPoint) { // #2500\n					hoverPoint.setState(hoverPoint.state, true);\n					each(chart.axes, function (axis) {\n						if (pick(axis.options.crosshair && axis.options.crosshair.snap, true)) {\n							axis.drawCrosshair(null, allowMove);\n						}  else {\n							axis.hideCrosshair();\n						}\n					});\n					\n				}\n\n			// Full reset\n			} else {\n\n				if (hoverPoint) {\n					hoverPoint.onMouseOut();\n				}\n\n				if (hoverSeries) {\n					hoverSeries.onMouseOut();\n				}\n\n				if (tooltip) {\n					tooltip.hide(delay);\n				}\n\n				if (pointer._onDocumentMouseMove) {\n					removeEvent(doc, 'mousemove', pointer._onDocumentMouseMove);\n					pointer._onDocumentMouseMove = null;\n				}\n\n				// Remove crosshairs\n				each(chart.axes, function (axis) {\n					axis.hideCrosshair();\n				});\n				\n				pointer.hoverX = null;\n\n			}\n		},\n\n		/**\n		 * Scale series groups to a certain scale and translation\n		 */\n		scaleGroups: function (attribs, clip) {\n\n			var chart = this.chart,\n				seriesAttribs;\n\n			// Scale each series\n			each(chart.series, function (series) {\n				seriesAttribs = attribs || series.getPlotBox(); // #1701\n				if (series.xAxis && series.xAxis.zoomEnabled) {\n					series.group.attr(seriesAttribs);\n					if (series.markerGroup) {\n						series.markerGroup.attr(seriesAttribs);\n						series.markerGroup.clip(clip ? chart.clipRect : null);\n					}\n					if (series.dataLabelsGroup) {\n						series.dataLabelsGroup.attr(seriesAttribs);\n					}\n				}\n			});\n			\n			// Clip\n			chart.clipRect.attr(clip || chart.clipBox);\n		},\n\n		/**\n		 * Start a drag operation\n		 */\n		dragStart: function (e) {\n			var chart = this.chart;\n\n			// Record the start position\n			chart.mouseIsDown = e.type;\n			chart.cancelClick = false;\n			chart.mouseDownX = this.mouseDownX = e.chartX;\n			chart.mouseDownY = this.mouseDownY = e.chartY;\n		},\n\n		/**\n		 * Perform a drag operation in response to a mousemove event while the mouse is down\n		 */\n		drag: function (e) {\n\n			var chart = this.chart,\n				chartOptions = chart.options.chart,\n				chartX = e.chartX,\n				chartY = e.chartY,\n				zoomHor = this.zoomHor,\n				zoomVert = this.zoomVert,\n				plotLeft = chart.plotLeft,\n				plotTop = chart.plotTop,\n				plotWidth = chart.plotWidth,\n				plotHeight = chart.plotHeight,\n				clickedInside,\n				size,\n				mouseDownX = this.mouseDownX,\n				mouseDownY = this.mouseDownY,\n				panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];\n\n			// If the mouse is outside the plot area, adjust to cooordinates\n			// inside to prevent the selection marker from going outside\n			if (chartX < plotLeft) {\n				chartX = plotLeft;\n			} else if (chartX > plotLeft + plotWidth) {\n				chartX = plotLeft + plotWidth;\n			}\n\n			if (chartY < plotTop) {\n				chartY = plotTop;\n			} else if (chartY > plotTop + plotHeight) {\n				chartY = plotTop + plotHeight;\n			}\n			\n			// determine if the mouse has moved more than 10px\n			this.hasDragged = Math.sqrt(\n				Math.pow(mouseDownX - chartX, 2) +\n				Math.pow(mouseDownY - chartY, 2)\n			);\n			\n			if (this.hasDragged > 10) {\n				clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);\n\n				// make a selection\n				if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {\n					if (!this.selectionMarker) {\n						this.selectionMarker = chart.renderer.rect(\n							plotLeft,\n							plotTop,\n							zoomHor ? 1 : plotWidth,\n							zoomVert ? 1 : plotHeight,\n							0\n						)\n						.attr({\n							fill: chartOptions.selectionMarkerFill || 'rgba(69,114,167,0.25)',\n							zIndex: 7\n						})\n						.add();\n					}\n				}\n\n				// adjust the width of the selection marker\n				if (this.selectionMarker && zoomHor) {\n					size = chartX - mouseDownX;\n					this.selectionMarker.attr({\n						width: mathAbs(size),\n						x: (size > 0 ? 0 : size) + mouseDownX\n					});\n				}\n				// adjust the height of the selection marker\n				if (this.selectionMarker && zoomVert) {\n					size = chartY - mouseDownY;\n					this.selectionMarker.attr({\n						height: mathAbs(size),\n						y: (size > 0 ? 0 : size) + mouseDownY\n					});\n				}\n\n				// panning\n				if (clickedInside && !this.selectionMarker && chartOptions.panning) {\n					chart.pan(e, chartOptions.panning);\n				}\n			}\n		},\n\n		/**\n		 * On mouse up or touch end across the entire document, drop the selection.\n		 */\n		drop: function (e) {\n			var pointer = this,\n				chart = this.chart,\n				hasPinched = this.hasPinched;\n\n			if (this.selectionMarker) {\n				var selectionData = {\n						xAxis: [],\n						yAxis: [],\n						originalEvent: e.originalEvent || e\n					},\n					selectionBox = this.selectionMarker,\n					selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,\n					selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,\n					selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,\n					selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,\n					runZoom;\n\n				// a selection has been made\n				if (this.hasDragged || hasPinched) {\n\n					// record each axis' min and max\n					each(chart.axes, function (axis) {\n						if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{ xAxis: 'zoomX', yAxis: 'zoomY' }[axis.coll]])) { // #859, #3569\n							var horiz = axis.horiz,\n								minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding: 0, // #1207, #3075\n								selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),\n								selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);\n\n							selectionData[axis.coll].push({\n								axis: axis,\n								min: mathMin(selectionMin, selectionMax), // for reversed axes\n								max: mathMax(selectionMin, selectionMax)\n							});\n							runZoom = true;\n						}\n					});\n					if (runZoom) {\n						fireEvent(chart, 'selection', selectionData, function (args) { \n							chart.zoom(extend(args, hasPinched ? { animation: false } : null)); \n						});\n					}\n\n				}\n				this.selectionMarker = this.selectionMarker.destroy();\n\n				// Reset scaling preview\n				if (hasPinched) {\n					this.scaleGroups();\n				}\n			}\n\n			// Reset all\n			if (chart) { // it may be destroyed on mouse up - #877\n				css(chart.container, { cursor: chart._cursor });\n				chart.cancelClick = this.hasDragged > 10; // #370\n				chart.mouseIsDown = this.hasDragged = this.hasPinched = false;\n				this.pinchDown = [];\n			}\n		},\n\n		onContainerMouseDown: function (e) {\n\n			e = this.normalize(e);\n\n			// issue #295, dragging not always working in Firefox\n			if (e.preventDefault) {\n				e.preventDefault();\n			}\n			\n			this.dragStart(e);\n		},\n\n		\n\n		onDocumentMouseUp: function (e) {\n			if (charts[hoverChartIndex]) {\n				charts[hoverChartIndex].pointer.drop(e);\n			}\n		},\n\n		/**\n		 * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.\n		 * Issue #149 workaround. The mouseleave event does not always fire. \n		 */\n		onDocumentMouseMove: function (e) {\n			var chart = this.chart,\n				chartPosition = this.chartPosition;\n\n			e = this.normalize(e, chartPosition);\n\n			// If we're outside, hide the tooltip\n			if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&\n					!chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {\n				this.reset();\n			}\n		},\n\n		/**\n		 * When mouse leaves the container, hide the tooltip.\n		 */\n		onContainerMouseLeave: function () {\n			var chart = charts[hoverChartIndex];\n			if (chart) {\n				chart.pointer.reset();\n				chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix\n			}\n		},\n\n		// The mousemove, touchmove and touchstart event handler\n		onContainerMouseMove: function (e) {\n\n			var chart = this.chart;\n\n			hoverChartIndex = chart.index;\n\n			e = this.normalize(e);		\n			e.returnValue = false; // #2251, #3224\n			\n			if (chart.mouseIsDown === 'mousedown') {\n				this.drag(e);\n			} \n			\n			// Show the tooltip and run mouse over events (#977)\n			if ((this.inClass(e.target, 'highcharts-tracker') || \n					chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {\n				this.runPointActions(e);\n			}\n		},\n\n		/**\n		 * Utility to detect whether an element has, or has a parent with, a specific\n		 * class name. Used on detection of tracker objects and on deciding whether\n		 * hovering the tooltip should cause the active series to mouse out.\n		 */\n		inClass: function (element, className) {\n			var elemClassName;\n			while (element) {\n				elemClassName = attr(element, 'class');\n				if (elemClassName) {\n					if (elemClassName.indexOf(className) !== -1) {\n						return true;\n					} else if (elemClassName.indexOf(PREFIX + 'container') !== -1) {\n						return false;\n					}\n				}\n				element = element.parentNode;\n			}		\n		},\n\n		onTrackerMouseOut: function (e) {\n			var series = this.chart.hoverSeries,\n				relatedTarget = e.relatedTarget || e.toElement,\n				relatedSeries = relatedTarget && relatedTarget.point && relatedTarget.point.series; // #2499\n			\n			if (series && !series.options.stickyTracking && !this.inClass(relatedTarget, PREFIX + 'tooltip') &&\n					relatedSeries !== series) {\n				series.onMouseOut();\n			}\n		},\n\n		onContainerClick: function (e) {\n			var chart = this.chart,\n				hoverPoint = chart.hoverPoint, \n				plotLeft = chart.plotLeft,\n				plotTop = chart.plotTop;\n			\n			e = this.normalize(e);\n			e.originalEvent = e; // #3913\n			e.cancelBubble = true; // IE specific\n\n			if (!chart.cancelClick) {\n				\n				// On tracker click, fire the series and point events. #783, #1583\n				if (hoverPoint && this.inClass(e.target, PREFIX + 'tracker')) {\n\n					// the series click event\n					fireEvent(hoverPoint.series, 'click', extend(e, {\n						point: hoverPoint\n					}));\n\n					// the point click event\n					if (chart.hoverPoint) { // it may be destroyed (#1844)\n						hoverPoint.firePointEvent('click', e);\n					}\n\n				// When clicking outside a tracker, fire a chart event\n				} else {\n					extend(e, this.getCoordinates(e));\n\n					// fire a click event in the chart\n					if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {\n						fireEvent(chart, 'click', e);\n					}\n				}\n\n\n			}\n		},\n\n		/**\n		 * Set the JS DOM events on the container and document. This method should contain\n		 * a one-to-one assignment between methods and their handlers. Any advanced logic should\n		 * be moved to the handler reflecting the event's name.\n		 */\n		setDOMEvents: function () {\n\n			var pointer = this,\n				container = pointer.chart.container;\n\n			container.onmousedown = function (e) {\n				pointer.onContainerMouseDown(e);\n			};\n			container.onmousemove = function (e) {\n				pointer.onContainerMouseMove(e);\n			};\n			container.onclick = function (e) {\n				pointer.onContainerClick(e);\n			};\n			addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);\n			if (chartCount === 1) {\n				addEvent(doc, 'mouseup', pointer.onDocumentMouseUp);\n			}\n			if (hasTouch) {\n				container.ontouchstart = function (e) {\n					pointer.onContainerTouchStart(e);\n				};\n				container.ontouchmove = function (e) {\n					pointer.onContainerTouchMove(e);\n				};\n				if (chartCount === 1) {\n					addEvent(doc, 'touchend', pointer.onDocumentTouchEnd);\n				}\n			}\n			\n		},\n\n		/**\n		 * Destroys the Pointer object and disconnects DOM events.\n		 */\n		destroy: function () {\n			var prop;\n\n			removeEvent(this.chart.container, 'mouseleave', this.onContainerMouseLeave);\n			if (!chartCount) {\n				removeEvent(doc, 'mouseup', this.onDocumentMouseUp);\n				removeEvent(doc, 'touchend', this.onDocumentTouchEnd);\n			}\n\n			// memory and CPU leak\n			clearInterval(this.tooltipTimeout);\n\n			for (prop in this) {\n				this[prop] = null;\n			}\n		}\n	};\n\n\n	/* Support for touch devices */\n	extend(Highcharts.Pointer.prototype, {\n\n		/**\n		 * Run translation operations\n		 */\n		pinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {\n			if (this.zoomHor || this.pinchHor) {\n				this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n			}\n			if (this.zoomVert || this.pinchVert) {\n				this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n			}\n		},\n\n		/**\n		 * Run translation operations for each direction (horizontal and vertical) independently\n		 */\n		pinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {\n			var chart = this.chart,\n				xy = horiz ? 'x' : 'y',\n				XY = horiz ? 'X' : 'Y',\n				sChartXY = 'chart' + XY,\n				wh = horiz ? 'width' : 'height',\n				plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],\n				selectionWH,\n				selectionXY,\n				clipXY,\n				scale = forcedScale || 1,\n				inverted = chart.inverted,\n				bounds = chart.bounds[horiz ? 'h' : 'v'],\n				singleTouch = pinchDown.length === 1,\n				touch0Start = pinchDown[0][sChartXY],\n				touch0Now = touches[0][sChartXY],\n				touch1Start = !singleTouch && pinchDown[1][sChartXY],\n				touch1Now = !singleTouch && touches[1][sChartXY],\n				outOfBounds,\n				transformScale,\n				scaleKey,\n				setScale = function () {\n					if (!singleTouch && mathAbs(touch0Start - touch1Start) > 20) { // Don't zoom if fingers are too close on this axis\n						scale = forcedScale || mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start); \n					}\n					\n					clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;\n					selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;\n				};\n\n			// Set the scale, first pass\n			setScale();\n\n			selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not\n\n			// Out of bounds\n			if (selectionXY < bounds.min) {\n				selectionXY = bounds.min;\n				outOfBounds = true;\n			} else if (selectionXY + selectionWH > bounds.max) {\n				selectionXY = bounds.max - selectionWH;\n				outOfBounds = true;\n			}\n			\n			// Is the chart dragged off its bounds, determined by dataMin and dataMax?\n			if (outOfBounds) {\n\n				// Modify the touchNow position in order to create an elastic drag movement. This indicates\n				// to the user that the chart is responsive but can't be dragged further.\n				touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);\n				if (!singleTouch) {\n					touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);\n				}\n\n				// Set the scale, second pass to adapt to the modified touchNow positions\n				setScale();\n\n			} else {\n				lastValidTouch[xy] = [touch0Now, touch1Now];\n			}\n\n			// Set geometry for clipping, selection and transformation\n			if (!inverted) { // TODO: implement clipping for inverted charts\n				clip[xy] = clipXY - plotLeftTop;\n				clip[wh] = selectionWH;\n			}\n			scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;\n			transformScale = inverted ? 1 / scale : scale;\n\n			selectionMarker[wh] = selectionWH;\n			selectionMarker[xy] = selectionXY;\n			transform[scaleKey] = scale;\n			transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));\n		},\n		\n		/**\n		 * Handle touch events with two touches\n		 */\n		pinch: function (e) {\n\n			var self = this,\n				chart = self.chart,\n				pinchDown = self.pinchDown,\n				touches = e.touches,\n				touchesLength = touches.length,\n				lastValidTouch = self.lastValidTouch,\n				hasZoom = self.hasZoom,\n				selectionMarker = self.selectionMarker,\n				transform = {},\n				fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, PREFIX + 'tracker') && \n					chart.runTrackerClick) || self.runChartClick),\n				clip = {};\n\n			// On touch devices, only proceed to trigger click if a handler is defined\n			if (hasZoom && !fireClickEvent) {\n				e.preventDefault();\n			}\n			\n			// Normalize each touch\n			map(touches, function (e) {\n				return self.normalize(e);\n			});\n			\n			// Register the touch start position\n			if (e.type === 'touchstart') {\n				each(touches, function (e, i) {\n					pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };\n				});\n				lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];\n				lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];\n\n				// Identify the data bounds in pixels\n				each(chart.axes, function (axis) {\n					if (axis.zoomEnabled) {\n						var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],\n							minPixelPadding = axis.minPixelPadding,\n							min = axis.toPixels(pick(axis.options.min, axis.dataMin)),\n							max = axis.toPixels(pick(axis.options.max, axis.dataMax)),\n							absMin = mathMin(min, max),\n							absMax = mathMax(min, max);\n\n						// Store the bounds for use in the touchmove handler\n						bounds.min = mathMin(axis.pos, absMin - minPixelPadding);\n						bounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);\n					}\n				});\n				self.res = true; // reset on next move\n			\n			// Event type is touchmove, handle panning and pinching\n			} else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first\n				\n\n				// Set the marker\n				if (!selectionMarker) {\n					self.selectionMarker = selectionMarker = extend({\n						destroy: noop\n					}, chart.plotBox);\n				}\n				\n				self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n\n				self.hasPinched = hasZoom;\n\n				// Scale and translate the groups to provide visual feedback during pinching\n				self.scaleGroups(transform, clip);\n				\n				// Optionally move the tooltip on touchmove\n				if (!hasZoom && self.followTouchMove && touchesLength === 1) {\n					this.runPointActions(self.normalize(e));\n				} else if (self.res) {\n					self.res = false;\n					this.reset(false, 0);\n				}\n			}\n		},\n\n		onContainerTouchStart: function (e) {\n			var chart = this.chart;\n\n			hoverChartIndex = chart.index;\n\n			if (e.touches.length === 1) {\n\n				e = this.normalize(e);\n\n				if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop) && !chart.openMenu) {\n\n					// Run mouse events and display tooltip etc\n					this.runPointActions(e);\n\n					this.pinch(e);\n\n				} else {\n					// Hide the tooltip on touching outside the plot area (#1203)\n					this.reset();\n				}\n\n			} else if (e.touches.length === 2) {\n				this.pinch(e);\n			}   \n		},\n\n		onContainerTouchMove: function (e) {\n			if (e.touches.length === 1 || e.touches.length === 2) {\n				this.pinch(e);\n			}\n		},\n\n		onDocumentTouchEnd: function (e) {\n			if (charts[hoverChartIndex]) {\n				charts[hoverChartIndex].pointer.drop(e);\n			}\n		}\n\n	});\n	if (win.PointerEvent || win.MSPointerEvent) {\n		\n		// The touches object keeps track of the points being touched at all times\n		var touches = {},\n			hasPointerEvent = !!win.PointerEvent,\n			getWebkitTouches = function () {\n				var key, fake = [];\n				fake.item = function (i) { return this[i]; };\n				for (key in touches) {\n					if (touches.hasOwnProperty(key)) {\n						fake.push({\n							pageX: touches[key].pageX,\n							pageY: touches[key].pageY,\n							target: touches[key].target\n						});\n					}\n				}\n				return fake;\n			},\n			translateMSPointer = function (e, method, wktype, callback) {\n				var p;\n				e = e.originalEvent || e;\n				if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[hoverChartIndex]) {\n					callback(e);\n					p = charts[hoverChartIndex].pointer;\n					p[method]({\n						type: wktype,\n						target: e.currentTarget,\n						preventDefault: noop,\n						touches: getWebkitTouches()\n					});				\n				}\n			};\n\n		/**\n		 * Extend the Pointer prototype with methods for each event handler and more\n		 */\n		extend(Pointer.prototype, {\n			onContainerPointerDown: function (e) {\n				translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {\n					touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };\n				});\n			},\n			onContainerPointerMove: function (e) {\n				translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {\n					touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };\n					if (!touches[e.pointerId].target) {\n						touches[e.pointerId].target = e.currentTarget;\n					}\n				});\n			},\n			onDocumentPointerUp: function (e) {\n				translateMSPointer(e, 'onContainerTouchEnd', 'touchend', function (e) {\n					delete touches[e.pointerId];\n				});\n			},\n\n			/**\n			 * Add or remove the MS Pointer specific events\n			 */\n			batchMSEvents: function (fn) {\n				fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);\n				fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);\n				fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);\n			}\n		});\n\n		// Disable default IE actions for pinch and such on chart element\n		wrap(Pointer.prototype, 'init', function (proceed, chart, options) {\n			proceed.call(this, chart, options);\n			if (this.hasZoom || this.followTouchMove) {\n				css(chart.container, {\n					'-ms-touch-action': NONE,\n					'touch-action': NONE\n				});\n			}\n		});\n\n		// Add IE specific touch events to chart\n		wrap(Pointer.prototype, 'setDOMEvents', function (proceed) {\n			proceed.apply(this);\n			if (this.hasZoom || this.followTouchMove) {\n				this.batchMSEvents(addEvent);\n			}\n		});\n		// Destroy MS events also\n		wrap(Pointer.prototype, 'destroy', function (proceed) {\n			this.batchMSEvents(removeEvent);\n			proceed.call(this);\n		});\n	}\n	/**\n	 * The overview of the chart's series\n	 */\n	var Legend = Highcharts.Legend = function (chart, options) {\n		this.init(chart, options);\n	};\n\n	Legend.prototype = {\n		\n		/**\n		 * Initialize the legend\n		 */\n		init: function (chart, options) {\n			\n			var legend = this,\n				itemStyle = options.itemStyle,\n				padding,\n				itemMarginTop = options.itemMarginTop || 0;\n		\n			this.options = options;\n\n			if (!options.enabled) {\n				return;\n			}\n		\n			legend.itemStyle = itemStyle;\n			legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);\n			legend.itemMarginTop = itemMarginTop;\n			legend.padding = padding = pick(options.padding, 8);\n			legend.initialItemX = padding;\n			legend.initialItemY = padding - 5; // 5 is the number of pixels above the text\n			legend.maxItemWidth = 0;\n			legend.chart = chart;\n			legend.itemHeight = 0;\n			legend.symbolWidth = pick(options.symbolWidth, 16);\n			legend.pages = [];\n\n\n			// Render it\n			legend.render();\n\n			// move checkboxes\n			addEvent(legend.chart, 'endResize', function () { \n				legend.positionCheckboxes();\n			});\n\n		},\n\n		/**\n		 * Set the colors for the legend item\n		 * @param {Object} item A Series or Point instance\n		 * @param {Object} visible Dimmed or colored\n		 */\n		colorizeItem: function (item, visible) {\n			var legend = this,\n				options = legend.options,\n				legendItem = item.legendItem,\n				legendLine = item.legendLine,\n				legendSymbol = item.legendSymbol,\n				hiddenColor = legend.itemHiddenStyle.color,\n				textColor = visible ? options.itemStyle.color : hiddenColor,\n				symbolColor = visible ? (item.legendColor || item.color || '#CCC') : hiddenColor,\n				markerOptions = item.options && item.options.marker,\n				symbolAttr = { fill: symbolColor },\n				key,\n				val;\n			\n			if (legendItem) {\n				legendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE\n			}\n			if (legendLine) {\n				legendLine.attr({ stroke: symbolColor });\n			}\n			\n			if (legendSymbol) {\n				\n				// Apply marker options\n				if (markerOptions && legendSymbol.isMarker) { // #585\n					symbolAttr.stroke = symbolColor;\n					markerOptions = item.convertAttribs(markerOptions);\n					for (key in markerOptions) {\n						val = markerOptions[key];\n						if (val !== UNDEFINED) {\n							symbolAttr[key] = val;\n						}\n					}\n				}\n\n				legendSymbol.attr(symbolAttr);\n			}\n		},\n\n		/**\n		 * Position the legend item\n		 * @param {Object} item A Series or Point instance\n		 */\n		positionItem: function (item) {\n			var legend = this,\n				options = legend.options,\n				symbolPadding = options.symbolPadding,\n				ltr = !options.rtl,\n				legendItemPos = item._legendItemPos,\n				itemX = legendItemPos[0],\n				itemY = legendItemPos[1],\n				checkbox = item.checkbox;\n\n			if (item.legendGroup) {\n				item.legendGroup.translate(\n					ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,\n					itemY\n				);\n			}\n\n			if (checkbox) {\n				checkbox.x = itemX;\n				checkbox.y = itemY;\n			}\n		},\n\n		/**\n		 * Destroy a single legend item\n		 * @param {Object} item The series or point\n		 */\n		destroyItem: function (item) {\n			var checkbox = item.checkbox;\n\n			// destroy SVG elements\n			each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {\n				if (item[key]) {\n					item[key] = item[key].destroy();\n				}\n			});\n\n			if (checkbox) {\n				discardElement(item.checkbox);\n			}\n		},\n\n		/**\n		 * Destroy all items.\n		 */\n		clearItems: function () {\n			var legend = this;\n			each(legend.getAllItems(), function (item) {\n				legend.destroyItem(item); \n			});		\n		},\n\n		/**\n		 * Destroys the legend.\n		 */\n		destroy: function () {\n			var legend = this,\n				legendGroup = legend.group,\n				box = legend.box;\n\n			if (box) {\n				legend.box = box.destroy();\n			}\n\n			if (legendGroup) {\n				legend.group = legendGroup.destroy();\n			}\n		},\n\n		/**\n		 * Position the checkboxes after the width is determined\n		 */\n		positionCheckboxes: function (scrollOffset) {\n			var alignAttr = this.group.alignAttr,\n				translateY,\n				clipHeight = this.clipHeight || this.legendHeight;\n\n			if (alignAttr) {\n				translateY = alignAttr.translateY;\n				each(this.allItems, function (item) {\n					var checkbox = item.checkbox,\n						top;\n					\n					if (checkbox) {\n						top = (translateY + checkbox.y + (scrollOffset || 0) + 3);\n						css(checkbox, {\n							left: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + PX,\n							top: top + PX,\n							display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : NONE\n						});\n					}\n				});\n			}\n		},\n		\n		/**\n		 * Render the legend title on top of the legend\n		 */\n		renderTitle: function () {\n			var options = this.options,\n				padding = this.padding,\n				titleOptions = options.title,\n				titleHeight = 0,\n				bBox;\n			\n			if (titleOptions.text) {\n				if (!this.title) {\n					this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')\n						.attr({ zIndex: 1 })\n						.css(titleOptions.style)\n						.add(this.group);\n				}\n				bBox = this.title.getBBox();\n				titleHeight = bBox.height;\n				this.offsetWidth = bBox.width; // #1717\n				this.contentGroup.attr({ translateY: titleHeight });\n			}\n			this.titleHeight = titleHeight;\n		},\n\n		/**\n		 * Render a single specific legend item\n		 * @param {Object} item A series or point\n		 */\n		renderItem: function (item) {\n			var legend = this,\n				chart = legend.chart,\n				renderer = chart.renderer,\n				options = legend.options,\n				horizontal = options.layout === 'horizontal',\n				symbolWidth = legend.symbolWidth,\n				symbolPadding = options.symbolPadding,\n				itemStyle = legend.itemStyle,\n				itemHiddenStyle = legend.itemHiddenStyle,\n				padding = legend.padding,\n				itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,\n				ltr = !options.rtl,\n				itemHeight,\n				widthOption = options.width,\n				itemMarginBottom = options.itemMarginBottom || 0,\n				itemMarginTop = legend.itemMarginTop,\n				initialItemX = legend.initialItemX,\n				bBox,\n				itemWidth,\n				li = item.legendItem,\n				series = item.series && item.series.drawLegendSymbol ? item.series : item,\n				seriesOptions = series.options,\n				showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,\n				useHTML = options.useHTML;\n\n			if (!li) { // generate it once, later move it\n\n				// Generate the group box\n				// A group to hold the symbol and text. Text is to be appended in Legend class.\n				item.legendGroup = renderer.g('legend-item')\n					.attr({ zIndex: 1 })\n					.add(legend.scrollGroup);\n\n				// Generate the list item text and add it to the group\n				item.legendItem = li = renderer.text(\n						options.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item),\n						ltr ? symbolWidth + symbolPadding : -symbolPadding,\n						legend.baseline || 0,\n						useHTML\n					)\n					.css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)\n					.attr({\n						align: ltr ? 'left' : 'right',\n						zIndex: 2\n					})\n					.add(item.legendGroup);\n\n				// Get the baseline for the first item - the font size is equal for all\n				if (!legend.baseline) {\n					legend.baseline = renderer.fontMetrics(itemStyle.fontSize, li).f + 3 + itemMarginTop;\n					li.attr('y', legend.baseline);\n				}\n\n				// Draw the legend symbol inside the group box\n				series.drawLegendSymbol(legend, item);\n\n				if (legend.setItemEvents) {\n					legend.setItemEvents(item, li, useHTML, itemStyle, itemHiddenStyle);\n				}			\n\n				// Colorize the items\n				legend.colorizeItem(item, item.visible);\n\n				// add the HTML checkbox on top\n				if (showCheckbox) {\n					legend.createCheckboxForItem(item);				\n				}\n			}\n\n			// calculate the positions for the next line\n			bBox = li.getBBox();\n\n			itemWidth = item.checkboxOffset = \n				options.itemWidth || \n				item.legendItemWidth || \n				symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);\n			legend.itemHeight = itemHeight = mathRound(item.legendItemHeight || bBox.height);\n\n			// if the item exceeds the width, start a new line\n			if (horizontal && legend.itemX - initialItemX + itemWidth >\n					(widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {\n				legend.itemX = initialItemX;\n				legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;\n			}\n\n			// If the item exceeds the height, start a new column\n			/*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {\n				legend.itemY = legend.initialItemY;\n				legend.itemX += legend.maxItemWidth;\n				legend.maxItemWidth = 0;\n			}*/\n\n			// Set the edge positions\n			legend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);\n			legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;\n			legend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight); // #915\n\n			// cache the position of the newly generated or reordered items\n			item._legendItemPos = [legend.itemX, legend.itemY];\n\n			// advance\n			if (horizontal) {\n				legend.itemX += itemWidth;\n\n			} else {\n				legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;\n				legend.lastLineHeight = itemHeight;\n			}\n\n			// the width of the widest item\n			legend.offsetWidth = widthOption || mathMax(\n				(horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,\n				legend.offsetWidth\n			);\n		},\n\n		/**\n		 * Get all items, which is one item per series for normal series and one item per point\n		 * for pie series.\n		 */\n		getAllItems: function () {\n			var allItems = [];\n			each(this.chart.series, function (series) {\n				var seriesOptions = series.options;\n\n				// Handle showInLegend. If the series is linked to another series, defaults to false.\n				if (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? UNDEFINED : false, true)) {\n					return;\n				}\n\n				// use points or series for the legend item depending on legendType\n				allItems = allItems.concat(\n						series.legendItems ||\n						(seriesOptions.legendType === 'point' ?\n								series.data :\n								series)\n				);\n			});\n			return allItems;\n		},\n\n		/**\n		 * Adjust the chart margins by reserving space for the legend on only one side\n		 * of the chart. If the position is set to a corner, top or bottom is reserved\n		 * for horizontal legends and left or right for vertical ones.\n		 */\n		adjustMargins: function (margin, spacing) {\n			var chart = this.chart, \n				options = this.options,\n				// Use the first letter of each alignment option in order to detect the side \n				alignment = options.align[0] + options.verticalAlign[0] + options.layout[0];\n				\n			if (this.display && !options.floating) {\n\n				each([\n					/(lth|ct|rth)/,\n					/(rtv|rm|rbv)/,\n					/(rbh|cb|lbh)/,\n					/(lbv|lm|ltv)/\n				], function (alignments, side) {\n					if (alignments.test(alignment) && !defined(margin[side])) {\n						// Now we have detected on which side of the chart we should reserve space for the legend\n						chart[marginNames[side]] = mathMax(\n							chart[marginNames[side]],\n							chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] + \n								[1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] + \n								pick(options.margin, 12) +\n								spacing[side]\n						);\n					}\n				});\n			}\n		},\n\n		/**\n		 * Render the legend. This method can be called both before and after\n		 * chart.render. If called after, it will only rearrange items instead\n		 * of creating new ones.\n		 */\n		render: function () {\n			var legend = this,\n				chart = legend.chart,\n				renderer = chart.renderer,\n				legendGroup = legend.group,\n				allItems,\n				display,\n				legendWidth,\n				legendHeight,\n				box = legend.box,\n				options = legend.options,\n				padding = legend.padding,\n				legendBorderWidth = options.borderWidth,\n				legendBackgroundColor = options.backgroundColor;\n\n			legend.itemX = legend.initialItemX;\n			legend.itemY = legend.initialItemY;\n			legend.offsetWidth = 0;\n			legend.lastItemY = 0;\n\n			if (!legendGroup) {\n				legend.group = legendGroup = renderer.g('legend')\n					.attr({ zIndex: 7 }) \n					.add();\n				legend.contentGroup = renderer.g()\n					.attr({ zIndex: 1 }) // above background\n					.add(legendGroup);\n				legend.scrollGroup = renderer.g()\n					.add(legend.contentGroup);\n			}\n			\n			legend.renderTitle();\n\n			// add each series or point\n			allItems = legend.getAllItems();\n\n			// sort by legendIndex\n			stableSort(allItems, function (a, b) {\n				return ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);\n			});\n\n			// reversed legend\n			if (options.reversed) {\n				allItems.reverse();\n			}\n\n			legend.allItems = allItems;\n			legend.display = display = !!allItems.length;\n\n			// render the items\n			legend.lastLineHeight = 0;\n			each(allItems, function (item) {\n				legend.renderItem(item); \n			});\n\n			// Get the box\n			legendWidth = (options.width || legend.offsetWidth) + padding;\n			legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;\n			legendHeight = legend.handleOverflow(legendHeight);\n			legendHeight += padding;\n\n			// Draw the border and/or background\n			if (legendBorderWidth || legendBackgroundColor) {\n\n				if (!box) {\n					legend.box = box = renderer.rect(\n						0,\n						0,\n						legendWidth,\n						legendHeight,\n						options.borderRadius,\n						legendBorderWidth || 0\n					).attr({\n						stroke: options.borderColor,\n						'stroke-width': legendBorderWidth || 0,\n						fill: legendBackgroundColor || NONE\n					})\n					.add(legendGroup)\n					.shadow(options.shadow);\n					box.isNew = true;\n\n				} else if (legendWidth > 0 && legendHeight > 0) {\n					box[box.isNew ? 'attr' : 'animate'](\n						box.crisp({ width: legendWidth, height: legendHeight })\n					);\n					box.isNew = false;\n				}\n\n				// hide the border if no items\n				box[display ? 'show' : 'hide']();\n			}\n			\n			legend.legendWidth = legendWidth;\n			legend.legendHeight = legendHeight;\n\n			// Now that the legend width and height are established, put the items in the \n			// final position\n			each(allItems, function (item) {\n				legend.positionItem(item);\n			});\n\n			// 1.x compatibility: positioning based on style\n			/*var props = ['left', 'right', 'top', 'bottom'],\n				prop,\n				i = 4;\n			while (i--) {\n				prop = props[i];\n				if (options.style[prop] && options.style[prop] !== 'auto') {\n					options[i < 2 ? 'align' : 'verticalAlign'] = prop;\n					options[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);\n				}\n			}*/\n\n			if (display) {\n				legendGroup.align(extend({\n					width: legendWidth,\n					height: legendHeight\n				}, options), true, 'spacingBox');\n			}\n\n			if (!chart.isResizing) {\n				this.positionCheckboxes();\n			}\n		},\n		\n		/**\n		 * Set up the overflow handling by adding navigation with up and down arrows below the\n		 * legend.\n		 */\n		handleOverflow: function (legendHeight) {\n			var legend = this,\n				chart = this.chart,\n				renderer = chart.renderer,\n				options = this.options,\n				optionsY = options.y,\n				alignTop = options.verticalAlign === 'top',\n				spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,\n				maxHeight = options.maxHeight,\n				clipHeight,\n				clipRect = this.clipRect,\n				navOptions = options.navigation,\n				animation = pick(navOptions.animation, true),\n				arrowSize = navOptions.arrowSize || 12,\n				nav = this.nav,\n				pages = this.pages,\n				lastY,\n				allItems = this.allItems;\n				\n			// Adjust the height\n			if (options.layout === 'horizontal') {\n				spaceHeight /= 2;\n			}\n			if (maxHeight) {\n				spaceHeight = mathMin(spaceHeight, maxHeight);\n			}\n			\n			// Reset the legend height and adjust the clipping rectangle\n			pages.length = 0;\n			if (legendHeight > spaceHeight && !options.useHTML) {\n\n				this.clipHeight = clipHeight = mathMax(spaceHeight - 20 - this.titleHeight - this.padding, 0);\n				this.currentPage = pick(this.currentPage, 1);\n				this.fullHeight = legendHeight;\n				\n				// Fill pages with Y positions so that the top of each a legend item defines\n				// the scroll top for each page (#2098)\n				each(allItems, function (item, i) {\n					var y = item._legendItemPos[1],\n						h = mathRound(item.legendItem.getBBox().height),\n						len = pages.length;\n					\n					if (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {\n						pages.push(lastY || y);\n						len++;\n					}\n					\n					if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {\n						pages.push(y);\n					}\n					if (y !== lastY) {\n						lastY = y;\n					}\n				});\n\n				// Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)\n				if (!clipRect) {\n					clipRect = legend.clipRect = renderer.clipRect(0, this.padding, 9999, 0);\n					legend.contentGroup.clip(clipRect);\n				}\n				clipRect.attr({\n					height: clipHeight\n				});\n				\n				// Add navigation elements\n				if (!nav) {\n					this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);\n					this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)\n						.on('click', function () {\n							legend.scroll(-1, animation);\n						})\n						.add(nav);\n					this.pager = renderer.text('', 15, 10)\n						.css(navOptions.style)\n						.add(nav);\n					this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)\n						.on('click', function () {\n							legend.scroll(1, animation);\n						})\n						.add(nav);\n				}\n				\n				// Set initial position\n				legend.scroll(0);\n				\n				legendHeight = spaceHeight;\n				\n			} else if (nav) {\n				clipRect.attr({\n					height: chart.chartHeight\n				});\n				nav.hide();\n				this.scrollGroup.attr({\n					translateY: 1\n				});\n				this.clipHeight = 0; // #1379\n			}\n			\n			return legendHeight;\n		},\n		\n		/**\n		 * Scroll the legend by a number of pages\n		 * @param {Object} scrollBy\n		 * @param {Object} animation\n		 */\n		scroll: function (scrollBy, animation) {\n			var pages = this.pages,\n				pageCount = pages.length,\n				currentPage = this.currentPage + scrollBy,\n				clipHeight = this.clipHeight,\n				navOptions = this.options.navigation,\n				activeColor = navOptions.activeColor,\n				inactiveColor = navOptions.inactiveColor,\n				pager = this.pager,\n				padding = this.padding,\n				scrollOffset;\n			\n			// When resizing while looking at the last page\n			if (currentPage > pageCount) {\n				currentPage = pageCount;\n			}\n			\n			if (currentPage > 0) {\n				\n				if (animation !== UNDEFINED) {\n					setAnimation(animation, this.chart);\n				}\n				\n				this.nav.attr({\n					translateX: padding,\n					translateY: clipHeight + this.padding + 7 + this.titleHeight,\n					visibility: VISIBLE\n				});\n				this.up.attr({\n						fill: currentPage === 1 ? inactiveColor : activeColor\n					})\n					.css({\n						cursor: currentPage === 1 ? 'default' : 'pointer'\n					});\n				pager.attr({\n					text: currentPage + '/' + pageCount\n				});\n				this.down.attr({\n						x: 18 + this.pager.getBBox().width, // adjust to text width\n						fill: currentPage === pageCount ? inactiveColor : activeColor\n					})\n					.css({\n						cursor: currentPage === pageCount ? 'default' : 'pointer'\n					});\n				\n				scrollOffset = -pages[currentPage - 1] + this.initialItemY;\n\n				this.scrollGroup.animate({\n					translateY: scrollOffset\n				});			\n				\n				this.currentPage = currentPage;\n				this.positionCheckboxes(scrollOffset);\n			}\n				\n		}\n		\n	};\n\n	/*\n	 * LegendSymbolMixin\n	 */ \n\n	var LegendSymbolMixin = Highcharts.LegendSymbolMixin = {\n\n		/**\n		 * Get the series' symbol in the legend\n		 * \n		 * @param {Object} legend The legend object\n		 * @param {Object} item The series (this) or point\n		 */\n		drawRectangle: function (legend, item) {\n			var symbolHeight = legend.options.symbolHeight || 12;\n			\n			item.legendSymbol = this.chart.renderer.rect(\n				0,\n				legend.baseline - 5 - (symbolHeight / 2),\n				legend.symbolWidth,\n				symbolHeight,\n				legend.options.symbolRadius || 0\n			).attr({\n				zIndex: 3\n			}).add(item.legendGroup);		\n			\n		},\n\n		/**\n		 * Get the series' symbol in the legend. This method should be overridable to create custom \n		 * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.\n		 * \n		 * @param {Object} legend The legend object\n		 */\n		drawLineMarker: function (legend) {\n\n			var options = this.options,\n				markerOptions = options.marker,\n				radius,\n				legendOptions = legend.options,\n				legendSymbol,\n				symbolWidth = legend.symbolWidth,\n				renderer = this.chart.renderer,\n				legendItemGroup = this.legendGroup,\n				verticalCenter = legend.baseline - mathRound(renderer.fontMetrics(legendOptions.itemStyle.fontSize, this.legendItem).b * 0.3),\n				attr;\n\n			// Draw the line\n			if (options.lineWidth) {\n				attr = {\n					'stroke-width': options.lineWidth\n				};\n				if (options.dashStyle) {\n					attr.dashstyle = options.dashStyle;\n				}\n				this.legendLine = renderer.path([\n					M,\n					0,\n					verticalCenter,\n					L,\n					symbolWidth,\n					verticalCenter\n				])\n				.attr(attr)\n				.add(legendItemGroup);\n			}\n			\n			// Draw the marker\n			if (markerOptions && markerOptions.enabled !== false) {\n				radius = markerOptions.radius;\n				this.legendSymbol = legendSymbol = renderer.symbol(\n					this.symbol,\n					(symbolWidth / 2) - radius,\n					verticalCenter - radius,\n					2 * radius,\n					2 * radius\n				)\n				.add(legendItemGroup);\n				legendSymbol.isMarker = true;\n			}\n		}\n	};\n\n	// Workaround for #2030, horizontal legend items not displaying in IE11 Preview,\n	// and for #2580, a similar drawing flaw in Firefox 26.\n	// TODO: Explore if there's a general cause for this. The problem may be related \n	// to nested group elements, as the legend item texts are within 4 group elements.\n	if (/Trident\\/7\\.0/.test(userAgent) || isFirefox) {\n		wrap(Legend.prototype, 'positionItem', function (proceed, item) {\n			var legend = this,\n				runPositionItem = function () { // If chart destroyed in sync, this is undefined (#2030)\n					if (item._legendItemPos) {\n						proceed.call(legend, item);\n					}\n				};\n\n			// Do it now, for export and to get checkbox placement\n			runPositionItem();\n			\n			// Do it after to work around the core issue\n			setTimeout(runPositionItem);\n		});\n	}\n	/**\n	 * The chart class\n	 * @param {Object} options\n	 * @param {Function} callback Function to run when the chart has loaded\n	 */\n	var Chart = Highcharts.Chart = function () {\n		this.init.apply(this, arguments);\n	};\n\n	Chart.prototype = {\n\n		/**\n		 * Hook for modules\n		 */\n		callbacks: [],\n\n		/**\n		 * Initialize the chart\n		 */\n		init: function (userOptions, callback) {\n\n			// Handle regular options\n			var options,\n				seriesOptions = userOptions.series; // skip merging data points to increase performance\n\n			userOptions.series = null;\n			options = merge(defaultOptions, userOptions); // do the merge\n			options.series = userOptions.series = seriesOptions; // set back the series data\n			this.userOptions = userOptions;\n\n			var optionsChart = options.chart;\n			\n			// Create margin & spacing array\n			this.margin = this.splashArray('margin', optionsChart);\n			this.spacing = this.splashArray('spacing', optionsChart);\n\n			var chartEvents = optionsChart.events;\n\n			//this.runChartClick = chartEvents && !!chartEvents.click;\n			this.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom\n\n			this.callback = callback;\n			this.isResizing = 0;\n			this.options = options;\n			//chartTitleOptions = UNDEFINED;\n			//chartSubtitleOptions = UNDEFINED;\n\n			this.axes = [];\n			this.series = [];\n			this.hasCartesianSeries = optionsChart.showAxes;\n			//this.axisOffset = UNDEFINED;\n			//this.maxTicks = UNDEFINED; // handle the greatest amount of ticks on grouped axes\n			//this.inverted = UNDEFINED;\n			//this.loadingShown = UNDEFINED;\n			//this.container = UNDEFINED;\n			//this.chartWidth = UNDEFINED;\n			//this.chartHeight = UNDEFINED;\n			//this.marginRight = UNDEFINED;\n			//this.marginBottom = UNDEFINED;\n			//this.containerWidth = UNDEFINED;\n			//this.containerHeight = UNDEFINED;\n			//this.oldChartWidth = UNDEFINED;\n			//this.oldChartHeight = UNDEFINED;\n\n			//this.renderTo = UNDEFINED;\n			//this.renderToClone = UNDEFINED;\n\n			//this.spacingBox = UNDEFINED\n\n			//this.legend = UNDEFINED;\n\n			// Elements\n			//this.chartBackground = UNDEFINED;\n			//this.plotBackground = UNDEFINED;\n			//this.plotBGImage = UNDEFINED;\n			//this.plotBorder = UNDEFINED;\n			//this.loadingDiv = UNDEFINED;\n			//this.loadingSpan = UNDEFINED;\n\n			var chart = this,\n				eventType;\n\n			// Add the chart to the global lookup\n			chart.index = charts.length;\n			charts.push(chart);\n			chartCount++;\n\n			// Set up auto resize\n			if (optionsChart.reflow !== false) {\n				addEvent(chart, 'load', function () {\n					chart.initReflow();\n				});\n			}\n\n			// Chart event handlers\n			if (chartEvents) {\n				for (eventType in chartEvents) {\n					addEvent(chart, eventType, chartEvents[eventType]);\n				}\n			}\n\n			chart.xAxis = [];\n			chart.yAxis = [];\n\n			// Expose methods and variables\n			chart.animation = useCanVG ? false : pick(optionsChart.animation, true);\n			chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;\n\n			chart.firstRender();\n		},\n\n		/**\n		 * Initialize an individual series, called internally before render time\n		 */\n		initSeries: function (options) {\n			var chart = this,\n				optionsChart = chart.options.chart,\n				type = options.type || optionsChart.type || optionsChart.defaultSeriesType,\n				series,\n				constr = seriesTypes[type];\n\n			// No such series type\n			if (!constr) {\n				error(17, true);\n			}\n\n			series = new constr();\n			series.init(this, options);\n			return series;\n		},\n\n		/**\n		 * Check whether a given point is within the plot area\n		 *\n		 * @param {Number} plotX Pixel x relative to the plot area\n		 * @param {Number} plotY Pixel y relative to the plot area\n		 * @param {Boolean} inverted Whether the chart is inverted\n		 */\n		isInsidePlot: function (plotX, plotY, inverted) {\n			var x = inverted ? plotY : plotX,\n				y = inverted ? plotX : plotY;\n				\n			return x >= 0 &&\n				x <= this.plotWidth &&\n				y >= 0 &&\n				y <= this.plotHeight;\n		},\n\n		/**\n		 * Redraw legend, axes or series based on updated data\n		 *\n		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n		 *    configuration\n		 */\n		redraw: function (animation) {\n			var chart = this,\n				axes = chart.axes,\n				series = chart.series,\n				pointer = chart.pointer,\n				legend = chart.legend,\n				redrawLegend = chart.isDirtyLegend,\n				hasStackedSeries,\n				hasDirtyStacks,\n				hasCartesianSeries = chart.hasCartesianSeries,\n				isDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?\n				seriesLength = series.length,\n				i = seriesLength,\n				serie,\n				renderer = chart.renderer,\n				isHiddenChart = renderer.isHidden(),\n				afterRedraw = [];\n				\n			setAnimation(animation, chart);\n			\n			if (isHiddenChart) {\n				chart.cloneRenderTo();\n			}\n\n			// Adjust title layout (reflow multiline text)\n			chart.layOutTitles();\n\n			// link stacked series\n			while (i--) {\n				serie = series[i];\n\n				if (serie.options.stacking) {\n					hasStackedSeries = true;\n					\n					if (serie.isDirty) {\n						hasDirtyStacks = true;\n						break;\n					}\n				}\n			}\n			if (hasDirtyStacks) { // mark others as dirty\n				i = seriesLength;\n				while (i--) {\n					serie = series[i];\n					if (serie.options.stacking) {\n						serie.isDirty = true;\n					}\n				}\n			}\n\n			// handle updated data in the series\n			each(series, function (serie) {\n				if (serie.isDirty) { // prepare the data so axis can read it\n					if (serie.options.legendType === 'point') {\n						redrawLegend = true;\n					}\n				}\n			});\n\n			// handle added or removed series\n			if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed\n				// draw legend graphics\n				legend.render();\n\n				chart.isDirtyLegend = false;\n			}\n\n			// reset stacks\n			if (hasStackedSeries) {\n				chart.getStacks();\n			}\n\n\n			if (hasCartesianSeries) {\n				if (!chart.isResizing) {\n\n					// reset maxTicks\n					chart.maxTicks = null;\n\n					// set axes scales\n					each(axes, function (axis) {\n						axis.setScale();\n					});\n				}\n			}\n\n			chart.getMargins(); // #3098\n\n			if (hasCartesianSeries) {\n				// If one axis is dirty, all axes must be redrawn (#792, #2169)\n				each(axes, function (axis) {\n					if (axis.isDirty) {\n						isDirtyBox = true;\n					}\n				});\n\n				// redraw axes\n				each(axes, function (axis) {\n					\n					// Fire 'afterSetExtremes' only if extremes are set\n					if (axis.isDirtyExtremes) { // #821\n						axis.isDirtyExtremes = false;\n						afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)\n							fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751\n							delete axis.eventArgs;\n						});\n					}\n					\n					if (isDirtyBox || hasStackedSeries) {\n						axis.redraw();\n					}\n				});\n			}\n			\n			// the plot areas size has changed\n			if (isDirtyBox) {\n				chart.drawChartBox();\n			}\n\n\n			// redraw affected series\n			each(series, function (serie) {\n				if (serie.isDirty && serie.visible &&\n						(!serie.isCartesian || serie.xAxis)) { // issue #153\n					serie.redraw();\n				}\n			});\n\n			// move tooltip or reset\n			if (pointer) {\n				pointer.reset(true);\n			}\n\n			// redraw if canvas\n			renderer.draw();\n\n			// fire the event\n			fireEvent(chart, 'redraw'); // jQuery breaks this when calling it from addEvent. Overwrites chart.redraw\n			\n			if (isHiddenChart) {\n				chart.cloneRenderTo(true);\n			}\n			\n			// Fire callbacks that are put on hold until after the redraw\n			each(afterRedraw, function (callback) {\n				callback.call();\n			});\n		},\n\n		/**\n		 * Get an axis, series or point object by id.\n		 * @param id {String} The id as given in the configuration options\n		 */\n		get: function (id) {\n			var chart = this,\n				axes = chart.axes,\n				series = chart.series;\n\n			var i,\n				j,\n				points;\n\n			// search axes\n			for (i = 0; i < axes.length; i++) {\n				if (axes[i].options.id === id) {\n					return axes[i];\n				}\n			}\n\n			// search series\n			for (i = 0; i < series.length; i++) {\n				if (series[i].options.id === id) {\n					return series[i];\n				}\n			}\n\n			// search points\n			for (i = 0; i < series.length; i++) {\n				points = series[i].points || [];\n				for (j = 0; j < points.length; j++) {\n					if (points[j].id === id) {\n						return points[j];\n					}\n				}\n			}\n			return null;\n		},\n\n		/**\n		 * Create the Axis instances based on the config options\n		 */\n		getAxes: function () {\n			var chart = this,\n				options = this.options,\n				xAxisOptions = options.xAxis = splat(options.xAxis || {}),\n				yAxisOptions = options.yAxis = splat(options.yAxis || {}),\n				optionsArray,\n				axis;\n\n			// make sure the options are arrays and add some members\n			each(xAxisOptions, function (axis, i) {\n				axis.index = i;\n				axis.isX = true;\n			});\n\n			each(yAxisOptions, function (axis, i) {\n				axis.index = i;\n			});\n\n			// concatenate all axis options into one array\n			optionsArray = xAxisOptions.concat(yAxisOptions);\n\n			each(optionsArray, function (axisOptions) {\n				axis = new Axis(chart, axisOptions);\n			});\n		},\n\n\n		/**\n		 * Get the currently selected points from all series\n		 */\n		getSelectedPoints: function () {\n			var points = [];\n			each(this.series, function (serie) {\n				points = points.concat(grep(serie.points || [], function (point) {\n					return point.selected;\n				}));\n			});\n			return points;\n		},\n\n		/**\n		 * Get the currently selected series\n		 */\n		getSelectedSeries: function () {\n			return grep(this.series, function (serie) {\n				return serie.selected;\n			});\n		},\n\n		/**\n		 * Generate stacks for each series and calculate stacks total values\n		 */\n		getStacks: function () {\n			var chart = this;\n\n			// reset stacks for each yAxis\n			each(chart.yAxis, function (axis) {\n				if (axis.stacks && axis.hasVisibleSeries) {\n					axis.oldStacks = axis.stacks;\n				}\n			});\n\n			each(chart.series, function (series) {\n				if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {\n					series.stackKey = series.type + pick(series.options.stack, '');\n				}\n			});\n		},	\n\n		/**\n		 * Show the title and subtitle of the chart\n		 *\n		 * @param titleOptions {Object} New title options\n		 * @param subtitleOptions {Object} New subtitle options\n		 *\n		 */\n		setTitle: function (titleOptions, subtitleOptions, redraw) {\n			var chart = this,\n				options = chart.options,\n				chartTitleOptions,\n				chartSubtitleOptions;\n\n			chartTitleOptions = options.title = merge(options.title, titleOptions);\n			chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);\n\n			// add title and subtitle\n			each([\n				['title', titleOptions, chartTitleOptions],\n				['subtitle', subtitleOptions, chartSubtitleOptions]\n			], function (arr) {\n				var name = arr[0],\n					title = chart[name],\n					titleOptions = arr[1],\n					chartTitleOptions = arr[2];\n\n				if (title && titleOptions) {\n					chart[name] = title = title.destroy(); // remove old\n				}\n				\n				if (chartTitleOptions && chartTitleOptions.text && !title) {\n					chart[name] = chart.renderer.text(\n						chartTitleOptions.text,\n						0,\n						0,\n						chartTitleOptions.useHTML\n					)\n					.attr({\n						align: chartTitleOptions.align,\n						'class': PREFIX + name,\n						zIndex: chartTitleOptions.zIndex || 4\n					})\n					.css(chartTitleOptions.style)\n					.add();\n				}	\n			});\n			chart.layOutTitles(redraw);\n		},\n\n		/**\n		 * Lay out the chart titles and cache the full offset height for use in getMargins\n		 */\n		layOutTitles: function (redraw) {\n			var titleOffset = 0,\n				title = this.title,\n				subtitle = this.subtitle,\n				options = this.options,\n				titleOptions = options.title,\n				subtitleOptions = options.subtitle,\n				requiresDirtyBox,\n				renderer = this.renderer,\n				autoWidth = this.spacingBox.width - 44; // 44 makes room for default context button\n\n			if (title) {\n				title\n					.css({ width: (titleOptions.width || autoWidth) + PX })\n					.align(extend({ \n						y: renderer.fontMetrics(titleOptions.style.fontSize, title).b - 3\n					}, titleOptions), false, 'spacingBox');\n				\n				if (!titleOptions.floating && !titleOptions.verticalAlign) {\n					titleOffset = title.getBBox().height;\n				}\n			}\n			if (subtitle) {\n				subtitle\n					.css({ width: (subtitleOptions.width || autoWidth) + PX })\n					.align(extend({ \n						y: titleOffset + (titleOptions.margin - 13) + renderer.fontMetrics(titleOptions.style.fontSize, subtitle).b \n					}, subtitleOptions), false, 'spacingBox');\n				\n				if (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {\n					titleOffset = mathCeil(titleOffset + subtitle.getBBox().height);\n				}\n			}\n\n			requiresDirtyBox = this.titleOffset !== titleOffset;				\n			this.titleOffset = titleOffset; // used in getMargins\n\n			if (!this.isDirtyBox && requiresDirtyBox) {\n				this.isDirtyBox = requiresDirtyBox;\n				// Redraw if necessary (#2719, #2744)		\n				if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {\n					this.redraw();\n				}\n			}\n		},\n\n		/**\n		 * Get chart width and height according to options and container size\n		 */\n		getChartSize: function () {\n			var chart = this,\n				optionsChart = chart.options.chart,\n				widthOption = optionsChart.width,\n				heightOption = optionsChart.height,\n				renderTo = chart.renderToClone || chart.renderTo;\n\n			// get inner width and height from jQuery (#824)\n			if (!defined(widthOption)) {\n				chart.containerWidth = adapterRun(renderTo, 'width');\n			}\n			if (!defined(heightOption)) {\n				chart.containerHeight = adapterRun(renderTo, 'height');\n			}\n			\n			chart.chartWidth = mathMax(0, widthOption || chart.containerWidth || 600); // #1393, 1460\n			chart.chartHeight = mathMax(0, pick(heightOption,\n				// the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:\n				chart.containerHeight > 19 ? chart.containerHeight : 400));\n		},\n\n		/**\n		 * Create a clone of the chart's renderTo div and place it outside the viewport to allow\n		 * size computation on chart.render and chart.redraw\n		 */\n		cloneRenderTo: function (revert) {\n			var clone = this.renderToClone,\n				container = this.container;\n			\n			// Destroy the clone and bring the container back to the real renderTo div\n			if (revert) {\n				if (clone) {\n					this.renderTo.appendChild(container);\n					discardElement(clone);\n					delete this.renderToClone;\n				}\n			\n			// Set up the clone\n			} else {\n				if (container && container.parentNode === this.renderTo) {\n					this.renderTo.removeChild(container); // do not clone this\n				}\n				this.renderToClone = clone = this.renderTo.cloneNode(0);\n				css(clone, {\n					position: ABSOLUTE,\n					top: '-9999px',\n					display: 'block' // #833\n				});\n				if (clone.style.setProperty) { // #2631\n					clone.style.setProperty('display', 'block', 'important');\n				}\n				doc.body.appendChild(clone);\n				if (container) {\n					clone.appendChild(container);\n				}\n			}\n		},\n\n		/**\n		 * Get the containing element, determine the size and create the inner container\n		 * div to hold the chart\n		 */\n		getContainer: function () {\n			var chart = this,\n				container,\n				optionsChart = chart.options.chart,\n				chartWidth,\n				chartHeight,\n				renderTo,\n				indexAttrName = 'data-highcharts-chart',\n				oldChartIndex,\n				containerId;\n\n			chart.renderTo = renderTo = optionsChart.renderTo;\n			containerId = PREFIX + idCounter++;\n\n			if (isString(renderTo)) {\n				chart.renderTo = renderTo = doc.getElementById(renderTo);\n			}\n			\n			// Display an error if the renderTo is wrong\n			if (!renderTo) {\n				error(13, true);\n			}\n			\n			// If the container already holds a chart, destroy it. The check for hasRendered is there\n			// because web pages that are saved to disk from the browser, will preserve the data-highcharts-chart\n			// attribute and the SVG contents, but not an interactive chart. So in this case,\n			// charts[oldChartIndex] will point to the wrong chart if any (#2609).\n			oldChartIndex = pInt(attr(renderTo, indexAttrName));\n			if (!isNaN(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {\n				charts[oldChartIndex].destroy();\n			}		\n			\n			// Make a reference to the chart from the div\n			attr(renderTo, indexAttrName, chart.index);\n\n			// remove previous chart\n			renderTo.innerHTML = '';\n\n			// If the container doesn't have an offsetWidth, it has or is a child of a node\n			// that has display:none. We need to temporarily move it out to a visible\n			// state to determine the size, else the legend and tooltips won't render\n			// properly. The allowClone option is used in sparklines as a micro optimization,\n			// saving about 1-2 ms each chart.\n			if (!optionsChart.skipClone && !renderTo.offsetWidth) {\n				chart.cloneRenderTo();\n			}\n\n			// get the width and height\n			chart.getChartSize();\n			chartWidth = chart.chartWidth;\n			chartHeight = chart.chartHeight;\n\n			// create the inner container\n			chart.container = container = createElement(DIV, {\n					className: PREFIX + 'container' +\n						(optionsChart.className ? ' ' + optionsChart.className : ''),\n					id: containerId\n				}, extend({\n					position: RELATIVE,\n					overflow: HIDDEN, // needed for context menu (avoid scrollbars) and\n						// content overflow in IE\n					width: chartWidth + PX,\n					height: chartHeight + PX,\n					textAlign: 'left',\n					lineHeight: 'normal', // #427\n					zIndex: 0, // #1072\n					'-webkit-tap-highlight-color': 'rgba(0,0,0,0)'\n				}, optionsChart.style),\n				chart.renderToClone || renderTo\n			);\n\n			// cache the cursor (#1650)\n			chart._cursor = container.style.cursor;\n\n			// Initialize the renderer\n			chart.renderer =\n				optionsChart.forExport ? // force SVG, used for SVG export\n					new SVGRenderer(container, chartWidth, chartHeight, optionsChart.style, true) :\n					new Renderer(container, chartWidth, chartHeight, optionsChart.style);\n\n			if (useCanVG) {\n				// If we need canvg library, extend and configure the renderer\n				// to get the tracker for translating mouse events\n				chart.renderer.create(chart, container, chartWidth, chartHeight);\n			}\n			// Add a reference to the charts index\n			chart.renderer.chartIndex = chart.index;\n		},\n\n		/**\n		 * Calculate margins by rendering axis labels in a preliminary position. Title,\n		 * subtitle and legend have already been rendered at this stage, but will be\n		 * moved into their final positions\n		 */\n		getMargins: function (skipAxes) {\n			var chart = this,\n				spacing = chart.spacing,\n				margin = chart.margin,\n				titleOffset = chart.titleOffset;\n\n			chart.resetMargins();\n\n			// Adjust for title and subtitle\n			if (titleOffset && !defined(margin[0])) {\n				chart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);\n			}\n			\n			// Adjust for legend\n			chart.legend.adjustMargins(margin, spacing);\n\n			// adjust for scroller\n			if (chart.extraBottomMargin) {\n				chart.marginBottom += chart.extraBottomMargin;\n			}\n			if (chart.extraTopMargin) {\n				chart.plotTop += chart.extraTopMargin;\n			}\n			if (!skipAxes) {\n				this.getAxisMargins();\n			}\n		},\n\n		getAxisMargins: function () {\n\n			var chart = this,\n				axisOffset = chart.axisOffset = [0, 0, 0, 0], // top, right, bottom, left\n				margin = chart.margin;\n			\n			// pre-render axes to get labels offset width\n			if (chart.hasCartesianSeries) {\n				each(chart.axes, function (axis) {\n					axis.getOffset();\n				});\n			}\n\n			// Add the axis offsets\n			each(marginNames, function (m, side) {\n				if (!defined(margin[side])) {\n					chart[m] += axisOffset[side];\n				}		\n			});\n\n			chart.setChartSize();\n\n		},\n\n		/**\n		 * Resize the chart to its container if size is not explicitly set\n		 */\n		reflow: function (e) {\n			var chart = this,\n				optionsChart = chart.options.chart,\n				renderTo = chart.renderTo,\n				width = optionsChart.width || adapterRun(renderTo, 'width'),\n				height = optionsChart.height || adapterRun(renderTo, 'height'),\n				target = e ? e.target : win, // #805 - MooTools doesn't supply e\n				doReflow = function () {\n					if (chart.container) { // It may have been destroyed in the meantime (#1257)\n						chart.setSize(width, height, false);\n						chart.hasUserSize = null;\n					}\n				};\n				\n			// Width and height checks for display:none. Target is doc in IE8 and Opera,\n			// win in Firefox, Chrome and IE9.\n			if (!chart.hasUserSize && !chart.isPrinting && width && height && (target === win || target === doc)) { // #1093\n				if (width !== chart.containerWidth || height !== chart.containerHeight) {\n					clearTimeout(chart.reflowTimeout);\n					if (e) { // Called from window.resize\n						chart.reflowTimeout = setTimeout(doReflow, 100);\n					} else { // Called directly (#2224)\n						doReflow();\n					}\n				}\n				chart.containerWidth = width;\n				chart.containerHeight = height;\n			}\n		},\n\n		/**\n		 * Add the event handlers necessary for auto resizing\n		 */\n		initReflow: function () {\n			var chart = this,\n				reflow = function (e) {\n					chart.reflow(e);\n				};\n				\n			\n			addEvent(win, 'resize', reflow);\n			addEvent(chart, 'destroy', function () {\n				removeEvent(win, 'resize', reflow);\n			});\n		},\n\n		/**\n		 * Resize the chart to a given width and height\n		 * @param {Number} width\n		 * @param {Number} height\n		 * @param {Object|Boolean} animation\n		 */\n		setSize: function (width, height, animation) {\n			var chart = this,\n				chartWidth,\n				chartHeight,\n				fireEndResize;\n\n			// Handle the isResizing counter\n			chart.isResizing += 1;\n			fireEndResize = function () {\n				if (chart) {\n					fireEvent(chart, 'endResize', null, function () {\n						chart.isResizing -= 1;\n					});\n				}\n			};\n\n			// set the animation for the current process\n			setAnimation(animation, chart);\n\n			chart.oldChartHeight = chart.chartHeight;\n			chart.oldChartWidth = chart.chartWidth;\n			if (defined(width)) {\n				chart.chartWidth = chartWidth = mathMax(0, mathRound(width));\n				chart.hasUserSize = !!chartWidth;\n			}\n			if (defined(height)) {\n				chart.chartHeight = chartHeight = mathMax(0, mathRound(height));\n			}\n\n			// Resize the container with the global animation applied if enabled (#2503)\n			(globalAnimation ? animate : css)(chart.container, {\n				width: chartWidth + PX,\n				height: chartHeight + PX\n			}, globalAnimation);\n\n			chart.setChartSize(true);\n			chart.renderer.setSize(chartWidth, chartHeight, animation);\n\n			// handle axes\n			chart.maxTicks = null;\n			each(chart.axes, function (axis) {\n				axis.isDirty = true;\n				axis.setScale();\n			});\n\n			// make sure non-cartesian series are also handled\n			each(chart.series, function (serie) {\n				serie.isDirty = true;\n			});\n\n			chart.isDirtyLegend = true; // force legend redraw\n			chart.isDirtyBox = true; // force redraw of plot and chart border\n\n			chart.layOutTitles(); // #2857\n			chart.getMargins();\n\n			chart.redraw(animation);\n\n\n			chart.oldChartHeight = null;\n			fireEvent(chart, 'resize');\n\n			// fire endResize and set isResizing back\n			// If animation is disabled, fire without delay\n			if (globalAnimation === false) {\n				fireEndResize();\n			} else { // else set a timeout with the animation duration\n				setTimeout(fireEndResize, (globalAnimation && globalAnimation.duration) || 500);\n			}\n		},\n\n		/**\n		 * Set the public chart properties. This is done before and after the pre-render\n		 * to determine margin sizes\n		 */\n		setChartSize: function (skipAxes) {\n			var chart = this,\n				inverted = chart.inverted,\n				renderer = chart.renderer,\n				chartWidth = chart.chartWidth,\n				chartHeight = chart.chartHeight,\n				optionsChart = chart.options.chart,\n				spacing = chart.spacing,\n				clipOffset = chart.clipOffset,\n				clipX,\n				clipY,\n				plotLeft,\n				plotTop,\n				plotWidth,\n				plotHeight,\n				plotBorderWidth;\n\n			chart.plotLeft = plotLeft = mathRound(chart.plotLeft);\n			chart.plotTop = plotTop = mathRound(chart.plotTop);\n			chart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));\n			chart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));\n\n			chart.plotSizeX = inverted ? plotHeight : plotWidth;\n			chart.plotSizeY = inverted ? plotWidth : plotHeight;\n			\n			chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;\n\n			// Set boxes used for alignment\n			chart.spacingBox = renderer.spacingBox = {\n				x: spacing[3],\n				y: spacing[0],\n				width: chartWidth - spacing[3] - spacing[1],\n				height: chartHeight - spacing[0] - spacing[2]\n			};\n			chart.plotBox = renderer.plotBox = {\n				x: plotLeft,\n				y: plotTop,\n				width: plotWidth,\n				height: plotHeight\n			};\n\n			plotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);\n			clipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);\n			clipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);\n			chart.clipBox = {\n				x: clipX, \n				y: clipY, \n				width: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX), \n				height: mathMax(0, mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY))\n			};\n\n			if (!skipAxes) {\n				each(chart.axes, function (axis) {\n					axis.setAxisSize();\n					axis.setAxisTranslation();\n				});\n			}\n		},\n\n		/**\n		 * Initial margins before auto size margins are applied\n		 */\n		resetMargins: function () {\n			var chart = this;\n\n			each(marginNames, function (m, side) {\n				chart[m] = pick(chart.margin[side], chart.spacing[side]);\n			});\n			chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left\n			chart.clipOffset = [0, 0, 0, 0];\n		},\n\n		/**\n		 * Draw the borders and backgrounds for chart and plot area\n		 */\n		drawChartBox: function () {\n			var chart = this,\n				optionsChart = chart.options.chart,\n				renderer = chart.renderer,\n				chartWidth = chart.chartWidth,\n				chartHeight = chart.chartHeight,\n				chartBackground = chart.chartBackground,\n				plotBackground = chart.plotBackground,\n				plotBorder = chart.plotBorder,\n				plotBGImage = chart.plotBGImage,\n				chartBorderWidth = optionsChart.borderWidth || 0,\n				chartBackgroundColor = optionsChart.backgroundColor,\n				plotBackgroundColor = optionsChart.plotBackgroundColor,\n				plotBackgroundImage = optionsChart.plotBackgroundImage,\n				plotBorderWidth = optionsChart.plotBorderWidth || 0,\n				mgn,\n				bgAttr,\n				plotLeft = chart.plotLeft,\n				plotTop = chart.plotTop,\n				plotWidth = chart.plotWidth,\n				plotHeight = chart.plotHeight,\n				plotBox = chart.plotBox,\n				clipRect = chart.clipRect,\n				clipBox = chart.clipBox;\n\n			// Chart area\n			mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);\n\n			if (chartBorderWidth || chartBackgroundColor) {\n				if (!chartBackground) {\n					\n					bgAttr = {\n						fill: chartBackgroundColor || NONE\n					};\n					if (chartBorderWidth) { // #980\n						bgAttr.stroke = optionsChart.borderColor;\n						bgAttr['stroke-width'] = chartBorderWidth;\n					}\n					chart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,\n							optionsChart.borderRadius, chartBorderWidth)\n						.attr(bgAttr)\n						.addClass(PREFIX + 'background')\n						.add()\n						.shadow(optionsChart.shadow);\n\n				} else { // resize\n					chartBackground.animate(\n						chartBackground.crisp({ width: chartWidth - mgn, height: chartHeight - mgn })\n					);\n				}\n			}\n\n\n			// Plot background\n			if (plotBackgroundColor) {\n				if (!plotBackground) {\n					chart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)\n						.attr({\n							fill: plotBackgroundColor\n						})\n						.add()\n						.shadow(optionsChart.plotShadow);\n				} else {\n					plotBackground.animate(plotBox);\n				}\n			}\n			if (plotBackgroundImage) {\n				if (!plotBGImage) {\n					chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)\n						.add();\n				} else {\n					plotBGImage.animate(plotBox);\n				}\n			}\n			\n			// Plot clip\n			if (!clipRect) {\n				chart.clipRect = renderer.clipRect(clipBox);\n			} else {\n				clipRect.animate({\n					width: clipBox.width,\n					height: clipBox.height\n				});\n			}\n\n			// Plot area border\n			if (plotBorderWidth) {\n				if (!plotBorder) {\n					chart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth)\n						.attr({\n							stroke: optionsChart.plotBorderColor,\n							'stroke-width': plotBorderWidth,\n							fill: NONE,\n							zIndex: 1\n						})\n						.add();\n				} else {\n					plotBorder.animate(\n						plotBorder.crisp({ x: plotLeft, y: plotTop, width: plotWidth, height: plotHeight, strokeWidth: -plotBorderWidth }) //#3282 plotBorder should be negative\n					);\n				}\n			}\n\n			// reset\n			chart.isDirtyBox = false;\n		},\n\n		/**\n		 * Detect whether a certain chart property is needed based on inspecting its options\n		 * and series. This mainly applies to the chart.invert property, and in extensions to \n		 * the chart.angular and chart.polar properties.\n		 */\n		propFromSeries: function () {\n			var chart = this,\n				optionsChart = chart.options.chart,\n				klass,\n				seriesOptions = chart.options.series,\n				i,\n				value;\n				\n				\n			each(['inverted', 'angular', 'polar'], function (key) {\n				\n				// The default series type's class\n				klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];\n				\n				// Get the value from available chart-wide properties\n				value = (\n					chart[key] || // 1. it is set before\n					optionsChart[key] || // 2. it is set in the options\n					(klass && klass.prototype[key]) // 3. it's default series class requires it\n				);\n		\n				// 4. Check if any the chart's series require it\n				i = seriesOptions && seriesOptions.length;\n				while (!value && i--) {\n					klass = seriesTypes[seriesOptions[i].type];\n					if (klass && klass.prototype[key]) {\n						value = true;\n					}\n				}\n		\n				// Set the chart property\n				chart[key] = value;	\n			});\n			\n		},\n\n		/**\n		 * Link two or more series together. This is done initially from Chart.render,\n		 * and after Chart.addSeries and Series.remove.\n		 */\n		linkSeries: function () {\n			var chart = this,\n				chartSeries = chart.series;\n\n			// Reset links\n			each(chartSeries, function (series) {\n				series.linkedSeries.length = 0;\n			});\n\n			// Apply new links\n			each(chartSeries, function (series) {\n				var linkedTo = series.options.linkedTo;\n				if (isString(linkedTo)) {\n					if (linkedTo === ':previous') {\n						linkedTo = chart.series[series.index - 1];\n					} else {\n						linkedTo = chart.get(linkedTo);\n					}\n					if (linkedTo) {\n						linkedTo.linkedSeries.push(series);\n						series.linkedParent = linkedTo;\n					}\n				}\n			});\n		},\n\n		/**\n		 * Render series for the chart\n		 */\n		renderSeries: function () {\n			each(this.series, function (serie) {\n				serie.translate();\n				serie.render();\n			});\n		},\n			\n		/**\n		 * Render labels for the chart\n		 */\n		renderLabels: function () {\n			var chart = this,\n				labels = chart.options.labels;\n			if (labels.items) {\n				each(labels.items, function (label) {\n					var style = extend(labels.style, label.style),\n						x = pInt(style.left) + chart.plotLeft,\n						y = pInt(style.top) + chart.plotTop + 12;\n\n					// delete to prevent rewriting in IE\n					delete style.left;\n					delete style.top;\n\n					chart.renderer.text(\n						label.html,\n						x,\n						y\n					)\n					.attr({ zIndex: 2 })\n					.css(style)\n					.add();\n\n				});\n			}\n		},\n\n		/**\n		 * Render all graphics for the chart\n		 */\n		render: function () {\n			var chart = this,\n				axes = chart.axes,\n				renderer = chart.renderer,\n				options = chart.options,\n				tempWidth,\n				tempHeight,\n				redoHorizontal,\n				redoVertical;\n\n			// Title\n			chart.setTitle();\n\n\n			// Legend\n			chart.legend = new Legend(chart, options.legend);\n\n			chart.getStacks(); // render stacks\n\n			// Get chart margins\n			chart.getMargins(true);\n			chart.setChartSize();\n\n			// Record preliminary dimensions for later comparison\n			tempWidth = chart.plotWidth;\n			tempHeight = chart.plotHeight = chart.plotHeight - 13; // 13 is the most common height of X axis labels\n\n			// Get margins by pre-rendering axes\n			each(axes, function (axis) {\n				axis.setScale();\n			});\n			chart.getAxisMargins();\n\n			// If the plot area size has changed significantly, calculate tick positions again\n			redoHorizontal = tempWidth / chart.plotWidth > 1.2;\n			redoVertical = tempHeight / chart.plotHeight > 1.1;\n\n			if (redoHorizontal || redoVertical) {\n\n				chart.maxTicks = null; // reset for second pass\n				each(axes, function (axis) {\n					if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {\n						axis.setTickInterval(true); // update to reflect the new margins\n					}\n				});\n				chart.getMargins(); // second pass to check for new labels\n			}\n\n			// Draw the borders and backgrounds\n			chart.drawChartBox();		\n\n\n			// Axes\n			if (chart.hasCartesianSeries) {\n				each(axes, function (axis) {\n					axis.render();\n				});\n			}\n\n			// The series\n			if (!chart.seriesGroup) {\n				chart.seriesGroup = renderer.g('series-group')\n					.attr({ zIndex: 3 })\n					.add();\n			}\n			chart.renderSeries();\n\n			// Labels\n			chart.renderLabels();\n\n			// Credits\n			chart.showCredits(options.credits);\n\n			// Set flag\n			chart.hasRendered = true;\n\n		},\n\n		/**\n		 * Show chart credits based on config options\n		 */\n		showCredits: function (credits) {\n			if (credits.enabled && !this.credits) {\n				this.credits = this.renderer.text(\n					credits.text,\n					0,\n					0\n				)\n				.on('click', function () {\n					if (credits.href) {\n						location.href = credits.href;\n					}\n				})\n				.attr({\n					align: credits.position.align,\n					zIndex: 8\n				})\n				.css(credits.style)\n				.add()\n				.align(credits.position);\n			}\n		},\n\n		/**\n		 * Clean up memory usage\n		 */\n		destroy: function () {\n			var chart = this,\n				axes = chart.axes,\n				series = chart.series,\n				container = chart.container,\n				i,\n				parentNode = container && container.parentNode;\n				\n			// fire the chart.destoy event\n			fireEvent(chart, 'destroy');\n			\n			// Delete the chart from charts lookup array\n			charts[chart.index] = UNDEFINED;\n			chartCount--;\n			chart.renderTo.removeAttribute('data-highcharts-chart');\n\n			// remove events\n			removeEvent(chart);\n\n			// ==== Destroy collections:\n			// Destroy axes\n			i = axes.length;\n			while (i--) {\n				axes[i] = axes[i].destroy();\n			}\n\n			// Destroy each series\n			i = series.length;\n			while (i--) {\n				series[i] = series[i].destroy();\n			}\n\n			// ==== Destroy chart properties:\n			each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage', \n					'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'scroller', \n					'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {\n				var prop = chart[name];\n\n				if (prop && prop.destroy) {\n					chart[name] = prop.destroy();\n				}\n			});\n\n			// remove container and all SVG\n			if (container) { // can break in IE when destroyed before finished loading\n				container.innerHTML = '';\n				removeEvent(container);\n				if (parentNode) {\n					discardElement(container);\n				}\n\n			}\n\n			// clean it all up\n			for (i in chart) {\n				delete chart[i];\n			}\n\n		},\n\n\n		/**\n		 * VML namespaces can't be added until after complete. Listening\n		 * for Perini's doScroll hack is not enough.\n		 */\n		isReadyToRender: function () {\n			var chart = this;\n\n			// Note: in spite of JSLint's complaints, win == win.top is required\n			/*jslint eqeq: true*/\n			if ((!hasSVG && (win == win.top && doc.readyState !== 'complete')) || (useCanVG && !win.canvg)) {\n			/*jslint eqeq: false*/\n				if (useCanVG) {\n					// Delay rendering until canvg library is downloaded and ready\n					CanVGController.push(function () { chart.firstRender(); }, chart.options.global.canvasToolsURL);\n				} else {\n					doc.attachEvent('onreadystatechange', function () {\n						doc.detachEvent('onreadystatechange', chart.firstRender);\n						if (doc.readyState === 'complete') {\n							chart.firstRender();\n						}\n					});\n				}\n				return false;\n			}\n			return true;\n		},\n\n		/**\n		 * Prepare for first rendering after all data are loaded\n		 */\n		firstRender: function () {\n			var chart = this,\n				options = chart.options,\n				callback = chart.callback;\n\n			// Check whether the chart is ready to render\n			if (!chart.isReadyToRender()) {\n				return;\n			}\n\n			// Create the container\n			chart.getContainer();\n\n			// Run an early event after the container and renderer are established\n			fireEvent(chart, 'init');\n\n			\n			chart.resetMargins();\n			chart.setChartSize();\n\n			// Set the common chart properties (mainly invert) from the given series\n			chart.propFromSeries();\n\n			// get axes\n			chart.getAxes();\n\n			// Initialize the series\n			each(options.series || [], function (serieOptions) {\n				chart.initSeries(serieOptions);\n			});\n\n			chart.linkSeries();\n\n			// Run an event after axes and series are initialized, but before render. At this stage,\n			// the series data is indexed and cached in the xData and yData arrays, so we can access\n			// those before rendering. Used in Highstock. \n			fireEvent(chart, 'beforeRender'); \n\n			// depends on inverted and on margins being set\n			if (Highcharts.Pointer) {\n				chart.pointer = new Pointer(chart, options);\n			}\n\n			chart.render();\n\n			// add canvas\n			chart.renderer.draw();\n			// run callbacks\n			if (callback) {\n				callback.apply(chart, [chart]);\n			}\n			each(chart.callbacks, function (fn) {\n				if (chart.index !== UNDEFINED) { // Chart destroyed in its own callback (#3600)\n					fn.apply(chart, [chart]);\n				}\n			});\n			\n			// Fire the load event\n			fireEvent(chart, 'load');		\n			\n			// If the chart was rendered outside the top container, put it back in (#3679)\n			chart.cloneRenderTo(true);\n\n		},\n\n		/**\n		* Creates arrays for spacing and margin from given options.\n		*/\n		splashArray: function (target, options) {\n			var oVar = options[target],\n				tArray = isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];\n\n			return [pick(options[target + 'Top'], tArray[0]),\n					pick(options[target + 'Right'], tArray[1]),\n					pick(options[target + 'Bottom'], tArray[2]),\n					pick(options[target + 'Left'], tArray[3])];\n		}\n	}; // end Chart\n\n	var CenteredSeriesMixin = Highcharts.CenteredSeriesMixin = {\n		/**\n		 * Get the center of the pie based on the size and center options relative to the  \n		 * plot area. Borrowed by the polar and gauge series types.\n		 */\n		getCenter: function () {\n			\n			var options = this.options,\n				chart = this.chart,\n				slicingRoom = 2 * (options.slicedOffset || 0),\n				handleSlicingRoom,\n				plotWidth = chart.plotWidth - 2 * slicingRoom,\n				plotHeight = chart.plotHeight - 2 * slicingRoom,\n				centerOption = options.center,\n				positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],\n				smallestSize = mathMin(plotWidth, plotHeight),\n				isPercent,\n				i,\n				value;\n\n			for (i = 0; i < 4; ++i) {\n				value = positions[i];\n				isPercent = /%$/.test(value);\n				handleSlicingRoom = i < 2 || (i === 2 && isPercent);\n				positions[i] = (isPercent ?\n					// i == 0: centerX, relative to width\n					// i == 1: centerY, relative to height\n					// i == 2: size, relative to smallestSize\n					// i == 3: innerSize, relative to size\n					[plotWidth, plotHeight, smallestSize, positions[2]][i] *\n						pInt(value) / 100 :\n					pInt(value)) + (handleSlicingRoom ? slicingRoom : 0);\n			}\n			return positions;\n		}\n	};\n\n	/**\n	 * The Point object and prototype. Inheritable and used as base for PiePoint\n	 */\n	var Point = function () {};\n	Point.prototype = {\n\n		/**\n		 * Initialize the point\n		 * @param {Object} series The series object containing this point\n		 * @param {Object} options The data in either number, array or object format\n		 */\n		init: function (series, options, x) {\n\n			var point = this,\n				colors;\n			point.series = series;\n			point.color = series.color; // #3445\n			point.applyOptions(options, x);\n			point.pointAttr = {};\n\n			if (series.options.colorByPoint) {\n				colors = series.options.colors || series.chart.options.colors;\n				point.color = point.color || colors[series.colorCounter++];\n				// loop back to zero\n				if (series.colorCounter === colors.length) {\n					series.colorCounter = 0;\n				}\n			}\n\n			series.chart.pointCount++;\n			return point;\n		},\n		/**\n		 * Apply the options containing the x and y data and possible some extra properties.\n		 * This is called on point init or from point.update.\n		 *\n		 * @param {Object} options\n		 */\n		applyOptions: function (options, x) {\n			var point = this,\n				series = point.series,\n				pointValKey = series.options.pointValKey || series.pointValKey;\n\n			options = Point.prototype.optionsToObject.call(this, options);\n\n			// copy options directly to point\n			extend(point, options);\n			point.options = point.options ? extend(point.options, options) : options;\n\n			// For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.\n			if (pointValKey) {\n				point.y = point[pointValKey];\n			}\n\n			// If no x is set by now, get auto incremented value. All points must have an\n			// x value, however the y value can be null to create a gap in the series\n			if (point.x === UNDEFINED && series) {\n				point.x = x === UNDEFINED ? series.autoIncrement() : x;\n			}\n\n			return point;\n		},\n\n		/**\n		 * Transform number or array configs into objects\n		 */\n		optionsToObject: function (options) {\n			var ret = {},\n				series = this.series,\n				pointArrayMap = series.pointArrayMap || ['y'],\n				valueCount = pointArrayMap.length,\n				firstItemType,\n				i = 0,\n				j = 0;\n\n			if (typeof options === 'number' || options === null) {\n				ret[pointArrayMap[0]] = options;\n\n			} else if (isArray(options)) {\n				// with leading x value\n				if (options.length > valueCount) {\n					firstItemType = typeof options[0];\n					if (firstItemType === 'string') {\n						ret.name = options[0];\n					} else if (firstItemType === 'number') {\n						ret.x = options[0];\n					}\n					i++;\n				}\n				while (j < valueCount) {\n					ret[pointArrayMap[j++]] = options[i++];\n				}\n			} else if (typeof options === 'object') {\n				ret = options;\n\n				// This is the fastest way to detect if there are individual point dataLabels that need\n				// to be considered in drawDataLabels. These can only occur in object configs.\n				if (options.dataLabels) {\n					series._hasPointLabels = true;\n				}\n\n				// Same approach as above for markers\n				if (options.marker) {\n					series._hasPointMarkers = true;\n				}\n			}\n			return ret;\n		},\n\n		/**\n		 * Destroy a point to clear memory. Its reference still stays in series.data.\n		 */\n		destroy: function () {\n			var point = this,\n				series = point.series,\n				chart = series.chart,\n				hoverPoints = chart.hoverPoints,\n				prop;\n\n			chart.pointCount--;\n\n			if (hoverPoints) {\n				point.setState();\n				erase(hoverPoints, point);\n				if (!hoverPoints.length) {\n					chart.hoverPoints = null;\n				}\n\n			}\n			if (point === chart.hoverPoint) {\n				point.onMouseOut();\n			}\n\n			// remove all events\n			if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive\n				removeEvent(point);\n				point.destroyElements();\n			}\n\n			if (point.legendItem) { // pies have legend items\n				chart.legend.destroyItem(point);\n			}\n\n			for (prop in point) {\n				point[prop] = null;\n			}\n\n\n		},\n\n		/**\n		 * Destroy SVG elements associated with the point\n		 */\n		destroyElements: function () {\n			var point = this,\n				props = ['graphic', 'dataLabel', 'dataLabelUpper', 'group', 'connector', 'shadowGroup'],\n				prop,\n				i = 6;\n			while (i--) {\n				prop = props[i];\n				if (point[prop]) {\n					point[prop] = point[prop].destroy();\n				}\n			}\n		},\n\n		/**\n		 * Return the configuration hash needed for the data label and tooltip formatters\n		 */\n		getLabelConfig: function () {\n			var point = this;\n			return {\n				x: point.category,\n				y: point.y,\n				key: point.name || point.category,\n				series: point.series,\n				point: point,\n				percentage: point.percentage,\n				total: point.total || point.stackTotal\n			};\n		},	\n\n		/**\n		 * Extendable method for formatting each point's tooltip line\n		 *\n		 * @return {String} A string to be concatenated in to the common tooltip text\n		 */\n		tooltipFormatter: function (pointFormat) {\n\n			// Insert options for valueDecimals, valuePrefix, and valueSuffix\n			var series = this.series,\n				seriesTooltipOptions = series.tooltipOptions,\n				valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),\n				valuePrefix = seriesTooltipOptions.valuePrefix || '',\n				valueSuffix = seriesTooltipOptions.valueSuffix || '';\n\n			// Loop over the point array map and replace unformatted values with sprintf formatting markup\n			each(series.pointArrayMap || ['y'], function (key) {\n				key = '{point.' + key; // without the closing bracket\n				if (valuePrefix || valueSuffix) {\n					pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);\n				}\n				pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');\n			});\n\n			return format(pointFormat, {\n				point: this,\n				series: this.series\n			});\n		},\n\n		/**\n		 * Fire an event on the Point object. Must not be renamed to fireEvent, as this\n		 * causes a name clash in MooTools\n		 * @param {String} eventType\n		 * @param {Object} eventArgs Additional event arguments\n		 * @param {Function} defaultFunction Default event handler\n		 */\n		firePointEvent: function (eventType, eventArgs, defaultFunction) {\n			var point = this,\n				series = this.series,\n				seriesOptions = series.options;\n\n			// load event handlers on demand to save time on mouseover/out\n			if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {\n				this.importEvents();\n			}\n\n			// add default handler if in selection mode\n			if (eventType === 'click' && seriesOptions.allowPointSelect) {\n				defaultFunction = function (event) {\n					// Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera\n					point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);\n				};\n			}\n\n			fireEvent(this, eventType, eventArgs, defaultFunction);\n		}\n	};/**\n	 * @classDescription The base function which all other series types inherit from. The data in the series is stored\n	 * in various arrays.\n	 *\n	 * - First, series.options.data contains all the original config options for\n	 * each point whether added by options or methods like series.addPoint.\n	 * - Next, series.data contains those values converted to points, but in case the series data length\n	 * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It\n	 * only contains the points that have been created on demand.\n	 * - Then there's series.points that contains all currently visible point objects. In case of cropping,\n	 * the cropped-away points are not part of this array. The series.points array starts at series.cropStart\n	 * compared to series.data and series.options.data. If however the series data is grouped, these can't\n	 * be correlated one to one.\n	 * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.\n	 * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.\n	 *\n	 * @param {Object} chart\n	 * @param {Object} options\n	 */\n	var Series = Highcharts.Series = function () {};\n\n	Series.prototype = {\n\n		isCartesian: true,\n		type: 'line',\n		pointClass: Point,\n		sorted: true, // requires the data to be sorted\n		requireSorting: true,\n		pointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n			stroke: 'lineColor',\n			'stroke-width': 'lineWidth',\n			fill: 'fillColor',\n			r: 'radius'\n		},\n		axisTypes: ['xAxis', 'yAxis'],\n		colorCounter: 0,\n		parallelArrays: ['x', 'y'], // each point's x and y values are stored in this.xData and this.yData\n		init: function (chart, options) {\n			var series = this,\n				eventType,\n				events,\n				chartSeries = chart.series,\n				sortByIndex = function (a, b) {\n					return pick(a.options.index, a._i) - pick(b.options.index, b._i);\n				};\n\n			series.chart = chart;\n			series.options = options = series.setOptions(options); // merge with plotOptions\n			series.linkedSeries = [];\n\n			// bind the axes\n			series.bindAxes();\n\n			// set some variables\n			extend(series, {\n				name: options.name,\n				state: NORMAL_STATE,\n				pointAttr: {},\n				visible: options.visible !== false, // true by default\n				selected: options.selected === true // false by default\n			});\n\n			// special\n			if (useCanVG) {\n				options.animation = false;\n			}\n\n			// register event listeners\n			events = options.events;\n			for (eventType in events) {\n				addEvent(series, eventType, events[eventType]);\n			}\n			if (\n				(events && events.click) ||\n				(options.point && options.point.events && options.point.events.click) ||\n				options.allowPointSelect\n			) {\n				chart.runTrackerClick = true;\n			}\n\n			series.getColor();\n			series.getSymbol();\n\n			// Set the data\n			each(series.parallelArrays, function (key) {\n				series[key + 'Data'] = [];\n			});\n			series.setData(options.data, false);\n\n			// Mark cartesian\n			if (series.isCartesian) {\n				chart.hasCartesianSeries = true;\n			}\n\n			// Register it in the chart\n			chartSeries.push(series);\n			series._i = chartSeries.length - 1;\n\n			// Sort series according to index option (#248, #1123, #2456)\n			stableSort(chartSeries, sortByIndex);\n			if (this.yAxis) {\n				stableSort(this.yAxis.series, sortByIndex);\n			}\n\n			each(chartSeries, function (series, i) {\n				series.index = i;\n				series.name = series.name || 'Series ' + (i + 1);\n			});\n\n		},\n\n		/**\n		 * Set the xAxis and yAxis properties of cartesian series, and register the series\n		 * in the axis.series array\n		 */\n		bindAxes: function () {\n			var series = this,\n				seriesOptions = series.options,\n				chart = series.chart,\n				axisOptions;\n\n			each(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis\n\n				each(chart[AXIS], function (axis) { // loop through the chart's axis objects\n					axisOptions = axis.options;\n\n					// apply if the series xAxis or yAxis option mathches the number of the\n					// axis, or if undefined, use the first axis\n					if ((seriesOptions[AXIS] === axisOptions.index) ||\n							(seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id) ||\n							(seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {\n\n						// register this series in the axis.series lookup\n						axis.series.push(series);\n\n						// set this series.xAxis or series.yAxis reference\n						series[AXIS] = axis;\n\n						// mark dirty for redraw\n						axis.isDirty = true;\n					}\n				});\n\n				// The series needs an X and an Y axis\n				if (!series[AXIS] && series.optionalAxis !== AXIS) {\n					error(18, true);\n				}\n\n			});\n		},\n\n		/**\n		 * For simple series types like line and column, the data values are held in arrays like\n		 * xData and yData for quick lookup to find extremes and more. For multidimensional series\n		 * like bubble and map, this can be extended with arrays like zData and valueData by\n		 * adding to the series.parallelArrays array.\n		 */\n		updateParallelArrays: function (point, i) {\n			var series = point.series,\n				args = arguments,\n				fn = typeof i === 'number' ?\n					 // Insert the value in the given position\n					function (key) {\n						var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];\n						series[key + 'Data'][i] = val;\n					} :\n					// Apply the method specified in i with the following arguments as arguments\n					function (key) {\n						Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));\n					};\n\n			each(series.parallelArrays, fn);\n		},\n\n		/**\n		 * Return an auto incremented x value based on the pointStart and pointInterval options.\n		 * This is only used if an x value is not given for the point that calls autoIncrement.\n		 */\n		autoIncrement: function () {\n\n			var options = this.options,\n				xIncrement = this.xIncrement,\n				date,\n				pointInterval,\n				pointIntervalUnit = options.pointIntervalUnit;\n			\n			xIncrement = pick(xIncrement, options.pointStart, 0);\n			\n			this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);\n			\n			// Added code for pointInterval strings\n			if (pointIntervalUnit === 'month' || pointIntervalUnit === 'year') {\n				date = new Date(xIncrement);\n				date = (pointIntervalUnit === 'month') ?\n					+date[setMonth](date[getMonth]() + pointInterval) :\n					+date[setFullYear](date[getFullYear]() + pointInterval);\n				pointInterval = date - xIncrement;\n			}\n			\n			this.xIncrement = xIncrement + pointInterval;\n			return xIncrement;\n		},\n\n		/**\n		 * Divide the series data into segments divided by null values.\n		 */\n		getSegments: function () {\n			var series = this,\n				lastNull = -1,\n				segments = [],\n				i,\n				points = series.points,\n				pointsLength = points.length;\n\n			if (pointsLength) { // no action required for []\n\n				// if connect nulls, just remove null points\n				if (series.options.connectNulls) {\n					i = pointsLength;\n					while (i--) {\n						if (points[i].y === null) {\n							points.splice(i, 1);\n						}\n					}\n					if (points.length) {\n						segments = [points];\n					}\n\n				// else, split on null points\n				} else {\n					each(points, function (point, i) {\n						if (point.y === null) {\n							if (i > lastNull + 1) {\n								segments.push(points.slice(lastNull + 1, i));\n							}\n							lastNull = i;\n						} else if (i === pointsLength - 1) { // last value\n							segments.push(points.slice(lastNull + 1, i + 1));\n						}\n					});\n				}\n			}\n\n			// register it\n			series.segments = segments;\n		},\n\n		/**\n		 * Set the series options by merging from the options tree\n		 * @param {Object} itemOptions\n		 */\n		setOptions: function (itemOptions) {\n			var chart = this.chart,\n				chartOptions = chart.options,\n				plotOptions = chartOptions.plotOptions,\n				userOptions = chart.userOptions || {},\n				userPlotOptions = userOptions.plotOptions || {},\n				typeOptions = plotOptions[this.type],\n				options,\n				zones;\n\n			this.userOptions = itemOptions;\n\n			// General series options take precedence over type options because otherwise, default\n			// type options like column.animation would be overwritten by the general option.\n			// But issues have been raised here (#3881), and the solution may be to distinguish \n			// between default option and userOptions like in the tooltip below.\n			options = merge(\n				typeOptions,\n				plotOptions.series,\n				itemOptions\n			);\n\n			// The tooltip options are merged between global and series specific options\n			this.tooltipOptions = merge(\n				defaultOptions.tooltip,\n				defaultOptions.plotOptions[this.type].tooltip,\n				userOptions.tooltip,\n				userPlotOptions.series && userPlotOptions.series.tooltip,\n				userPlotOptions[this.type] && userPlotOptions[this.type].tooltip,\n				itemOptions.tooltip\n			);\n\n			// Delete marker object if not allowed (#1125)\n			if (typeOptions.marker === null) {\n				delete options.marker;\n			}\n\n			// Handle color zones\n			this.zoneAxis = options.zoneAxis;\n			zones = this.zones = (options.zones || []).slice();\n			if ((options.negativeColor || options.negativeFillColor) && !options.zones) {\n				zones.push({\n					value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,\n					color: options.negativeColor,\n					fillColor: options.negativeFillColor\n				});\n			}\n			if (zones.length) { // Push one extra zone for the rest\n				if (defined(zones[zones.length - 1].value)) {\n					zones.push({\n						color: this.color,\n						fillColor: this.fillColor\n					});\n				}\n			}\n			return options;\n		},\n\n		getCyclic: function (prop, value, defaults) {\n			var i,\n				userOptions = this.userOptions,\n				indexName = '_' + prop + 'Index',\n				counterName = prop + 'Counter';\n\n			if (!value) {\n				if (defined(userOptions[indexName])) { // after Series.update()\n					i = userOptions[indexName];\n				} else {\n					userOptions[indexName] = i = this.chart[counterName] % defaults.length;\n					this.chart[counterName] += 1;\n				}\n				value = defaults[i];\n			}\n			this[prop] = value;\n		},\n\n		/**\n		 * Get the series' color\n		 */\n		getColor: function () {\n			if (!this.options.colorByPoint) {\n				this.getCyclic('color', this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);\n			}\n		},\n		/**\n		 * Get the series' symbol\n		 */\n		getSymbol: function () {\n			var seriesMarkerOption = this.options.marker;\n\n			this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);\n\n			// don't substract radius in image symbols (#604)\n			if (/^url/.test(this.symbol)) {\n				seriesMarkerOption.radius = 0;\n			}\n		},\n\n		drawLegendSymbol: LegendSymbolMixin.drawLineMarker,\n\n		/**\n		 * Replace the series data with a new set of data\n		 * @param {Object} data\n		 * @param {Object} redraw\n		 */\n		setData: function (data, redraw, animation, updatePoints) {\n			var series = this,\n				oldData = series.points,\n				oldDataLength = (oldData && oldData.length) || 0,\n				dataLength,\n				options = series.options,\n				chart = series.chart,\n				firstPoint = null,\n				xAxis = series.xAxis,\n				hasCategories = xAxis && !!xAxis.categories,\n				i,\n				turboThreshold = options.turboThreshold,\n				pt,\n				xData = this.xData,\n				yData = this.yData,\n				pointArrayMap = series.pointArrayMap,\n				valueCount = pointArrayMap && pointArrayMap.length;\n\n			data = data || [];\n			dataLength = data.length;\n			redraw = pick(redraw, true);\n\n			// If the point count is the same as is was, just run Point.update which is\n			// cheaper, allows animation, and keeps references to points.\n			if (updatePoints !== false && dataLength && oldDataLength === dataLength && !series.cropped && !series.hasGroupedData && series.visible) {\n				each(data, function (point, i) {\n					oldData[i].update(point, false, null, false);\n				});\n\n			} else {\n\n				// Reset properties\n				series.xIncrement = null;\n				series.pointRange = hasCategories ? 1 : options.pointRange;\n\n				series.colorCounter = 0; // for series with colorByPoint (#1547)\n				\n				// Update parallel arrays\n				each(this.parallelArrays, function (key) {\n					series[key + 'Data'].length = 0;\n				});\n\n				// In turbo mode, only one- or twodimensional arrays of numbers are allowed. The\n				// first value is tested, and we assume that all the rest are defined the same\n				// way. Although the 'for' loops are similar, they are repeated inside each\n				// if-else conditional for max performance.\n				if (turboThreshold && dataLength > turboThreshold) {\n\n					// find the first non-null point\n					i = 0;\n					while (firstPoint === null && i < dataLength) {\n						firstPoint = data[i];\n						i++;\n					}\n\n\n					if (isNumber(firstPoint)) { // assume all points are numbers\n						var x = pick(options.pointStart, 0),\n							pointInterval = pick(options.pointInterval, 1);\n\n						for (i = 0; i < dataLength; i++) {\n							xData[i] = x;\n							yData[i] = data[i];\n							x += pointInterval;\n						}\n						series.xIncrement = x;\n					} else if (isArray(firstPoint)) { // assume all points are arrays\n						if (valueCount) { // [x, low, high] or [x, o, h, l, c]\n							for (i = 0; i < dataLength; i++) {\n								pt = data[i];\n								xData[i] = pt[0];\n								yData[i] = pt.slice(1, valueCount + 1);\n							}\n						} else { // [x, y]\n							for (i = 0; i < dataLength; i++) {\n								pt = data[i];\n								xData[i] = pt[0];\n								yData[i] = pt[1];\n							}\n						}\n					} else {\n						error(12); // Highcharts expects configs to be numbers or arrays in turbo mode\n					}\n				} else {\n					for (i = 0; i < dataLength; i++) {\n						if (data[i] !== UNDEFINED) { // stray commas in oldIE\n							pt = { series: series };\n							series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);\n							series.updateParallelArrays(pt, i);\n							if (hasCategories && pt.name) {\n								xAxis.names[pt.x] = pt.name; // #2046\n							}\n						}\n					}\n				}\n\n				// Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON\n				if (isString(yData[0])) {\n					error(14, true);\n				}\n\n				series.data = [];\n				series.options.data = data;\n				//series.zData = zData;\n\n				// destroy old points\n				i = oldDataLength;\n				while (i--) {\n					if (oldData[i] && oldData[i].destroy) {\n						oldData[i].destroy();\n					}\n				}\n\n				// reset minRange (#878)\n				if (xAxis) {\n					xAxis.minRange = xAxis.userMinRange;\n				}\n\n				// redraw\n				series.isDirty = series.isDirtyData = chart.isDirtyBox = true;\n				animation = false;\n			}\n\n			if (redraw) {\n				chart.redraw(animation);\n			}\n		},\n\n		/**\n		 * Process the data by cropping away unused data points if the series is longer\n		 * than the crop threshold. This saves computing time for lage series.\n		 */\n		processData: function (force) {\n			var series = this,\n				processedXData = series.xData, // copied during slice operation below\n				processedYData = series.yData,\n				dataLength = processedXData.length,\n				croppedData,\n				cropStart = 0,\n				cropped,\n				distance,\n				closestPointRange,\n				xAxis = series.xAxis,\n				i, // loop variable\n				options = series.options,\n				cropThreshold = options.cropThreshold,\n				isCartesian = series.isCartesian,\n				xExtremes,\n				min,\n				max;\n\n			// If the series data or axes haven't changed, don't go through this. Return false to pass\n			// the message on to override methods like in data grouping.\n			if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {\n				return false;\n			}\n\n			if (xAxis) {\n				xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)\n				min = xExtremes.min;\n				max = xExtremes.max;\n			}\n\n			// optionally filter out points outside the plot area\n			if (isCartesian && series.sorted && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {\n				\n				// it's outside current extremes\n				if (processedXData[dataLength - 1] < min || processedXData[0] > max) {\n					processedXData = [];\n					processedYData = [];\n\n				// only crop if it's actually spilling out\n				} else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {\n					croppedData = this.cropData(series.xData, series.yData, min, max);\n					processedXData = croppedData.xData;\n					processedYData = croppedData.yData;\n					cropStart = croppedData.start;\n					cropped = true;\n				}\n			}\n\n\n			// Find the closest distance between processed points\n			for (i = processedXData.length - 1; i >= 0; i--) {\n				distance = processedXData[i] - processedXData[i - 1];\n				\n				if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {\n					closestPointRange = distance;\n\n				// Unsorted data is not supported by the line tooltip, as well as data grouping and\n				// navigation in Stock charts (#725) and width calculation of columns (#1900)\n				} else if (distance < 0 && series.requireSorting) {\n					error(15);\n				}\n			}\n\n			// Record the properties\n			series.cropped = cropped; // undefined or true\n			series.cropStart = cropStart;\n			series.processedXData = processedXData;\n			series.processedYData = processedYData;\n\n			if (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC\n				series.pointRange = closestPointRange || 1;\n			}\n			series.closestPointRange = closestPointRange;\n\n		},\n\n		/**\n		 * Iterate over xData and crop values between min and max. Returns object containing crop start/end\n		 * cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range\n		 */\n		cropData: function (xData, yData, min, max) {\n			var dataLength = xData.length,\n				cropStart = 0,\n				cropEnd = dataLength,\n				cropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside\n				i;\n\n			// iterate up to find slice start\n			for (i = 0; i < dataLength; i++) {\n				if (xData[i] >= min) {\n					cropStart = mathMax(0, i - cropShoulder);\n					break;\n				}\n			}\n\n			// proceed to find slice end\n			for (; i < dataLength; i++) {\n				if (xData[i] > max) {\n					cropEnd = i + cropShoulder;\n					break;\n				}\n			}\n\n			return {\n				xData: xData.slice(cropStart, cropEnd),\n				yData: yData.slice(cropStart, cropEnd),\n				start: cropStart,\n				end: cropEnd\n			};\n		},\n\n\n		/**\n		 * Generate the data point after the data has been processed by cropping away\n		 * unused points and optionally grouped in Highcharts Stock.\n		 */\n		generatePoints: function () {\n			var series = this,\n				options = series.options,\n				dataOptions = options.data,\n				data = series.data,\n				dataLength,\n				processedXData = series.processedXData,\n				processedYData = series.processedYData,\n				pointClass = series.pointClass,\n				processedDataLength = processedXData.length,\n				cropStart = series.cropStart || 0,\n				cursor,\n				hasGroupedData = series.hasGroupedData,\n				point,\n				points = [],\n				i;\n\n			if (!data && !hasGroupedData) {\n				var arr = [];\n				arr.length = dataOptions.length;\n				data = series.data = arr;\n			}\n\n			for (i = 0; i < processedDataLength; i++) {\n				cursor = cropStart + i;\n				if (!hasGroupedData) {\n					if (data[cursor]) {\n						point = data[cursor];\n					} else if (dataOptions[cursor] !== UNDEFINED) { // #970\n						data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);\n					}\n					points[i] = point;\n				} else {\n					// splat the y data in case of ohlc data array\n					points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));\n				}\n				points[i].index = cursor; // For faster access in Point.update\n			}\n\n			// Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when\n			// swithching view from non-grouped data to grouped data (#637)\n			if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {\n				for (i = 0; i < dataLength; i++) {\n					if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points\n						i += processedDataLength;\n					}\n					if (data[i]) {\n						data[i].destroyElements();\n						data[i].plotX = UNDEFINED; // #1003\n					}\n				}\n			}\n\n			series.data = data;\n			series.points = points;\n		},\n\n		/**\n		 * Calculate Y extremes for visible data\n		 */\n		getExtremes: function (yData) {\n			var xAxis = this.xAxis,\n				yAxis = this.yAxis,\n				xData = this.processedXData,\n				yDataLength,\n				activeYData = [],\n				activeCounter = 0,\n				xExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis\n				xMin = xExtremes.min,\n				xMax = xExtremes.max,\n				validValue,\n				withinRange,\n				dataMin,\n				dataMax,\n				x,\n				y,\n				i,\n				j;\n\n			yData = yData || this.stackedYData || this.processedYData;\n			yDataLength = yData.length;\n\n			for (i = 0; i < yDataLength; i++) {\n\n				x = xData[i];\n				y = yData[i];\n\n				// For points within the visible range, including the first point outside the\n				// visible range, consider y extremes\n				validValue = y !== null && y !== UNDEFINED && (!yAxis.isLog || (y.length || y > 0));\n				withinRange = this.getExtremesFromAll || this.cropped || ((xData[i + 1] || x) >= xMin &&\n					(xData[i - 1] || x) <= xMax);\n\n				if (validValue && withinRange) {\n\n					j = y.length;\n					if (j) { // array, like ohlc or range data\n						while (j--) {\n							if (y[j] !== null) {\n								activeYData[activeCounter++] = y[j];\n							}\n						}\n					} else {\n						activeYData[activeCounter++] = y;\n					}\n				}\n			}\n			this.dataMin = pick(dataMin, arrayMin(activeYData));\n			this.dataMax = pick(dataMax, arrayMax(activeYData));\n		},\n\n		/**\n		 * Translate data points from raw data values to chart specific positioning data\n		 * needed later in drawPoints, drawGraph and drawTracker.\n		 */\n		translate: function () {\n			if (!this.processedXData) { // hidden series\n				this.processData();\n			}\n			this.generatePoints();\n			var series = this,\n				options = series.options,\n				stacking = options.stacking,\n				xAxis = series.xAxis,\n				categories = xAxis.categories,\n				yAxis = series.yAxis,\n				points = series.points,\n				dataLength = points.length,\n				hasModifyValue = !!series.modifyValue,\n				i,\n				pointPlacement = options.pointPlacement,\n				dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),\n				threshold = options.threshold,\n				plotX,\n				plotY,\n				lastPlotX,\n				closestPointRangePx = Number.MAX_VALUE;\n\n			// Translate each point\n			for (i = 0; i < dataLength; i++) {\n				var point = points[i],\n					xValue = point.x,\n					yValue = point.y,\n					yBottom = point.low,\n					stack = stacking && yAxis.stacks[(series.negStacks && yValue < threshold ? '-' : '') + series.stackKey],\n					pointStack,\n					stackValues;\n\n				// Discard disallowed y values for log axes (#3434)\n				if (yAxis.isLog && yValue !== null && yValue <= 0) {\n					point.y = yValue = null;\n					error(10);\n				}\n\n				// Get the plotX translation\n				point.plotX = plotX = xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags'); // Math.round fixes #591\n\n\n				// Calculate the bottom y value for stacked series\n				if (stacking && series.visible && stack && stack[xValue]) {\n\n					pointStack = stack[xValue];\n					stackValues = pointStack.points[series.index + ',' + i];\n					yBottom = stackValues[0];\n					yValue = stackValues[1];\n\n					if (yBottom === 0) {\n						yBottom = pick(threshold, yAxis.min);\n					}\n					if (yAxis.isLog && yBottom <= 0) { // #1200, #1232\n						yBottom = null;\n					}\n\n					point.total = point.stackTotal = pointStack.total;\n					point.percentage = pointStack.total && (point.y / pointStack.total * 100);\n					point.stackY = yValue;\n\n					// Place the stack label\n					pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);\n\n				}\n\n				// Set translated yBottom or remove it\n				point.yBottom = defined(yBottom) ?\n					yAxis.translate(yBottom, 0, 1, 0, 1) :\n					null;\n\n				// general hook, used for Highstock compare mode\n				if (hasModifyValue) {\n					yValue = series.modifyValue(yValue, point);\n				}\n\n				// Set the the plotY value, reset it for redraws\n				point.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?\n					mathMin(mathMax(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201\n					UNDEFINED;\n				point.isInside = plotY !== UNDEFINED && plotY >= 0 && plotY <= yAxis.len && // #3519\n					plotX >= 0 && plotX <= xAxis.len;\n\n\n				// Set client related positions for mouse tracking\n				point.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : plotX; // #1514\n\n				point.negative = point.y < (threshold || 0);\n\n				// some API data\n				point.category = categories && categories[point.x] !== UNDEFINED ?\n					categories[point.x] : point.x;\n\n				// Determine auto enabling of markers (#3635)\n				if (i) {\n					closestPointRangePx = mathMin(closestPointRangePx, mathAbs(plotX - lastPlotX));\n				}\n				lastPlotX = plotX;\n\n			}\n\n			series.closestPointRangePx = closestPointRangePx;\n\n			// now that we have the cropped data, build the segments\n			series.getSegments();\n		},\n\n		/**\n		 * Set the clipping for the series. For animated series it is called twice, first to initiate\n		 * animating the clip then the second time without the animation to set the final clip.\n		 */\n		setClip: function (animation) {\n			var chart = this.chart,\n				renderer = chart.renderer,\n				inverted = chart.inverted,\n				seriesClipBox = this.clipBox,\n				clipBox = seriesClipBox || chart.clipBox,\n				sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height].join(','),\n				clipRect = chart[sharedClipKey],\n				markerClipRect = chart[sharedClipKey + 'm'];\n\n			// If a clipping rectangle with the same properties is currently present in the chart, use that.\n			if (!clipRect) {\n\n				// When animation is set, prepare the initial positions\n				if (animation) { \n					clipBox.width = 0;\n\n					chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(\n						-99, // include the width of the first marker\n						inverted ? -chart.plotLeft : -chart.plotTop,\n						99,\n						inverted ? chart.chartWidth : chart.chartHeight\n					);\n				}\n				chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);\n				\n			}\n			if (animation) {\n				clipRect.count += 1;\n			}\n\n			if (this.options.clip !== false) {\n				this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);\n				this.markerGroup.clip(markerClipRect);\n				this.sharedClipKey = sharedClipKey;\n			}\n\n			// Remove the shared clipping rectancgle when all series are shown\n			if (!animation) {\n				clipRect.count -= 1;\n				if (clipRect.count <= 0 && sharedClipKey && chart[sharedClipKey]) {\n					if (!seriesClipBox) {\n						chart[sharedClipKey] = chart[sharedClipKey].destroy();\n					}\n					if (chart[sharedClipKey + 'm']) {\n						chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();\n					}\n				}\n			}\n		},\n\n		/**\n		 * Animate in the series\n		 */\n		animate: function (init) {\n			var series = this,\n				chart = series.chart,\n				clipRect,\n				animation = series.options.animation,\n				sharedClipKey;\n\n			// Animation option is set to true\n			if (animation && !isObject(animation)) {\n				animation = defaultPlotOptions[series.type].animation;\n			}\n\n			// Initialize the animation. Set up the clipping rectangle.\n			if (init) {\n\n				series.setClip(animation);\n\n			// Run the animation\n			} else {\n				sharedClipKey = this.sharedClipKey;\n				clipRect = chart[sharedClipKey];\n				if (clipRect) {\n					clipRect.animate({\n						width: chart.plotSizeX\n					}, animation);\n				}\n				if (chart[sharedClipKey + 'm']) {\n					chart[sharedClipKey + 'm'].animate({\n						width: chart.plotSizeX + 99\n					}, animation);\n				}\n\n				// Delete this function to allow it only once\n				series.animate = null;\n	 \n			}\n		},\n\n		/**\n		 * This runs after animation to land on the final plot clipping\n		 */\n		afterAnimate: function () {\n			this.setClip();\n			fireEvent(this, 'afterAnimate');\n		},\n\n		/**\n		 * Draw the markers\n		 */\n		drawPoints: function () {\n			var series = this,\n				pointAttr,\n				points = series.points,\n				chart = series.chart,\n				plotX,\n				plotY,\n				i,\n				point,\n				radius,\n				symbol,\n				isImage,\n				graphic,\n				options = series.options,\n				seriesMarkerOptions = options.marker,\n				seriesPointAttr = series.pointAttr[''],\n				pointMarkerOptions,\n				hasPointMarker,\n				enabled,\n				isInside,\n				markerGroup = series.markerGroup,\n				xAxis = series.xAxis,\n				globallyEnabled = pick(\n					seriesMarkerOptions.enabled, \n					xAxis.isRadial,\n					series.closestPointRangePx > 2 * seriesMarkerOptions.radius\n				);\n\n			if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {\n\n				i = points.length;\n				while (i--) {\n					point = points[i];\n					plotX = mathFloor(point.plotX); // #1843\n					plotY = point.plotY;\n					graphic = point.graphic;\n					pointMarkerOptions = point.marker || {};\n					hasPointMarker = !!point.marker;\n					enabled = (globallyEnabled && pointMarkerOptions.enabled === UNDEFINED) || pointMarkerOptions.enabled;\n					isInside = point.isInside;\n\n					// only draw the point if y is defined\n					if (enabled && plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {\n\n						// shortcuts\n						pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || seriesPointAttr;\n						radius = pointAttr.r;\n						symbol = pick(pointMarkerOptions.symbol, series.symbol);\n						isImage = symbol.indexOf('url') === 0;\n\n						if (graphic) { // update\n							graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled\n								.animate(extend({\n									x: plotX - radius,\n									y: plotY - radius\n								}, graphic.symbolName ? { // don't apply to image symbols #507\n									width: 2 * radius,\n									height: 2 * radius\n								} : {}));\n						} else if (isInside && (radius > 0 || isImage)) {\n							point.graphic = graphic = chart.renderer.symbol(\n								symbol,\n								plotX - radius,\n								plotY - radius,\n								2 * radius,\n								2 * radius,\n								hasPointMarker ? pointMarkerOptions : seriesMarkerOptions\n							)\n							.attr(pointAttr)\n							.add(markerGroup);\n						}\n\n					} else if (graphic) {\n						point.graphic = graphic.destroy(); // #1269\n					}\n				}\n			}\n\n		},\n\n		/**\n		 * Convert state properties from API naming conventions to SVG attributes\n		 *\n		 * @param {Object} options API options object\n		 * @param {Object} base1 SVG attribute object to inherit from\n		 * @param {Object} base2 Second level SVG attribute object to inherit from\n		 */\n		convertAttribs: function (options, base1, base2, base3) {\n			var conversion = this.pointAttrToOptions,\n				attr,\n				option,\n				obj = {};\n\n			options = options || {};\n			base1 = base1 || {};\n			base2 = base2 || {};\n			base3 = base3 || {};\n\n			for (attr in conversion) {\n				option = conversion[attr];\n				obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);\n			}\n			return obj;\n		},\n\n		/**\n		 * Get the state attributes. Each series type has its own set of attributes\n		 * that are allowed to change on a point's state change. Series wide attributes are stored for\n		 * all series, and additionally point specific attributes are stored for all\n		 * points with individual marker options. If such options are not defined for the point,\n		 * a reference to the series wide attributes is stored in point.pointAttr.\n		 */\n		getAttribs: function () {\n			var series = this,\n				seriesOptions = series.options,\n				normalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions,\n				stateOptions = normalOptions.states,\n				stateOptionsHover = stateOptions[HOVER_STATE],\n				pointStateOptionsHover,\n				seriesColor = series.color,\n				seriesNegativeColor = series.options.negativeColor,\n				normalDefaults = {\n					stroke: seriesColor,\n					fill: seriesColor\n				},\n				points = series.points || [], // #927\n				i,\n				point,\n				seriesPointAttr = [],\n				pointAttr,\n				pointAttrToOptions = series.pointAttrToOptions,\n				hasPointSpecificOptions = series.hasPointSpecificOptions,\n				defaultLineColor = normalOptions.lineColor,\n				defaultFillColor = normalOptions.fillColor,\n				turboThreshold = seriesOptions.turboThreshold,\n				zones = series.zones,\n				zoneAxis = series.zoneAxis || 'y',\n				attr,\n				key;\n\n			// series type specific modifications\n			if (seriesOptions.marker) { // line, spline, area, areaspline, scatter\n\n				// if no hover radius is given, default to normal radius + 2\n				stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + stateOptionsHover.radiusPlus;\n				stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + stateOptionsHover.lineWidthPlus;\n\n			} else { // column, bar, pie\n\n				// if no hover color is given, brighten the normal color\n				stateOptionsHover.color = stateOptionsHover.color ||\n					Color(stateOptionsHover.color || seriesColor)\n						.brighten(stateOptionsHover.brightness).get();\n\n				// if no hover negativeColor is given, brighten the normal negativeColor\n				stateOptionsHover.negativeColor = stateOptionsHover.negativeColor ||\n					Color(stateOptionsHover.negativeColor || seriesNegativeColor)\n						.brighten(stateOptionsHover.brightness).get();\n			}\n\n			// general point attributes for the series normal state\n			seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);\n\n			// HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius\n			each([HOVER_STATE, SELECT_STATE], function (state) {\n				seriesPointAttr[state] =\n						series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);\n			});\n\n			// set it\n			series.pointAttr = seriesPointAttr;\n\n\n			// Generate the point-specific attribute collections if specific point\n			// options are given. If not, create a referance to the series wide point\n			// attributes\n			i = points.length;\n			if (!turboThreshold || i < turboThreshold || hasPointSpecificOptions) {\n				while (i--) {\n					point = points[i];\n					normalOptions = (point.options && point.options.marker) || point.options;\n					if (normalOptions && normalOptions.enabled === false) {\n						normalOptions.radius = 0;\n					}\n\n					if (zones.length) {\n						var j = 0,\n							threshold = zones[j];\n						while (point[zoneAxis] >= threshold.value) {				\n							threshold = zones[++j];\n						}\n						\n						point.color = point.fillColor = threshold.color;\n					}\n\n					hasPointSpecificOptions = seriesOptions.colorByPoint || point.color; // #868\n\n					// check if the point has specific visual options\n					if (point.options) {\n						for (key in pointAttrToOptions) {\n							if (defined(normalOptions[pointAttrToOptions[key]])) {\n								hasPointSpecificOptions = true;\n							}\n						}\n					}\n\n					// a specific marker config object is defined for the individual point:\n					// create it's own attribute collection\n					if (hasPointSpecificOptions) {\n						normalOptions = normalOptions || {};\n						pointAttr = [];\n						stateOptions = normalOptions.states || {}; // reassign for individual point\n						pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};\n\n						// Handle colors for column and pies\n						if (!seriesOptions.marker) { // column, bar, point\n							// If no hover color is given, brighten the normal color. #1619, #2579\n							pointStateOptionsHover.color = pointStateOptionsHover.color || (!point.options.color && stateOptionsHover[(point.negative && seriesNegativeColor ? 'negativeColor' : 'color')]) ||\n								Color(point.color)\n									.brighten(pointStateOptionsHover.brightness || stateOptionsHover.brightness)\n									.get();\n						}\n\n						// normal point state inherits series wide normal state\n						attr = { color: point.color }; // #868\n						if (!defaultFillColor) { // Individual point color or negative color markers (#2219)\n							attr.fillColor = point.color;\n						}\n						if (!defaultLineColor) {\n							attr.lineColor = point.color; // Bubbles take point color, line markers use white\n						}\n						pointAttr[NORMAL_STATE] = series.convertAttribs(extend(attr, normalOptions), seriesPointAttr[NORMAL_STATE]);\n\n						// inherit from point normal and series hover\n						pointAttr[HOVER_STATE] = series.convertAttribs(\n							stateOptions[HOVER_STATE],\n							seriesPointAttr[HOVER_STATE],\n							pointAttr[NORMAL_STATE]\n						);\n\n						// inherit from point normal and series hover\n						pointAttr[SELECT_STATE] = series.convertAttribs(\n							stateOptions[SELECT_STATE],\n							seriesPointAttr[SELECT_STATE],\n							pointAttr[NORMAL_STATE]\n						);\n\n\n					// no marker config object is created: copy a reference to the series-wide\n					// attribute collection\n					} else {\n						pointAttr = seriesPointAttr;\n					}\n\n					point.pointAttr = pointAttr;\n				}\n			}\n		},\n\n		/**\n		 * Clear DOM objects and free up memory\n		 */\n		destroy: function () {\n			var series = this,\n				chart = series.chart,\n				issue134 = /AppleWebKit\\/533/.test(userAgent),\n				destroy,\n				i,\n				data = series.data || [],\n				point,\n				prop,\n				axis;\n\n			// add event hook\n			fireEvent(series, 'destroy');\n\n			// remove all events\n			removeEvent(series);\n\n			// erase from axes\n			each(series.axisTypes || [], function (AXIS) {\n				axis = series[AXIS];\n				if (axis) {\n					erase(axis.series, series);\n					axis.isDirty = axis.forceRedraw = true;\n				}\n			});\n\n			// remove legend items\n			if (series.legendItem) {\n				series.chart.legend.destroyItem(series);\n			}\n\n			// destroy all points with their elements\n			i = data.length;\n			while (i--) {\n				point = data[i];\n				if (point && point.destroy) {\n					point.destroy();\n				}\n			}\n			series.points = null;\n\n			// Clear the animation timeout if we are destroying the series during initial animation\n			clearTimeout(series.animationTimeout);\n\n			// destroy all SVGElements associated to the series\n			each(['area', 'graph', 'dataLabelsGroup', 'group', 'markerGroup', 'tracker',\n					'graphNeg', 'areaNeg', 'posClip', 'negClip'], function (prop) {\n				if (series[prop]) {\n\n					// issue 134 workaround\n					destroy = issue134 && prop === 'group' ?\n						'hide' :\n						'destroy';\n\n					series[prop][destroy]();\n				}\n			});\n\n			// remove from hoverSeries\n			if (chart.hoverSeries === series) {\n				chart.hoverSeries = null;\n			}\n			erase(chart.series, series);\n\n			// clear all members\n			for (prop in series) {\n				delete series[prop];\n			}\n		},\n\n		/**\n		 * Return the graph path of a segment\n		 */\n		getSegmentPath: function (segment) {\n			var series = this,\n				segmentPath = [],\n				step = series.options.step;\n\n			// build the segment line\n			each(segment, function (point, i) {\n\n				var plotX = point.plotX,\n					plotY = point.plotY,\n					lastPoint;\n\n				if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object\n					segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));\n\n				} else {\n\n					// moveTo or lineTo\n					segmentPath.push(i ? L : M);\n\n					// step line?\n					if (step && i) {\n						lastPoint = segment[i - 1];\n						if (step === 'right') {\n							segmentPath.push(\n								lastPoint.plotX,\n								plotY\n							);\n\n						} else if (step === 'center') {\n							segmentPath.push(\n								(lastPoint.plotX + plotX) / 2,\n								lastPoint.plotY,\n								(lastPoint.plotX + plotX) / 2,\n								plotY\n							);\n\n						} else {\n							segmentPath.push(\n								plotX,\n								lastPoint.plotY\n							);\n						}\n					}\n\n					// normal line to next point\n					segmentPath.push(\n						point.plotX,\n						point.plotY\n					);\n				}\n			});\n\n			return segmentPath;\n		},\n\n		/**\n		 * Get the graph path\n		 */\n		getGraphPath: function () {\n			var series = this,\n				graphPath = [],\n				segmentPath,\n				singlePoints = []; // used in drawTracker\n\n			// Divide into segments and build graph and area paths\n			each(series.segments, function (segment) {\n\n				segmentPath = series.getSegmentPath(segment);\n\n				// add the segment to the graph, or a single point for tracking\n				if (segment.length > 1) {\n					graphPath = graphPath.concat(segmentPath);\n				} else {\n					singlePoints.push(segment[0]);\n				}\n			});\n\n			// Record it for use in drawGraph and drawTracker, and return graphPath\n			series.singlePoints = singlePoints;\n			series.graphPath = graphPath;\n\n			return graphPath;\n\n		},\n\n		/**\n		 * Draw the actual graph\n		 */\n		drawGraph: function () {\n			var series = this,\n				options = this.options,\n				props = [['graph', options.lineColor || this.color, options.dashStyle]],\n				lineWidth = options.lineWidth,\n				roundCap = options.linecap !== 'square',\n				graphPath = this.getGraphPath(),\n				fillColor = (this.fillGraph && this.color) || NONE, // polygon series use filled graph\n				zones = this.zones;\n\n			each(zones, function (threshold, i) {\n				props.push(['colorGraph' + i, threshold.color || series.color, threshold.dashStyle || options.dashStyle]);\n			});\n			\n			// Draw the graph\n			each(props, function (prop, i) {\n				var graphKey = prop[0],\n					graph = series[graphKey],\n					attribs;\n\n				if (graph) {\n					stop(graph); // cancel running animations, #459\n					graph.animate({ d: graphPath });\n\n				} else if ((lineWidth || fillColor) && graphPath.length) { // #1487\n					attribs = {\n						stroke: prop[1],\n						'stroke-width': lineWidth,\n						fill: fillColor,\n						zIndex: 1 // #1069\n					};\n					if (prop[2]) {\n						attribs.dashstyle = prop[2];\n					} else if (roundCap) {\n						attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';\n					}\n\n					series[graphKey] = series.chart.renderer.path(graphPath)\n						.attr(attribs)\n						.add(series.group)\n						.shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932\n				}\n			});\n		},\n\n		/**\n		 * Clip the graphs into the positive and negative coloured graphs\n		 */\n		applyZones: function () {\n			var series = this,\n				chart = this.chart,\n				renderer = chart.renderer,\n				zones = this.zones,\n				translatedFrom,\n				translatedTo,\n				clips = this.clips || [],\n				clipAttr,\n				graph = this.graph,\n				area = this.area,\n				chartSizeMax = mathMax(chart.chartWidth, chart.chartHeight),\n				zoneAxis = this.zoneAxis || 'y',\n				axis = this[zoneAxis + 'Axis'],\n				reversed = axis.reversed,\n				horiz = axis.horiz,\n				ignoreZones = false;\n\n			if (zones.length && (graph || area)) {\n				// The use of the Color Threshold assumes there are no gaps\n				// so it is safe to hide the original graph and area\n				graph.hide();\n				if (area) { area.hide(); }\n\n				// Create the clips\n				each(zones, function (threshold, i) {\n					translatedFrom = pick(translatedTo, (reversed ? (horiz ? chart.plotWidth : 0) : (horiz ? 0 : axis.toPixels(axis.min))));\n					translatedTo = mathRound(axis.toPixels(pick(threshold.value, axis.max), true));\n\n					if (ignoreZones) {\n						translatedFrom = translatedTo = axis.toPixels(axis.max);\n					}\n\n					if (axis.isXAxis) {\n						clipAttr = {\n							x: reversed ? translatedTo : translatedFrom,\n							y: 0,\n							width: Math.abs(translatedFrom - translatedTo), \n							height: chartSizeMax\n						};\n						if (!horiz) {\n							clipAttr.x = chart.plotHeight - clipAttr.x;\n						}\n					} else {\n						clipAttr = {\n							x: 0,\n							y: reversed ? translatedFrom : translatedTo,\n							width: chartSizeMax, \n							height: Math.abs(translatedFrom - translatedTo)\n						};\n						if (horiz) {\n							clipAttr.y = chart.plotWidth - clipAttr.y;\n						}\n					} \n\n					/// VML SUPPPORT\n					if (chart.inverted && renderer.isVML) {\n						if (axis.isXAxis) {			\n							clipAttr = {\n								x: 0,\n								y: reversed ? translatedFrom : translatedTo,\n								height: clipAttr.width,\n								width: chart.chartWidth\n							};		\n						} else {				\n							clipAttr = {\n								x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,\n								y: 0,\n								width: clipAttr.height,\n								height: chart.chartHeight\n							};	\n						}				\n					}\n					/// END OF VML SUPPORT\n\n					if (clips[i]) {\n						clips[i].animate(clipAttr);\n					} else {\n						clips[i] = renderer.clipRect(clipAttr);\n\n						series['colorGraph' + i].clip(clips[i]);\n\n						if (area) {\n							series['colorArea' + i].clip(clips[i]);\n						}\n					}\n					// if this zone extends out of the axis, ignore the others\n					ignoreZones = threshold.value > axis.max;\n				});\n				this.clips = clips;\n			}\n		},\n\n		/**\n		 * Initialize and perform group inversion on series.group and series.markerGroup\n		 */\n		invertGroups: function () {\n			var series = this,\n				chart = series.chart;\n\n			// Pie, go away (#1736)\n			if (!series.xAxis) {\n				return;\n			}\n\n			// A fixed size is needed for inversion to work\n			function setInvert() {\n				var size = {\n					width: series.yAxis.len,\n					height: series.xAxis.len\n				};\n\n				each(['group', 'markerGroup'], function (groupName) {\n					if (series[groupName]) {\n						series[groupName].attr(size).invert();\n					}\n				});\n			}\n\n			addEvent(chart, 'resize', setInvert); // do it on resize\n			addEvent(series, 'destroy', function () {\n				removeEvent(chart, 'resize', setInvert);\n			});\n\n			// Do it now\n			setInvert(); // do it now\n\n			// On subsequent render and redraw, just do setInvert without setting up events again\n			series.invertGroups = setInvert;\n		},\n\n		/**\n		 * General abstraction for creating plot groups like series.group, series.dataLabelsGroup and\n		 * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.\n		 */\n		plotGroup: function (prop, name, visibility, zIndex, parent) {\n			var group = this[prop],\n				isNew = !group;\n\n			// Generate it on first call\n			if (isNew) {\n				this[prop] = group = this.chart.renderer.g(name)\n					.attr({\n						visibility: visibility,\n						zIndex: zIndex || 0.1 // IE8 needs this\n					})\n					.add(parent);\n			}\n			// Place it on first and subsequent (redraw) calls\n			group[isNew ? 'attr' : 'animate'](this.getPlotBox());\n			return group;\n		},\n\n		/**\n		 * Get the translation and scale for the plot area of this series\n		 */\n		getPlotBox: function () {\n			var chart = this.chart,\n				xAxis = this.xAxis,\n				yAxis = this.yAxis;\n\n			// Swap axes for inverted (#2339)\n			if (chart.inverted) {\n				xAxis = yAxis;\n				yAxis = this.xAxis;\n			}\n			return {\n				translateX: xAxis ? xAxis.left : chart.plotLeft,\n				translateY: yAxis ? yAxis.top : chart.plotTop,\n				scaleX: 1, // #1623\n				scaleY: 1\n			};\n		},\n\n		/**\n		 * Render the graph and markers\n		 */\n		render: function () {\n			var series = this,\n				chart = series.chart,\n				group,\n				options = series.options,\n				animation = options.animation,\n				// Animation doesn't work in IE8 quirks when the group div is hidden,\n				// and looks bad in other oldIE\n				animDuration = (animation && !!series.animate && chart.renderer.isSVG && pick(animation.duration, 500)) || 0,\n				visibility = series.visible ? VISIBLE : HIDDEN,\n				zIndex = options.zIndex,\n				hasRendered = series.hasRendered,\n				chartSeriesGroup = chart.seriesGroup;\n\n			// the group\n			group = series.plotGroup(\n				'group',\n				'series',\n				visibility,\n				zIndex,\n				chartSeriesGroup\n			);\n\n			series.markerGroup = series.plotGroup(\n				'markerGroup',\n				'markers',\n				visibility,\n				zIndex,\n				chartSeriesGroup\n			);\n\n			// initiate the animation\n			if (animDuration) {\n				series.animate(true);\n			}\n\n			// cache attributes for shapes\n			series.getAttribs();\n\n			// SVGRenderer needs to know this before drawing elements (#1089, #1795)\n			group.inverted = series.isCartesian ? chart.inverted : false;\n\n			// draw the graph if any\n			if (series.drawGraph) {\n				series.drawGraph();\n				series.applyZones();\n			}\n\n			each(series.points, function (point) {\n				if (point.redraw) {\n					point.redraw();\n				}\n			});\n\n			// draw the data labels (inn pies they go before the points)\n			if (series.drawDataLabels) {\n				series.drawDataLabels();\n			}\n\n			// draw the points\n			if (series.visible) {\n				series.drawPoints();\n			}\n\n\n			// draw the mouse tracking area\n			if (series.drawTracker && series.options.enableMouseTracking !== false) {\n				series.drawTracker();\n			}\n\n			// Handle inverted series and tracker groups\n			if (chart.inverted) {\n				series.invertGroups();\n			}\n\n			// Initial clipping, must be defined after inverting groups for VML. Applies to columns etc. (#3839).\n			if (options.clip !== false && !series.sharedClipKey && !hasRendered) {\n				group.clip(chart.clipRect);\n			}\n\n			// Run the animation\n			if (animDuration) {\n				series.animate();\n			} \n\n			// Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option\n			// which should be available to the user).\n			if (!hasRendered) {\n				if (animDuration) {\n					series.animationTimeout = setTimeout(function () {\n						series.afterAnimate();\n					}, animDuration);\n				} else {\n					series.afterAnimate();\n				}\n			}\n\n			series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see\n			// (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see\n			series.hasRendered = true;\n		},\n\n		/**\n		 * Redraw the series after an update in the axes.\n		 */\n		redraw: function () {\n			var series = this,\n				chart = series.chart,\n				wasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after\n				wasDirty = series.isDirty,\n				group = series.group,\n				xAxis = series.xAxis,\n				yAxis = series.yAxis;\n\n			// reposition on resize\n			if (group) {\n				if (chart.inverted) {\n					group.attr({\n						width: chart.plotWidth,\n						height: chart.plotHeight\n					});\n				}\n\n				group.animate({\n					translateX: pick(xAxis && xAxis.left, chart.plotLeft),\n					translateY: pick(yAxis && yAxis.top, chart.plotTop)\n				});\n			}\n\n			series.translate();\n			series.render();\n			if (wasDirtyData) {\n				fireEvent(series, 'updatedData');\n			}\n			if (wasDirty || wasDirtyData) {			// #3945 recalculate the kdtree when dirty\n				delete this.kdTree; // #3868 recalculate the kdtree with dirty data\n			}\n		},\n\n		/**\n		 * KD Tree && PointSearching Implementation\n		 */\n\n		kdDimensions: 1,\n		kdTree: null,\n		kdAxisArray: ['clientX', 'plotY'],\n		kdComparer: 'distX',\n\n		searchPoint: function (e) {\n			var series = this,\n				xAxis = series.xAxis,\n				yAxis = series.yAxis,\n				inverted = series.chart.inverted;\n			\n			return this.searchKDTree({\n				clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,\n				plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos\n			});\n		},\n\n		buildKDTree: function () {\n			var series = this,\n				dimensions = series.kdDimensions;\n\n			// Internal function\n			function _kdtree(points, depth, dimensions) {\n				var axis, median, length = points && points.length;\n\n				if (length) {\n\n					// alternate between the axis\n					axis = series.kdAxisArray[depth % dimensions];\n\n					// sort point array\n					points.sort(function(a, b) {\n						return a[axis] - b[axis];\n					});\n				\n					median = Math.floor(length / 2);\n					\n					// build and return node\n					return {\n						point: points[median],\n						left: _kdtree(points.slice(0, median), depth + 1, dimensions),\n						right: _kdtree(points.slice(median + 1), depth + 1, dimensions)\n					};\n				\n				}\n			}\n\n			// Start the recursive build process with a clone of the points array and null points filtered out (#3873)\n			function startRecursive() {\n				var points = grep(series.points, function (point) {\n					return point.y !== null;\n				});\n				series.kdTree = _kdtree(points, dimensions, dimensions);		\n			}\n\n			delete series.kdTree;\n			\n			if (series.options.kdSync) {  // For testing tooltips, don't build async\n				startRecursive();\n			} else {\n				setTimeout(startRecursive);\n			}\n		},\n\n		searchKDTree: function (point) {\n			var series = this,\n				kdComparer = this.kdComparer,\n				kdX = this.kdAxisArray[0],\n				kdY = this.kdAxisArray[1];\n\n			// Internal function\n			function _distance(p1, p2) {\n				var x = (defined(p1[kdX]) && defined(p2[kdX])) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,\n					y = (defined(p1[kdY]) && defined(p2[kdY])) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,\n					r = (x || 0) + (y || 0);\n					\n				return {\n					distX: defined(x) ? Math.sqrt(x) : Number.MAX_VALUE,\n					distY: defined(y) ? Math.sqrt(y) : Number.MAX_VALUE,\n					distR: defined(r) ? Math.sqrt(r) : Number.MAX_VALUE\n				};\n			}\n			function _search(search, tree, depth, dimensions) {\n				var point = tree.point,\n					axis = series.kdAxisArray[depth % dimensions],\n					tdist,\n					sideA,\n					sideB,\n					ret = point,\n					nPoint1,\n					nPoint2;\n				point.dist = _distance(search, point);\n\n				// Pick side based on distance to splitting point\n				tdist = search[axis] - point[axis];\n				sideA = tdist < 0 ? 'left' : 'right';\n\n				// End of tree\n				if (tree[sideA]) {\n					nPoint1 =_search(search, tree[sideA], depth + 1, dimensions);\n\n					ret = (nPoint1.dist[kdComparer] < ret.dist[kdComparer] ? nPoint1 : point);\n\n					sideB = tdist < 0 ? 'right' : 'left';\n					if (tree[sideB]) {\n						// compare distance to current best to splitting point to decide wether to check side B or not\n						if (Math.sqrt(tdist*tdist) < ret.dist[kdComparer]) {\n							nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);\n							ret = (nPoint2.dist[kdComparer] < ret.dist[kdComparer] ? nPoint2 : ret);\n						}\n					}\n				}\n				return ret;\n			}\n\n			if (!this.kdTree) {\n				this.buildKDTree();\n			}\n\n			if (this.kdTree) {\n				return _search(point, \n					this.kdTree, this.kdDimensions, this.kdDimensions);\n			}\n		}\n\n	}; // end Series prototype\n\n	/**\n	 * The class for stack items\n	 */\n	function StackItem(axis, options, isNegative, x, stackOption) {\n		\n		var inverted = axis.chart.inverted;\n\n		this.axis = axis;\n\n		// Tells if the stack is negative\n		this.isNegative = isNegative;\n\n		// Save the options to be able to style the label\n		this.options = options;\n\n		// Save the x value to be able to position the label later\n		this.x = x;\n\n		// Initialize total value\n		this.total = null;\n\n		// This will keep each points' extremes stored by series.index and point index\n		this.points = {};\n\n		// Save the stack option on the series configuration object, and whether to treat it as percent\n		this.stack = stackOption;\n\n		// The align options and text align varies on whether the stack is negative and\n		// if the chart is inverted or not.\n		// First test the user supplied value, then use the dynamic.\n		this.alignOptions = {\n			align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),\n			verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),\n			y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),\n			x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)\n		};\n\n		this.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');\n	}\n\n	StackItem.prototype = {\n		destroy: function () {\n			destroyObjectProperties(this, this.axis);\n		},\n\n		/**\n		 * Renders the stack total label and adds it to the stack label group.\n		 */\n		render: function (group) {\n			var options = this.options,\n				formatOption = options.format,\n				str = formatOption ?\n					format(formatOption, this) : \n					options.formatter.call(this);  // format the text in the label\n\n			// Change the text to reflect the new total and set visibility to hidden in case the serie is hidden\n			if (this.label) {\n				this.label.attr({text: str, visibility: HIDDEN});\n			// Create new label\n			} else {\n				this.label =\n					this.axis.chart.renderer.text(str, null, null, options.useHTML)		// dummy positions, actual position updated with setOffset method in columnseries\n						.css(options.style)				// apply style\n						.attr({\n							align: this.textAlign,				// fix the text-anchor\n							rotation: options.rotation,	// rotation\n							visibility: HIDDEN					// hidden until setOffset is called\n						})				\n						.add(group);							// add to the labels-group\n			}\n		},\n\n		/**\n		 * Sets the offset that the stack has from the x value and repositions the label.\n		 */\n		setOffset: function (xOffset, xWidth) {\n			var stackItem = this,\n				axis = stackItem.axis,\n				chart = axis.chart,\n				inverted = chart.inverted,\n				neg = this.isNegative,							// special treatment is needed for negative stacks\n				y = axis.translate(axis.usePercentage ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates\n				yZero = axis.translate(0),						// stack origin\n				h = mathAbs(y - yZero),							// stack height\n				x = chart.xAxis[0].translate(this.x) + xOffset,	// stack x position\n				plotHeight = chart.plotHeight,\n				stackBox = {	// this is the box for the complete stack\n					x: inverted ? (neg ? y : y - h) : x,\n					y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),\n					width: inverted ? h : xWidth,\n					height: inverted ? xWidth : h\n				},\n				label = this.label,\n				alignAttr;\n			\n			if (label) {\n				label.align(this.alignOptions, null, stackBox);	// align the label to the box\n					\n				// Set visibility (#678)\n				alignAttr = label.alignAttr;\n				label[this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? 'show' : 'hide'](true);\n			}\n		}\n	};\n\n\n	// Stacking methods defined on the Axis prototype\n\n	/**\n	 * Build the stacks from top down\n	 */\n	Axis.prototype.buildStacks = function () {\n		var series = this.series,\n			reversedStacks = pick(this.options.reversedStacks, true),\n			i = series.length;\n		if (!this.isXAxis) {\n			this.usePercentage = false;\n			while (i--) {\n				series[reversedStacks ? i : series.length - i - 1].setStackedPoints();\n			}\n			// Loop up again to compute percent stack\n			if (this.usePercentage) {\n				for (i = 0; i < series.length; i++) {\n					series[i].setPercentStacks();\n				}\n			}\n		}\n	};\n\n	Axis.prototype.renderStackTotals = function () {\n		var axis = this,\n			chart = axis.chart,\n			renderer = chart.renderer,\n			stacks = axis.stacks,\n			stackKey, \n			oneStack, \n			stackCategory,\n			stackTotalGroup = axis.stackTotalGroup;\n\n		// Create a separate group for the stack total labels\n		if (!stackTotalGroup) {\n			axis.stackTotalGroup = stackTotalGroup =\n				renderer.g('stack-labels')\n					.attr({\n						visibility: VISIBLE,\n						zIndex: 6\n					})\n					.add();\n		}\n\n		// plotLeft/Top will change when y axis gets wider so we need to translate the\n		// stackTotalGroup at every render call. See bug #506 and #516\n		stackTotalGroup.translate(chart.plotLeft, chart.plotTop);\n\n		// Render each stack total\n		for (stackKey in stacks) {\n			oneStack = stacks[stackKey];\n			for (stackCategory in oneStack) {\n				oneStack[stackCategory].render(stackTotalGroup);\n			}\n		}\n	};\n\n\n	// Stacking methods defnied for Series prototype\n\n	/**\n	 * Adds series' points value to corresponding stack\n	 */\n	Series.prototype.setStackedPoints = function () {\n		if (!this.options.stacking || (this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false)) {\n			return;\n		}\n\n		var series = this,\n			xData = series.processedXData,\n			yData = series.processedYData,\n			stackedYData = [],\n			yDataLength = yData.length,\n			seriesOptions = series.options,\n			threshold = seriesOptions.threshold,\n			stackOption = seriesOptions.stack,\n			stacking = seriesOptions.stacking,\n			stackKey = series.stackKey,\n			negKey = '-' + stackKey,\n			negStacks = series.negStacks,\n			yAxis = series.yAxis,\n			stacks = yAxis.stacks,\n			oldStacks = yAxis.oldStacks,\n			isNegative,\n			stack,\n			other,\n			key,\n			pointKey,\n			i,\n			x,\n			y;\n\n		// loop over the non-null y values and read them into a local array\n		for (i = 0; i < yDataLength; i++) {\n			x = xData[i];\n			y = yData[i];\n			pointKey = series.index + ',' + i;\n\n			// Read stacked values into a stack based on the x value,\n			// the sign of y and the stack key. Stacking is also handled for null values (#739)\n			isNegative = negStacks && y < threshold;\n			key = isNegative ? negKey : stackKey;\n\n			// Create empty object for this stack if it doesn't exist yet\n			if (!stacks[key]) {\n				stacks[key] = {};\n			}\n\n			// Initialize StackItem for this x\n			if (!stacks[key][x]) {\n				if (oldStacks[key] && oldStacks[key][x]) {\n					stacks[key][x] = oldStacks[key][x];\n					stacks[key][x].total = null;\n				} else {\n					stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);\n				}\n			}\n\n			// If the StackItem doesn't exist, create it first\n			stack = stacks[key][x];\n			stack.points[pointKey] = [stack.cum || 0];\n\n			// Add value to the stack total\n			if (stacking === 'percent') {\n\n				// Percent stacked column, totals are the same for the positive and negative stacks\n				other = isNegative ? stackKey : negKey;\n				if (negStacks && stacks[other] && stacks[other][x]) {\n					other = stacks[other][x];\n					stack.total = other.total = mathMax(other.total, stack.total) + mathAbs(y) || 0;\n\n				// Percent stacked areas\n				} else {\n					stack.total = correctFloat(stack.total + (mathAbs(y) || 0));\n				}\n			} else {\n				stack.total = correctFloat(stack.total + (y || 0));\n			}\n\n			stack.cum = (stack.cum || 0) + (y || 0);\n\n			stack.points[pointKey].push(stack.cum);\n			stackedYData[i] = stack.cum;\n\n		}\n\n		if (stacking === 'percent') {\n			yAxis.usePercentage = true;\n		}\n\n		this.stackedYData = stackedYData; // To be used in getExtremes\n\n		// Reset old stacks\n		yAxis.oldStacks = {};\n	};\n\n	/**\n	 * Iterate over all stacks and compute the absolute values to percent\n	 */\n	Series.prototype.setPercentStacks = function () {\n		var series = this,\n			stackKey = series.stackKey,\n			stacks = series.yAxis.stacks,\n			processedXData = series.processedXData;\n\n		each([stackKey, '-' + stackKey], function (key) {\n			var i = processedXData.length,\n				x,\n				stack,\n				pointExtremes,\n				totalFactor;\n\n			while (i--) {\n				x = processedXData[i];\n				stack = stacks[key] && stacks[key][x];\n				pointExtremes = stack && stack.points[series.index + ',' + i];\n				if (pointExtremes) {\n					totalFactor = stack.total ? 100 / stack.total : 0;\n					pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor); // Y bottom value\n					pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor); // Y value\n					series.stackedYData[i] = pointExtremes[1];\n				}\n			}\n		});\n	};\n\n	// Extend the Chart prototype for dynamic methods\n	extend(Chart.prototype, {\n\n		/**\n		 * Add a series dynamically after  time\n		 *\n		 * @param {Object} options The config options\n		 * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.\n		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n		 *    configuration\n		 *\n		 * @return {Object} series The newly created series object\n		 */\n		addSeries: function (options, redraw, animation) {\n			var series,\n				chart = this;\n\n			if (options) {\n				redraw = pick(redraw, true); // defaults to true\n\n				fireEvent(chart, 'addSeries', { options: options }, function () {\n					series = chart.initSeries(options);\n\n					chart.isDirtyLegend = true; // the series array is out of sync with the display\n					chart.linkSeries();\n					if (redraw) {\n						chart.redraw(animation);\n					}\n				});\n			}\n\n			return series;\n		},\n\n		/**\n	     * Add an axis to the chart\n	     * @param {Object} options The axis option\n	     * @param {Boolean} isX Whether it is an X axis or a value axis\n	     */\n		addAxis: function (options, isX, redraw, animation) {\n			var key = isX ? 'xAxis' : 'yAxis',\n				chartOptions = this.options,\n				axis;\n\n			/*jslint unused: false*/\n			axis = new Axis(this, merge(options, {\n				index: this[key].length,\n				isX: isX\n			}));\n			/*jslint unused: true*/\n\n			// Push the new axis options to the chart options\n			chartOptions[key] = splat(chartOptions[key] || {});\n			chartOptions[key].push(options);\n\n			if (pick(redraw, true)) {\n				this.redraw(animation);\n			}\n		},\n\n		/**\n		 * Dim the chart and show a loading text or symbol\n		 * @param {String} str An optional text to show in the loading label instead of the default one\n		 */\n		showLoading: function (str) {\n			var chart = this,\n				options = chart.options,\n				loadingDiv = chart.loadingDiv,\n				loadingOptions = options.loading,\n				setLoadingSize = function () {\n					if (loadingDiv) {\n						css(loadingDiv, {\n							left: chart.plotLeft + PX,\n							top: chart.plotTop + PX,\n							width: chart.plotWidth + PX,\n							height: chart.plotHeight + PX\n						});\n					}\n				};\n\n			// create the layer at the first call\n			if (!loadingDiv) {\n				chart.loadingDiv = loadingDiv = createElement(DIV, {\n					className: PREFIX + 'loading'\n				}, extend(loadingOptions.style, {\n					zIndex: 10,\n					display: NONE\n				}), chart.container);\n\n				chart.loadingSpan = createElement(\n					'span',\n					null,\n					loadingOptions.labelStyle,\n					loadingDiv\n				);\n				addEvent(chart, 'redraw', setLoadingSize); // #1080\n			}\n\n			// update text\n			chart.loadingSpan.innerHTML = str || options.lang.loading;\n\n			// show it\n			if (!chart.loadingShown) {\n				css(loadingDiv, {\n					opacity: 0,\n					display: ''				\n				});\n				animate(loadingDiv, {\n					opacity: loadingOptions.style.opacity\n				}, {\n					duration: loadingOptions.showDuration || 0\n				});\n				chart.loadingShown = true;\n			}\n			setLoadingSize();\n		},\n\n		/**\n		 * Hide the loading layer\n		 */\n		hideLoading: function () {\n			var options = this.options,\n				loadingDiv = this.loadingDiv;\n\n			if (loadingDiv) {\n				animate(loadingDiv, {\n					opacity: 0\n				}, {\n					duration: options.loading.hideDuration || 100,\n					complete: function () {\n						css(loadingDiv, { display: NONE });\n					}\n				});\n			}\n			this.loadingShown = false;\n		}\n	});\n\n	// extend the Point prototype for dynamic methods\n	extend(Point.prototype, {\n		/**\n		 * Update the point with new options (typically x/y data) and optionally redraw the series.\n		 *\n		 * @param {Object} options Point options as defined in the series.data array\n		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n		 *    configuration\n		 *\n		 */\n		update: function (options, redraw, animation, runEvent) {\n			var point = this,\n				series = point.series,\n				graphic = point.graphic,\n				i,\n				chart = series.chart,\n				seriesOptions = series.options,\n				names = series.xAxis && series.xAxis.names;\n\n			redraw = pick(redraw, true);\n\n			function update() {\n\n				point.applyOptions(options);\n\n				// Update visuals\n				if (isObject(options) && !isArray(options)) {\n					// Defer the actual redraw until getAttribs has been called (#3260)\n					point.redraw = function () {\n						if (graphic) {\n							if (options && options.marker && options.marker.symbol) {\n								point.graphic = graphic.destroy();\n							} else {\n								graphic.attr(point.pointAttr[point.state || '']);\n							}\n						}\n						if (options && options.dataLabels && point.dataLabel) { // #2468\n							point.dataLabel = point.dataLabel.destroy();\n						}\n						point.redraw = null;\n					};\n				}\n\n				// record changes in the parallel arrays\n				i = point.index;\n				series.updateParallelArrays(point, i);\n				if (names && point.name) {\n					names[point.x] = point.name;\n				}\n\n				seriesOptions.data[i] = point.options;\n\n				// redraw\n				series.isDirty = series.isDirtyData = true;\n				if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320\n					chart.isDirtyBox = true;\n				}\n\n				if (chart.legend.display && seriesOptions.legendType === 'point') { // #1831, #1885, #3934\n					series.updateTotals();\n					chart.legend.clearItems();\n				}\n				if (redraw) {\n					chart.redraw(animation);\n				}\n			}\n\n			// Fire the event with a default handler of doing the update\n			if (runEvent === false) { // When called from setData\n				update();\n			} else {\n				point.firePointEvent('update', { options: options }, update);\n			}\n		},\n\n		/**\n		 * Remove a point and optionally redraw the series and if necessary the axes\n		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n		 *    configuration\n		 */\n		remove: function (redraw, animation) {\n			this.series.removePoint(inArray(this, this.series.data), redraw, animation);\n		}\n	});\n\n	// Extend the series prototype for dynamic methods\n	extend(Series.prototype, {\n		/**\n		 * Add a point dynamically after chart load time\n		 * @param {Object} options Point options as given in series.data\n		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n		 * @param {Boolean} shift If shift is true, a point is shifted off the start\n		 *    of the series as one is appended to the end.\n		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n		 *    configuration\n		 */\n		addPoint: function (options, redraw, shift, animation) {\n			var series = this,\n				seriesOptions = series.options,\n				data = series.data,\n				graph = series.graph,\n				area = series.area,\n				chart = series.chart,\n				names = series.xAxis && series.xAxis.names,\n				currentShift = (graph && graph.shift) || 0,\n				dataOptions = seriesOptions.data,\n				point,\n				isInTheMiddle,\n				xData = series.xData,\n				x,\n				i;\n\n			setAnimation(animation, chart);\n\n			// Make graph animate sideways\n			if (shift) {\n				each([graph, area, series.graphNeg, series.areaNeg], function (shape) {\n					if (shape) {\n						shape.shift = currentShift + 1;\n					}\n				});\n			}\n			if (area) {\n				area.isArea = true; // needed in animation, both with and without shift\n			}\n\n			// Optional redraw, defaults to true\n			redraw = pick(redraw, true);\n\n			// Get options and push the point to xData, yData and series.options. In series.generatePoints\n			// the Point instance will be created on demand and pushed to the series.data array.\n			point = { series: series };\n			series.pointClass.prototype.applyOptions.apply(point, [options]);\n			x = point.x;\n\n			// Get the insertion point\n			i = xData.length;\n			if (series.requireSorting && x < xData[i - 1]) {\n				isInTheMiddle = true;\n				while (i && xData[i - 1] > x) {\n					i--;\n				}\n			}\n\n			series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item\n			series.updateParallelArrays(point, i); // update it\n\n			if (names && point.name) {\n				names[x] = point.name;\n			}\n			dataOptions.splice(i, 0, options);\n\n			if (isInTheMiddle) {\n				series.data.splice(i, 0, null);\n				series.processData();\n			}\n\n			// Generate points to be added to the legend (#1329)\n			if (seriesOptions.legendType === 'point') {\n				series.generatePoints();\n			}\n\n			// Shift the first point off the parallel arrays\n			// todo: consider series.removePoint(i) method\n			if (shift) {\n				if (data[0] && data[0].remove) {\n					data[0].remove(false);\n				} else {\n					data.shift();\n					series.updateParallelArrays(point, 'shift');\n\n					dataOptions.shift();\n				}\n			}\n\n			// redraw\n			series.isDirty = true;\n			series.isDirtyData = true;\n			if (redraw) {\n				series.getAttribs(); // #1937\n				chart.redraw();\n			}\n		},\n\n		/**\n		 * Remove a point (rendered or not), by index\n		 */\n		removePoint: function (i, redraw, animation) {\n\n			var series = this,\n				data = series.data,\n				point = data[i],\n				points = series.points,\n				chart = series.chart,\n				remove = function () {\n\n					if (data.length === points.length) {\n						points.splice(i, 1);\n					}\n					data.splice(i, 1);\n					series.options.data.splice(i, 1);\n					series.updateParallelArrays(point || { series: series }, 'splice', i, 1);\n\n					if (point) {\n						point.destroy();\n					}\n\n					// redraw\n					series.isDirty = true;\n					series.isDirtyData = true;\n					if (redraw) {\n						chart.redraw();\n					}\n				};\n\n			setAnimation(animation, chart);\n			redraw = pick(redraw, true);\n\n			// Fire the event with a default handler of removing the point\n			if (point) {\n				point.firePointEvent('remove', null, remove);\n			} else {\n				remove();\n			}\n		},\n\n		/**\n		 * Remove a series and optionally redraw the chart\n		 *\n		 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call\n		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation\n		 *    configuration\n		 */\n\n		remove: function (redraw, animation) {\n			var series = this,\n				chart = series.chart;\n			redraw = pick(redraw, true);\n\n			if (!series.isRemoving) {  /* prevent triggering native event in jQuery\n					(calling the remove function from the remove event) */\n				series.isRemoving = true;\n\n				// fire the event with a default handler of removing the point\n				fireEvent(series, 'remove', null, function () {\n\n\n					// destroy elements\n					series.destroy();\n\n\n					// redraw\n					chart.isDirtyLegend = chart.isDirtyBox = true;\n					chart.linkSeries();\n\n					if (redraw) {\n						chart.redraw(animation);\n					}\n				});\n\n			}\n			series.isRemoving = false;\n		},\n\n		/**\n		 * Update the series with a new set of options\n		 */\n		update: function (newOptions, redraw) {\n			var series = this,\n				chart = this.chart,\n				// must use user options when changing type because this.options is merged\n				// in with type specific plotOptions\n				oldOptions = this.userOptions,\n				oldType = this.type,\n				proto = seriesTypes[oldType].prototype,\n				preserve = ['group', 'markerGroup', 'dataLabelsGroup'],\n				n;\n\n			// If we're changing type or zIndex, create new groups (#3380, #3404)\n			if ((newOptions.type && newOptions.type !== oldType) || newOptions.zIndex !== undefined) {\n				preserve.length = 0;\n			}\n\n			// Make sure groups are not destroyed (#3094)\n			each(preserve, function (prop) {\n				preserve[prop] = series[prop];\n				delete series[prop];\n			});\n\n			// Do the merge, with some forced options\n			newOptions = merge(oldOptions, {\n				animation: false,\n				index: this.index,\n				pointStart: this.xData[0] // when updating after addPoint\n			}, { data: this.options.data }, newOptions);\n\n			// Destroy the series and delete all properties. Reinsert all methods \n			// and properties from the new type prototype (#2270, #3719)\n			this.remove(false);\n			for (n in proto) {\n				this[n] = UNDEFINED;\n			}\n			extend(this, seriesTypes[newOptions.type || oldType].prototype);\n\n			// Re-register groups (#3094)\n			each(preserve, function (prop) {\n				series[prop] = preserve[prop];\n			});\n\n			this.init(chart, newOptions);\n			chart.linkSeries(); // Links are lost in this.remove (#3028)\n			if (pick(redraw, true)) {\n				chart.redraw(false);\n			}\n		}\n	});\n\n	// Extend the Axis.prototype for dynamic methods\n	extend(Axis.prototype, {\n\n		/**\n		 * Update the axis with a new options structure\n		 */\n		update: function (newOptions, redraw) {\n			var chart = this.chart;\n\n			newOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);\n\n			this.destroy(true);\n			this._addedPlotLB = UNDEFINED; // #1611, #2887\n\n			this.init(chart, extend(newOptions, { events: UNDEFINED }));\n\n			chart.isDirtyBox = true;\n			if (pick(redraw, true)) {\n				chart.redraw();\n			}\n		},\n\n		/**\n	     * Remove the axis from the chart\n	     */\n		remove: function (redraw) {\n			var chart = this.chart,\n				key = this.coll, // xAxis or yAxis\n				axisSeries = this.series,\n				i = axisSeries.length;\n\n			// Remove associated series (#2687)\n			while (i--) {\n				if (axisSeries[i]) {\n					axisSeries[i].remove(false);\n				}\n			}\n\n			// Remove the axis\n			erase(chart.axes, this);\n			erase(chart[key], this);\n			chart.options[key].splice(this.options.index, 1);\n			each(chart[key], function (axis, i) { // Re-index, #1706\n				axis.options.index = i;\n			});\n			this.destroy();\n			chart.isDirtyBox = true;\n\n			if (pick(redraw, true)) {\n				chart.redraw();\n			}\n		},\n\n		/**\n		 * Update the axis title by options\n		 */\n		setTitle: function (newTitleOptions, redraw) {\n			this.update({ title: newTitleOptions }, redraw);\n		},\n\n		/**\n		 * Set new axis categories and optionally redraw\n		 * @param {Array} categories\n		 * @param {Boolean} redraw\n		 */\n		setCategories: function (categories, redraw) {\n			this.update({ categories: categories }, redraw);\n		}\n\n	});\n\n\n	/**\n	 * LineSeries object\n	 */\n	var LineSeries = extendClass(Series);\n	seriesTypes.line = LineSeries;\n\n	/**\n	 * Set the default options for area\n	 */\n	defaultPlotOptions.area = merge(defaultSeriesOptions, {\n		threshold: 0\n		// trackByArea: false,\n		// lineColor: null, // overrides color, but lets fillColor be unaltered\n		// fillOpacity: 0.75,\n		// fillColor: null\n	});\n\n	/**\n	 * AreaSeries object\n	 */\n	var AreaSeries = extendClass(Series, {\n		type: 'area',\n		/**\n		 * For stacks, don't split segments on null values. Instead, draw null values with \n		 * no marker. Also insert dummy points for any X position that exists in other series\n		 * in the stack.\n		 */ \n		getSegments: function () {\n			var series = this,\n				segments = [],\n				segment = [],\n				keys = [],\n				xAxis = this.xAxis,\n				yAxis = this.yAxis,\n				stack = yAxis.stacks[this.stackKey],\n				pointMap = {},\n				plotX,\n				plotY,\n				points = this.points,\n				connectNulls = this.options.connectNulls,\n				i,\n				x;\n\n			if (this.options.stacking && !this.cropped) { // cropped causes artefacts in Stock, and perf issue\n				// Create a map where we can quickly look up the points by their X value.\n				for (i = 0; i < points.length; i++) {\n					pointMap[points[i].x] = points[i];\n				}\n\n				// Sort the keys (#1651)\n				for (x in stack) {\n					if (stack[x].total !== null) { // nulled after switching between grouping and not (#1651, #2336)\n						keys.push(+x);\n					}\n				}\n				keys.sort(function (a, b) {\n					return a - b;\n				});\n\n				each(keys, function (x) {\n					var y = 0,\n						stackPoint;\n\n					if (connectNulls && (!pointMap[x] || pointMap[x].y === null)) { // #1836\n						return;\n\n					// The point exists, push it to the segment\n					} else if (pointMap[x]) {\n						segment.push(pointMap[x]);\n\n					// There is no point for this X value in this series, so we \n					// insert a dummy point in order for the areas to be drawn\n					// correctly.\n					} else {\n\n						// Loop down the stack to find the series below this one that has\n						// a value (#1991)\n						for (i = series.index; i <= yAxis.series.length; i++) {\n							stackPoint = stack[x].points[i + ',' + x];\n							if (stackPoint) {\n								y = stackPoint[1];\n								break;\n							}\n						}\n\n						plotX = xAxis.translate(x);\n						plotY = yAxis.toPixels(y, true);\n						segment.push({ \n							y: null, \n							plotX: plotX,\n							clientX: plotX, \n							plotY: plotY, \n							yBottom: plotY,\n							onMouseOver: noop\n						});\n					}\n				});\n\n				if (segment.length) {\n					segments.push(segment);\n				}\n\n			} else {\n				Series.prototype.getSegments.call(this);\n				segments = this.segments;\n			}\n\n			this.segments = segments;\n		},\n		\n		/**\n		 * Extend the base Series getSegmentPath method by adding the path for the area.\n		 * This path is pushed to the series.areaPath property.\n		 */\n		getSegmentPath: function (segment) {\n			\n			var segmentPath = Series.prototype.getSegmentPath.call(this, segment), // call base method\n				areaSegmentPath = [].concat(segmentPath), // work on a copy for the area path\n				i,\n				options = this.options,\n				segLength = segmentPath.length,\n				translatedThreshold = this.yAxis.getThreshold(options.threshold), // #2181\n				yBottom;\n			\n			if (segLength === 3) { // for animation from 1 to two points\n				areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);\n			}\n			if (options.stacking && !this.closedStacks) {\n				\n				// Follow stack back. Todo: implement areaspline. A general solution could be to \n				// reverse the entire graphPath of the previous series, though may be hard with\n				// splines and with series with different extremes\n				for (i = segment.length - 1; i >= 0; i--) {\n\n					yBottom = pick(segment[i].yBottom, translatedThreshold);\n				\n					// step line?\n					if (i < segment.length - 1 && options.step) {\n						areaSegmentPath.push(segment[i + 1].plotX, yBottom);\n					}\n					\n					areaSegmentPath.push(segment[i].plotX, yBottom);\n				}\n\n			} else { // follow zero line back\n				this.closeSegment(areaSegmentPath, segment, translatedThreshold);\n			}\n			this.areaPath = this.areaPath.concat(areaSegmentPath);\n			return segmentPath;\n		},\n		\n		/**\n		 * Extendable method to close the segment path of an area. This is overridden in polar \n		 * charts.\n		 */\n		closeSegment: function (path, segment, translatedThreshold) {\n			path.push(\n				L,\n				segment[segment.length - 1].plotX,\n				translatedThreshold,\n				L,\n				segment[0].plotX,\n				translatedThreshold\n			);\n		},\n		\n		/**\n		 * Draw the graph and the underlying area. This method calls the Series base\n		 * function and adds the area. The areaPath is calculated in the getSegmentPath\n		 * method called from Series.prototype.drawGraph.\n		 */\n		drawGraph: function () {\n			\n			// Define or reset areaPath\n			this.areaPath = [];\n			\n			// Call the base method\n			Series.prototype.drawGraph.apply(this);\n			\n			// Define local variables\n			var series = this,\n				areaPath = this.areaPath,\n				options = this.options,\n				zones = this.zones,\n				props = [['area', this.color, options.fillColor]]; // area name, main color, fill color\n			\n			each(zones, function (threshold, i) {\n				props.push(['colorArea' + i, threshold.color || series.color, threshold.fillColor || options.fillColor]);\n			});\n			each(props, function (prop) {\n				var areaKey = prop[0],\n					area = series[areaKey];\n					\n				// Create or update the area\n				if (area) { // update\n					area.animate({ d: areaPath });\n		\n				} else { // create\n					series[areaKey] = series.chart.renderer.path(areaPath)\n						.attr({\n							fill: pick(\n								prop[2],\n								Color(prop[1]).setOpacity(pick(options.fillOpacity, 0.75)).get()\n							),\n							zIndex: 0 // #1069\n						}).add(series.group);\n				}\n			});\n		},\n\n		drawLegendSymbol: LegendSymbolMixin.drawRectangle\n	});\n\n	seriesTypes.area = AreaSeries;\n	/**\n	 * Set the default options for spline\n	 */\n	defaultPlotOptions.spline = merge(defaultSeriesOptions);\n\n	/**\n	 * SplineSeries object\n	 */\n	var SplineSeries = extendClass(Series, {\n		type: 'spline',\n\n		/**\n		 * Get the spline segment from a given point's previous neighbour to the given point\n		 */\n		getPointSpline: function (segment, point, i) {\n			var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc\n				denom = smoothing + 1,\n				plotX = point.plotX,\n				plotY = point.plotY,\n				lastPoint = segment[i - 1],\n				nextPoint = segment[i + 1],\n				leftContX,\n				leftContY,\n				rightContX,\n				rightContY,\n				ret;\n\n			// find control points\n			if (lastPoint && nextPoint) {\n			\n				var lastX = lastPoint.plotX,\n					lastY = lastPoint.plotY,\n					nextX = nextPoint.plotX,\n					nextY = nextPoint.plotY,\n					correction;\n\n				leftContX = (smoothing * plotX + lastX) / denom;\n				leftContY = (smoothing * plotY + lastY) / denom;\n				rightContX = (smoothing * plotX + nextX) / denom;\n				rightContY = (smoothing * plotY + nextY) / denom;\n\n				// have the two control points make a straight line through main point\n				correction = ((rightContY - leftContY) * (rightContX - plotX)) /\n					(rightContX - leftContX) + plotY - rightContY;\n\n				leftContY += correction;\n				rightContY += correction;\n\n				// to prevent false extremes, check that control points are between\n				// neighbouring points' y values\n				if (leftContY > lastY && leftContY > plotY) {\n					leftContY = mathMax(lastY, plotY);\n					rightContY = 2 * plotY - leftContY; // mirror of left control point\n				} else if (leftContY < lastY && leftContY < plotY) {\n					leftContY = mathMin(lastY, plotY);\n					rightContY = 2 * plotY - leftContY;\n				}\n				if (rightContY > nextY && rightContY > plotY) {\n					rightContY = mathMax(nextY, plotY);\n					leftContY = 2 * plotY - rightContY;\n				} else if (rightContY < nextY && rightContY < plotY) {\n					rightContY = mathMin(nextY, plotY);\n					leftContY = 2 * plotY - rightContY;\n				}\n\n				// record for drawing in next point\n				point.rightContX = rightContX;\n				point.rightContY = rightContY;\n\n			}\n			\n			// Visualize control points for debugging\n			/*\n			if (leftContX) {\n				this.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)\n					.attr({\n						stroke: 'red',\n						'stroke-width': 1,\n						fill: 'none'\n					})\n					.add();\n				this.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,\n					'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n					.attr({\n						stroke: 'red',\n						'stroke-width': 1\n					})\n					.add();\n				this.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)\n					.attr({\n						stroke: 'green',\n						'stroke-width': 1,\n						fill: 'none'\n					})\n					.add();\n				this.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,\n					'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n					.attr({\n						stroke: 'green',\n						'stroke-width': 1\n					})\n					.add();\n			}\n			*/\n\n			// moveTo or lineTo\n			if (!i) {\n				ret = [M, plotX, plotY];\n			} else { // curve from last point to this\n				ret = [\n					'C',\n					lastPoint.rightContX || lastPoint.plotX,\n					lastPoint.rightContY || lastPoint.plotY,\n					leftContX || plotX,\n					leftContY || plotY,\n					plotX,\n					plotY\n				];\n				lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later\n			}\n			return ret;\n		}\n	});\n	seriesTypes.spline = SplineSeries;\n\n	/**\n	 * Set the default options for areaspline\n	 */\n	defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);\n\n	/**\n	 * AreaSplineSeries object\n	 */\n	var areaProto = AreaSeries.prototype,\n		AreaSplineSeries = extendClass(SplineSeries, {\n			type: 'areaspline',\n			closedStacks: true, // instead of following the previous graph back, follow the threshold back\n			\n			// Mix in methods from the area series\n			getSegmentPath: areaProto.getSegmentPath,\n			closeSegment: areaProto.closeSegment,\n			drawGraph: areaProto.drawGraph,\n			drawLegendSymbol: LegendSymbolMixin.drawRectangle\n		});\n\n	seriesTypes.areaspline = AreaSplineSeries;\n\n	/**\n	 * Set the default options for column\n	 */\n	defaultPlotOptions.column = merge(defaultSeriesOptions, {\n		borderColor: '#FFFFFF',\n		//borderWidth: 1,\n		borderRadius: 0,\n		//colorByPoint: undefined,\n		groupPadding: 0.2,\n		//grouping: true,\n		marker: null, // point options are specified in the base options\n		pointPadding: 0.1,\n		//pointWidth: null,\n		minPointLength: 0,\n		cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes\n		pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories\n		states: {\n			hover: {\n				brightness: 0.1,\n				shadow: false,\n				halo: false\n			},\n			select: {\n				color: '#C0C0C0',\n				borderColor: '#000000',\n				shadow: false\n			}\n		},\n		dataLabels: {\n			align: null, // auto\n			verticalAlign: null, // auto\n			y: null\n		},\n		stickyTracking: false,\n		tooltip: {\n			distance: 6\n		},\n		threshold: 0\n	});\n\n	/**\n	 * ColumnSeries object\n	 */\n	var ColumnSeries = extendClass(Series, {\n		type: 'column',\n		pointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n			stroke: 'borderColor',\n			fill: 'color',\n			r: 'borderRadius'\n		},\n		cropShoulder: 0,\n		directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.\n		trackerGroups: ['group', 'dataLabelsGroup'],\n		negStacks: true, // use separate negative stacks, unlike area stacks where a negative \n			// point is substracted from previous (#1910)\n		\n		/**\n		 * Initialize the series\n		 */\n		init: function () {\n			Series.prototype.init.apply(this, arguments);\n\n			var series = this,\n				chart = series.chart;\n\n			// if the series is added dynamically, force redraw of other\n			// series affected by a new column\n			if (chart.hasRendered) {\n				each(chart.series, function (otherSeries) {\n					if (otherSeries.type === series.type) {\n						otherSeries.isDirty = true;\n					}\n				});\n			}\n		},\n\n		/**\n		 * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,\n		 * pointWidth etc. \n		 */\n		getColumnMetrics: function () {\n\n			var series = this,\n				options = series.options,\n				xAxis = series.xAxis,\n				yAxis = series.yAxis,\n				reversedXAxis = xAxis.reversed,\n				stackKey,\n				stackGroups = {},\n				columnIndex,\n				columnCount = 0;\n\n			// Get the total number of column type series.\n			// This is called on every series. Consider moving this logic to a\n			// chart.orderStacks() function and call it on init, addSeries and removeSeries\n			if (options.grouping === false) {\n				columnCount = 1;\n			} else {\n				each(series.chart.series, function (otherSeries) {\n					var otherOptions = otherSeries.options,\n						otherYAxis = otherSeries.yAxis;\n					if (otherSeries.type === series.type && otherSeries.visible &&\n							yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {  // #642, #2086\n						if (otherOptions.stacking) {\n							stackKey = otherSeries.stackKey;\n							if (stackGroups[stackKey] === UNDEFINED) {\n								stackGroups[stackKey] = columnCount++;\n							}\n							columnIndex = stackGroups[stackKey];\n						} else if (otherOptions.grouping !== false) { // #1162\n							columnIndex = columnCount++;\n						}\n						otherSeries.columnIndex = columnIndex;\n					}\n				});\n			}\n\n			var categoryWidth = mathMin(\n					mathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610\n					xAxis.len // #1535\n				),\n				groupPadding = categoryWidth * options.groupPadding,\n				groupWidth = categoryWidth - 2 * groupPadding,\n				pointOffsetWidth = groupWidth / columnCount,\n				optionPointWidth = options.pointWidth,\n				pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 :\n					pointOffsetWidth * options.pointPadding,\n				pointWidth = pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), // exact point width, used in polar charts\n				colIndex = (reversedXAxis ? \n					columnCount - (series.columnIndex || 0) : // #1251\n					series.columnIndex) || 0,\n				pointXOffset = pointPadding + (groupPadding + colIndex *\n					pointOffsetWidth - (categoryWidth / 2)) *\n					(reversedXAxis ? -1 : 1);\n\n			// Save it for reading in linked series (Error bars particularly)\n			return (series.columnMetrics = { \n				width: pointWidth, \n				offset: pointXOffset \n			});\n				\n		},\n\n		/**\n		 * Translate each point to the plot area coordinate system and find shape positions\n		 */\n		translate: function () {\n			var series = this,\n				chart = series.chart,\n				options = series.options,\n				borderWidth = series.borderWidth = pick(\n					options.borderWidth, \n					series.closestPointRange * series.xAxis.transA < 2 ? 0 : 1 // #3635\n				),\n				yAxis = series.yAxis,\n				threshold = options.threshold,\n				translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),\n				minPointLength = pick(options.minPointLength, 5),\n				metrics = series.getColumnMetrics(),\n				pointWidth = metrics.width,\n				seriesBarW = series.barW = mathMax(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width\n				pointXOffset = series.pointXOffset = metrics.offset,\n				xCrisp = -(borderWidth % 2 ? 0.5 : 0),\n				yCrisp = borderWidth % 2 ? 0.5 : 1;\n\n			if (chart.renderer.isVML && chart.inverted) {\n				yCrisp += 1;\n			}\n\n			// When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual\n			// columns to have individual sizes. When pointPadding is greater, we strive for equal-width\n			// columns (#2694).\n			if (options.pointPadding) {\n				seriesBarW = mathCeil(seriesBarW);\n			}\n\n			Series.prototype.translate.apply(series);\n\n			// Record the new values\n			each(series.points, function (point) {\n				var yBottom = pick(point.yBottom, translatedThreshold),\n					plotY = mathMin(mathMax(-999 - yBottom, point.plotY), yAxis.len + 999 + yBottom), // Don't draw too far outside plot area (#1303, #2241)\n					barX = point.plotX + pointXOffset,\n					barW = seriesBarW,\n					barY = mathMin(plotY, yBottom),\n					right,\n					bottom,\n					fromTop,\n					barH = mathMax(plotY, yBottom) - barY;\n\n				// Handle options.minPointLength\n				if (mathAbs(barH) < minPointLength) {\n					if (minPointLength) {\n						barH = minPointLength;\n						barY =\n							mathRound(mathAbs(barY - translatedThreshold) > minPointLength ? // stacked\n								yBottom - minPointLength : // keep position\n								translatedThreshold - (yAxis.translate(point.y, 0, 1, 0, 1) <= translatedThreshold ? minPointLength : 0)); // use exact yAxis.translation (#1485)\n					}\n				}\n\n				// Cache for access in polar\n				point.barX = barX;\n				point.pointWidth = pointWidth;\n\n				// Fix the tooltip on center of grouped columns (#1216, #424, #3648)\n				point.tooltipPos = chart.inverted ? \n					[yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2] : \n					[barX + barW / 2, plotY + yAxis.pos - chart.plotTop];\n\n				// Round off to obtain crisp edges and avoid overlapping with neighbours (#2694)\n				right = mathRound(barX + barW) + xCrisp;\n				barX = mathRound(barX) + xCrisp;\n				barW = right - barX;\n\n				fromTop = mathAbs(barY) < 0.5;\n				bottom = mathMin(mathRound(barY + barH) + yCrisp, 9e4); // #3575\n				barY = mathRound(barY) + yCrisp;\n				barH = bottom - barY;\n\n				// Top edges are exceptions\n				if (fromTop) {\n					barY -= 1;\n					barH += 1;\n				}\n\n				// Register shape type and arguments to be used in drawPoints\n				point.shapeType = 'rect';\n				point.shapeArgs = {\n					x: barX,\n					y: barY,\n					width: barW,\n					height: barH\n				};\n\n			});\n\n		},\n\n		getSymbol: noop,\n		\n		/**\n		 * Use a solid rectangle like the area series types\n		 */\n		drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n		\n		\n		/**\n		 * Columns have no graph\n		 */\n		drawGraph: noop,\n\n		/**\n		 * Draw the columns. For bars, the series.group is rotated, so the same coordinates\n		 * apply for columns and bars. This method is inherited by scatter series.\n		 *\n		 */\n		drawPoints: function () {\n			var series = this,\n				chart = this.chart,\n				options = series.options,\n				renderer = chart.renderer,\n				animationLimit = options.animationLimit || 250,\n				shapeArgs,\n				pointAttr;\n\n			// draw the columns\n			each(series.points, function (point) {\n				var plotY = point.plotY,\n					graphic = point.graphic,\n					borderAttr;\n\n				if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {\n					shapeArgs = point.shapeArgs;\n\n					borderAttr = defined(series.borderWidth) ? {\n						'stroke-width': series.borderWidth\n					} : {};\n\n					pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || series.pointAttr[NORMAL_STATE];\n					\n					if (graphic) { // update\n						stop(graphic);\n						graphic.attr(borderAttr)[chart.pointCount < animationLimit ? 'animate' : 'attr'](merge(shapeArgs));\n\n					} else {\n						point.graphic = graphic = renderer[point.shapeType](shapeArgs)\n							.attr(borderAttr)\n							.attr(pointAttr)\n							.add(series.group)\n							.shadow(options.shadow, null, options.stacking && !options.borderRadius);\n					}\n\n				} else if (graphic) {\n					point.graphic = graphic.destroy(); // #1269\n				}\n			});\n		},\n\n		/**\n		 * Animate the column heights one by one from zero\n		 * @param {Boolean} init Whether to initialize the animation or run it\n		 */\n		animate: function (init) {\n			var series = this,\n				yAxis = this.yAxis,\n				options = series.options,\n				inverted = this.chart.inverted,\n				attr = {},\n				translatedThreshold;\n\n			if (hasSVG) { // VML is too slow anyway\n				if (init) {\n					attr.scaleY = 0.001;\n					translatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));\n					if (inverted) {\n						attr.translateX = translatedThreshold - yAxis.len;\n					} else {\n						attr.translateY = translatedThreshold;\n					}\n					series.group.attr(attr);\n\n				} else { // run the animation\n					\n					attr.scaleY = 1;\n					attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;\n					series.group.animate(attr, series.options.animation);\n\n					// delete this function to allow it only once\n					series.animate = null;\n				}\n			}\n		},\n		\n		/**\n		 * Remove this series from the chart\n		 */\n		remove: function () {\n			var series = this,\n				chart = series.chart;\n\n			// column and bar series affects other series of the same type\n			// as they are either stacked or grouped\n			if (chart.hasRendered) {\n				each(chart.series, function (otherSeries) {\n					if (otherSeries.type === series.type) {\n						otherSeries.isDirty = true;\n					}\n				});\n			}\n\n			Series.prototype.remove.apply(series, arguments);\n		}\n	});\n	seriesTypes.column = ColumnSeries;\n	/**\n	 * Set the default options for bar\n	 */\n	defaultPlotOptions.bar = merge(defaultPlotOptions.column);\n	/**\n	 * The Bar series class\n	 */\n	var BarSeries = extendClass(ColumnSeries, {\n		type: 'bar',\n		inverted: true\n	});\n	seriesTypes.bar = BarSeries;\n\n	/**\n	 * Set the default options for scatter\n	 */\n	defaultPlotOptions.scatter = merge(defaultSeriesOptions, {\n		lineWidth: 0,\n		marker: {\n			enabled: true // Overrides auto-enabling in line series (#3647)\n		},\n		tooltip: {\n			headerFormat: '<span style=\"color:{series.color}\">\\u25CF</span> <span style=\"font-size: 10px;\"> {series.name}</span><br/>',\n			pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'\n		}\n	});\n\n	/**\n	 * The scatter series class\n	 */\n	var ScatterSeries = extendClass(Series, {\n		type: 'scatter',\n		sorted: false,\n		requireSorting: false,\n		noSharedTooltip: true,\n		trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],\n		takeOrdinalPosition: false, // #2342\n		kdDimensions: 2,\n		kdComparer: 'distR',\n		drawGraph: function () {\n			if (this.options.lineWidth) {\n				Series.prototype.drawGraph.call(this);\n			}\n		}\n	});\n\n	seriesTypes.scatter = ScatterSeries;\n\n	/**\n	 * Set the default options for pie\n	 */\n	defaultPlotOptions.pie = merge(defaultSeriesOptions, {\n		borderColor: '#FFFFFF',\n		borderWidth: 1,\n		center: [null, null],\n		clip: false,\n		colorByPoint: true, // always true for pies\n		dataLabels: {\n			// align: null,\n			// connectorWidth: 1,\n			// connectorColor: point.color,\n			// connectorPadding: 5,\n			distance: 30,\n			enabled: true,\n			formatter: function () { // #2945\n				return this.point.name;\n			},\n			// softConnector: true,\n			x: 0\n			// y: 0\n		},\n		ignoreHiddenPoint: true,\n		//innerSize: 0,\n		legendType: 'point',\n		marker: null, // point options are specified in the base options\n		size: null,\n		showInLegend: false,\n		slicedOffset: 10,\n		states: {\n			hover: {\n				brightness: 0.1,\n				shadow: false\n			}\n		},\n		stickyTracking: false,\n		tooltip: {\n			followPointer: true\n		}\n	});\n\n	/**\n	 * Extended point object for pies\n	 */\n	var PiePoint = extendClass(Point, {\n		/**\n		 * Initiate the pie slice\n		 */\n		init: function () {\n\n			Point.prototype.init.apply(this, arguments);\n\n			var point = this,\n				toggleSlice;\n\n			extend(point, {\n				visible: point.visible !== false,\n				name: pick(point.name, 'Slice')\n			});\n\n			// add event listener for select\n			toggleSlice = function (e) {\n				point.slice(e.type === 'select');\n			};\n			addEvent(point, 'select', toggleSlice);\n			addEvent(point, 'unselect', toggleSlice);\n\n			return point;\n		},\n\n		/**\n		 * Toggle the visibility of the pie slice\n		 * @param {Boolean} vis Whether to show the slice or not. If undefined, the\n		 *    visibility is toggled\n		 */\n		setVisible: function (vis) {\n			var point = this,\n				series = point.series,\n				chart = series.chart,\n				doRedraw = !series.isDirty && series.options.ignoreHiddenPoint;\n\n			// if called without an argument, toggle visibility\n			point.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;\n			series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data\n\n			// Show and hide associated elements\n			each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {\n				if (point[key]) {\n					point[key][vis ? 'show' : 'hide'](true);\n				}\n			});\n\n			if (point.legendItem) {\n				if (chart.hasRendered) {\n					series.updateTotals();\n					chart.legend.clearItems();\n					if (!doRedraw) {\n						chart.legend.render();\n					}\n				}\n				chart.legend.colorizeItem(point, vis);\n			}\n\n			// Handle ignore hidden slices\n			if (doRedraw) {\n				series.isDirty = true;\n				chart.redraw();\n			}\n		},\n\n		/**\n		 * Set or toggle whether the slice is cut out from the pie\n		 * @param {Boolean} sliced When undefined, the slice state is toggled\n		 * @param {Boolean} redraw Whether to redraw the chart. True by default.\n		 */\n		slice: function (sliced, redraw, animation) {\n			var point = this,\n				series = point.series,\n				chart = series.chart,\n				translation;\n\n			setAnimation(animation, chart);\n\n			// redraw is true by default\n			redraw = pick(redraw, true);\n\n			// if called without an argument, toggle\n			point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;\n			series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data\n\n			translation = sliced ? point.slicedTranslation : {\n				translateX: 0,\n				translateY: 0\n			};\n\n			point.graphic.animate(translation);\n			\n			if (point.shadowGroup) {\n				point.shadowGroup.animate(translation);\n			}\n\n		},\n\n		haloPath: function (size) {\n			var shapeArgs = this.shapeArgs,\n				chart = this.series.chart;\n\n			return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(chart.plotLeft + shapeArgs.x, chart.plotTop + shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {\n				innerR: this.shapeArgs.r,\n				start: shapeArgs.start,\n				end: shapeArgs.end\n			});\n		}\n	});\n\n	/**\n	 * The Pie series class\n	 */\n	var PieSeries = {\n		type: 'pie',\n		isCartesian: false,\n		pointClass: PiePoint,\n		requireSorting: false,\n		noSharedTooltip: true,\n		trackerGroups: ['group', 'dataLabelsGroup'],\n		axisTypes: [],\n		pointAttrToOptions: { // mapping between SVG attributes and the corresponding options\n			stroke: 'borderColor',\n			'stroke-width': 'borderWidth',\n			fill: 'color'\n		},\n\n		/**\n		 * Pies have one color each point\n		 */\n		getColor: noop,\n\n		/**\n		 * Animate the pies in\n		 */\n		animate: function (init) {\n			var series = this,\n				points = series.points,\n				startAngleRad = series.startAngleRad;\n\n			if (!init) {\n				each(points, function (point) {\n					var graphic = point.graphic,\n						args = point.shapeArgs;\n\n					if (graphic) {\n						// start values\n						graphic.attr({\n							r: series.center[3] / 2, // animate from inner radius (#779)\n							start: startAngleRad,\n							end: startAngleRad\n						});\n\n						// animate\n						graphic.animate({\n							r: args.r,\n							start: args.start,\n							end: args.end\n						}, series.options.animation);\n					}\n				});\n\n				// delete this function to allow it only once\n				series.animate = null;\n			}\n		},\n\n		/**\n		 * Extend the basic setData method by running processData and generatePoints immediately,\n		 * in order to access the points from the legend.\n		 */\n		setData: function (data, redraw, animation, updatePoints) {\n			Series.prototype.setData.call(this, data, false, animation, updatePoints);\n			this.processData();\n			this.generatePoints();\n			if (pick(redraw, true)) {\n				this.chart.redraw(animation);\n			} \n		},\n\n		/**\n		 * Recompute total chart sum and update percentages of points.\n		 */\n		updateTotals: function () {\n			var i,\n				total = 0,\n				points,\n				len,\n				point,\n				ignoreHiddenPoint = this.options.ignoreHiddenPoint;\n\n			// Populate local vars\n			points = this.points;\n			len = points.length;\n			\n			// Get the total sum\n			for (i = 0; i < len; i++) {\n				point = points[i];\n\n				// Disallow negative values (#1530, #3623)\n				if (point.y < 0) {\n					point.y = null;\n				}\n				\n				total += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;\n			}\n			this.total = total;\n\n			// Set each point's properties\n			for (i = 0; i < len; i++) {\n				point = points[i];\n				//point.percentage = (total <= 0 || ignoreHiddenPoint && !point.visible) ? 0 : point.y / total * 100;\n				point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;\n				point.total = total;\n			}\n		},\n\n		/**\n		 * Extend the generatePoints method by adding total and percentage properties to each point\n		 */\n		generatePoints: function () {\n			Series.prototype.generatePoints.call(this);\n			this.updateTotals();\n		},\n		\n		/**\n		 * Do translation for pie slices\n		 */\n		translate: function (positions) {\n			this.generatePoints();\n			\n			var series = this,\n				cumulative = 0,\n				precision = 1000, // issue #172\n				options = series.options,\n				slicedOffset = options.slicedOffset,\n				connectorOffset = slicedOffset + options.borderWidth,\n				start,\n				end,\n				angle,\n				startAngle = options.startAngle || 0,\n				startAngleRad = series.startAngleRad = mathPI / 180 * (startAngle - 90),\n				endAngleRad = series.endAngleRad = mathPI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),\n				circ = endAngleRad - startAngleRad, //2 * mathPI,\n				points = series.points,\n				radiusX, // the x component of the radius vector for a given point\n				radiusY,\n				labelDistance = options.dataLabels.distance,\n				ignoreHiddenPoint = options.ignoreHiddenPoint,\n				i,\n				len = points.length,\n				point;\n\n			// Get positions - either an integer or a percentage string must be given.\n			// If positions are passed as a parameter, we're in a recursive loop for adjusting\n			// space for data labels.\n			if (!positions) {\n				series.center = positions = series.getCenter();\n			}\n\n			// utility for getting the x value from a given y, used for anticollision logic in data labels\n			series.getX = function (y, left) {\n\n				angle = math.asin(mathMin((y - positions[1]) / (positions[2] / 2 + labelDistance), 1));\n\n				return positions[0] +\n					(left ? -1 : 1) *\n					(mathCos(angle) * (positions[2] / 2 + labelDistance));\n			};\n\n			// Calculate the geometry for each point\n			for (i = 0; i < len; i++) {\n				\n				point = points[i];\n				\n				// set start and end angle\n				start = startAngleRad + (cumulative * circ);\n				if (!ignoreHiddenPoint || point.visible) {\n					cumulative += point.percentage / 100;\n				}\n				end = startAngleRad + (cumulative * circ);\n\n				// set the shape\n				point.shapeType = 'arc';\n				point.shapeArgs = {\n					x: positions[0],\n					y: positions[1],\n					r: positions[2] / 2,\n					innerR: positions[3] / 2,\n					start: mathRound(start * precision) / precision,\n					end: mathRound(end * precision) / precision\n				};\n\n				// The angle must stay within -90 and 270 (#2645)\n				angle = (end + start) / 2;\n				if (angle > 1.5 * mathPI) {\n					angle -= 2 * mathPI;\n				} else if (angle < -mathPI / 2) {\n					angle += 2 * mathPI;\n				}\n\n				// Center for the sliced out slice\n				point.slicedTranslation = {\n					translateX: mathRound(mathCos(angle) * slicedOffset),\n					translateY: mathRound(mathSin(angle) * slicedOffset)\n				};\n\n				// set the anchor point for tooltips\n				radiusX = mathCos(angle) * positions[2] / 2;\n				radiusY = mathSin(angle) * positions[2] / 2;\n				point.tooltipPos = [\n					positions[0] + radiusX * 0.7,\n					positions[1] + radiusY * 0.7\n				];\n				\n				point.half = angle < -mathPI / 2 || angle > mathPI / 2 ? 1 : 0;\n				point.angle = angle;\n\n				// set the anchor point for data labels\n				connectorOffset = mathMin(connectorOffset, labelDistance / 2); // #1678\n				point.labelPos = [\n					positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector\n					positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a\n					positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie\n					positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a\n					positions[0] + radiusX, // landing point for connector\n					positions[1] + radiusY, // a/a\n					labelDistance < 0 ? // alignment\n						'center' :\n						point.half ? 'right' : 'left', // alignment\n					angle // center angle\n				];\n\n			}\n		},\n		\n		drawGraph: null,\n\n		/**\n		 * Draw the data points\n		 */\n		drawPoints: function () {\n			var series = this,\n				chart = series.chart,\n				renderer = chart.renderer,\n				groupTranslation,\n				//center,\n				graphic,\n				//group,\n				shadow = series.options.shadow,\n				shadowGroup,\n				shapeArgs;\n\n			if (shadow && !series.shadowGroup) {\n				series.shadowGroup = renderer.g('shadow')\n					.add(series.group);\n			}\n\n			// draw the slices\n			each(series.points, function (point) {\n				graphic = point.graphic;\n				shapeArgs = point.shapeArgs;\n				shadowGroup = point.shadowGroup;\n\n				// put the shadow behind all points\n				if (shadow && !shadowGroup) {\n					shadowGroup = point.shadowGroup = renderer.g('shadow')\n						.add(series.shadowGroup);\n				}\n\n				// if the point is sliced, use special translation, else use plot area traslation\n				groupTranslation = point.sliced ? point.slicedTranslation : {\n					translateX: 0,\n					translateY: 0\n				};\n\n				//group.translate(groupTranslation[0], groupTranslation[1]);\n				if (shadowGroup) {\n					shadowGroup.attr(groupTranslation);\n				}\n\n				// draw the slice\n				if (graphic) {\n					graphic.animate(extend(shapeArgs, groupTranslation));\n				} else {\n					point.graphic = graphic = renderer[point.shapeType](shapeArgs)\n						.setRadialReference(series.center)\n						.attr(\n							point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE]\n						)\n						.attr({ \n							'stroke-linejoin': 'round'\n							//zIndex: 1 // #2722 (reversed)\n						})\n						.attr(groupTranslation)\n						.add(series.group)\n						.shadow(shadow, shadowGroup);	\n				}\n\n				// detect point specific visibility (#2430)\n				if (point.visible !== undefined) {\n					point.setVisible(point.visible);\n				}\n\n			});\n\n		},\n\n\n		searchPoint: noop,\n\n		/**\n		 * Utility for sorting data labels\n		 */\n		sortByAngle: function (points, sign) {\n			points.sort(function (a, b) {\n				return a.angle !== undefined && (b.angle - a.angle) * sign;\n			});\n		},		\n\n		/**\n		 * Use a simple symbol from LegendSymbolMixin\n		 */\n		drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n		/**\n		 * Use the getCenter method from drawLegendSymbol\n		 */\n		getCenter: CenteredSeriesMixin.getCenter,\n\n		/**\n		 * Pies don't have point marker symbols\n		 */\n		getSymbol: noop\n\n	};\n	PieSeries = extendClass(Series, PieSeries);\n	seriesTypes.pie = PieSeries;\n\n	/**\n	 * Draw the data labels\n	 */\n	Series.prototype.drawDataLabels = function () {\n\n		var series = this,\n			seriesOptions = series.options,\n			cursor = seriesOptions.cursor,\n			options = seriesOptions.dataLabels,\n			points = series.points,\n			pointOptions,\n			generalOptions,\n			hasRendered = series.hasRendered || 0,\n			str,\n			dataLabelsGroup,\n			renderer = series.chart.renderer;\n\n		if (options.enabled || series._hasPointLabels) {\n\n			// Process default alignment of data labels for columns\n			if (series.dlProcessOptions) {\n				series.dlProcessOptions(options);\n			}\n\n			// Create a separate group for the data labels to avoid rotation\n			dataLabelsGroup = series.plotGroup(\n				'dataLabelsGroup',\n				'data-labels',\n				options.defer ? HIDDEN : VISIBLE,\n				options.zIndex || 6\n			);\n\n			if (pick(options.defer, true)) {\n				dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300\n				if (!hasRendered) {\n					addEvent(series, 'afterAnimate', function () {\n						if (series.visible) { // #3023, #3024\n							dataLabelsGroup.show();\n						}\n						dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({ opacity: 1 }, { duration: 200 });\n					});\n				}\n			}\n\n			// Make the labels for each point\n			generalOptions = options;\n			each(points, function (point) {\n\n				var enabled,\n					dataLabel = point.dataLabel,\n					labelConfig,\n					attr,\n					name,\n					rotation,\n					connector = point.connector,\n					isNew = true,\n					style,\n					moreStyle = {};\n\n				// Determine if each data label is enabled\n				pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps\n				enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled); // #2282\n\n\n				// If the point is outside the plot area, destroy it. #678, #820\n				if (dataLabel && !enabled) {\n					point.dataLabel = dataLabel.destroy();\n\n				// Individual labels are disabled if the are explicitly disabled\n				// in the point options, or if they fall outside the plot area.\n				} else if (enabled) {\n\n					// Create individual options structure that can be extended without\n					// affecting others\n					options = merge(generalOptions, pointOptions);\n					style = options.style;\n\n					rotation = options.rotation;\n\n					// Get the string\n					labelConfig = point.getLabelConfig();\n					str = options.format ?\n						format(options.format, labelConfig) :\n						options.formatter.call(labelConfig, options);\n\n					// Determine the color\n					style.color = pick(options.color, style.color, series.color, 'black');\n\n\n					// update existing label\n					if (dataLabel) {\n\n						if (defined(str)) {\n							dataLabel\n								.attr({\n									text: str\n								});\n							isNew = false;\n\n						} else { // #1437 - the label is shown conditionally\n							point.dataLabel = dataLabel = dataLabel.destroy();\n							if (connector) {\n								point.connector = connector.destroy();\n							}\n						}\n\n					// create new label\n					} else if (defined(str)) {\n						attr = {\n							//align: align,\n							fill: options.backgroundColor,\n							stroke: options.borderColor,\n							'stroke-width': options.borderWidth,\n							r: options.borderRadius || 0,\n							rotation: rotation,\n							padding: options.padding,\n							zIndex: 1\n						};\n						\n						// Get automated contrast color\n						if (style.color === 'contrast') {\n							moreStyle.color = options.inside || options.distance < 0 || !!seriesOptions.stacking ? \n								renderer.getContrast(point.color || series.color) : \n								'#000000';\n						}\n						if (cursor) {\n							moreStyle.cursor = cursor;\n						}\n						\n\n						// Remove unused attributes (#947)\n						for (name in attr) {\n							if (attr[name] === UNDEFINED) {\n								delete attr[name];\n							}\n						}\n\n						dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation\n							str,\n							0,\n							-999,\n							options.shape,\n							null,\n							null,\n							options.useHTML\n						)\n						.attr(attr)\n						.css(extend(style, moreStyle))\n						.add(dataLabelsGroup)\n						.shadow(options.shadow);\n\n					}\n\n					if (dataLabel) {\n						// Now the data label is created and placed at 0,0, so we need to align it\n						series.alignDataLabel(point, dataLabel, options, null, isNew);\n					}\n				}\n			});\n		}\n	};\n\n	/**\n	 * Align each individual data label\n	 */\n	Series.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {\n		var chart = this.chart,\n			inverted = chart.inverted,\n			plotX = pick(point.plotX, -999),\n			plotY = pick(point.plotY, -999),\n			bBox = dataLabel.getBBox(),\n			baseline = chart.renderer.fontMetrics(options.style.fontSize).b,\n			rotCorr, // rotation correction\n			// Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)\n			visible = this.visible && (point.series.forceDL || chart.isInsidePlot(plotX, mathRound(plotY), inverted) ||\n				(alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted))),\n			alignAttr; // the final position;\n\n		if (visible) {\n\n			// The alignment box is a singular point\n			alignTo = extend({\n				x: inverted ? chart.plotWidth - plotY : plotX,\n				y: mathRound(inverted ? chart.plotHeight - plotX : plotY),\n				width: 0,\n				height: 0\n			}, alignTo);\n\n			// Add the text size for alignment calculation\n			extend(options, {\n				width: bBox.width,\n				height: bBox.height\n			});\n\n			// Allow a hook for changing alignment in the last moment, then do the alignment\n			if (options.rotation) { // Fancy box alignment isn't supported for rotated text\n				rotCorr = chart.renderer.rotCorr(baseline, options.rotation); // #3723\n				dataLabel[isNew ? 'attr' : 'animate']({\n						x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,\n						y: alignTo.y + options.y + alignTo.height / 2\n					})\n					.attr({ // #3003\n						align: options.align\n					});\n			} else {\n				dataLabel.align(options, null, alignTo);\n				alignAttr = dataLabel.alignAttr;\n\n				// Handle justify or crop\n				if (pick(options.overflow, 'justify') === 'justify') {\n					this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);\n\n				} else if (pick(options.crop, true)) {\n					// Now check that the data label is within the plot area\n					visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);\n\n				}\n\n				// When we're using a shape, make it possible with a connector or an arrow pointing to thie point\n				if (options.shape) {\n					dataLabel.attr({\n						anchorX: point.plotX,\n						anchorY: point.plotY\n					});\n				}\n\n			}\n		}\n\n		// Show or hide based on the final aligned position\n		if (!visible) {\n			dataLabel.attr({ y: -999 });\n			dataLabel.placed = false; // don't animate back in\n		}\n\n	};\n\n	/**\n	 * If data labels fall partly outside the plot area, align them back in, in a way that\n	 * doesn't hide the point.\n	 */\n	Series.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {\n		var chart = this.chart,\n			align = options.align,\n			verticalAlign = options.verticalAlign,\n			off,\n			justified,\n			padding = dataLabel.box ? 0 : (dataLabel.padding || 0);\n\n		// Off left\n		off = alignAttr.x + padding;\n		if (off < 0) {\n			if (align === 'right') {\n				options.align = 'left';\n			} else {\n				options.x = -off;\n			}\n			justified = true;\n		}\n\n		// Off right\n		off = alignAttr.x + bBox.width - padding;\n		if (off > chart.plotWidth) {\n			if (align === 'left') {\n				options.align = 'right';\n			} else {\n				options.x = chart.plotWidth - off;\n			}\n			justified = true;\n		}\n\n		// Off top\n		off = alignAttr.y + padding;\n		if (off < 0) {\n			if (verticalAlign === 'bottom') {\n				options.verticalAlign = 'top';\n			} else {\n				options.y = -off;\n			}\n			justified = true;\n		}\n\n		// Off bottom\n		off = alignAttr.y + bBox.height - padding;\n		if (off > chart.plotHeight) {\n			if (verticalAlign === 'top') {\n				options.verticalAlign = 'bottom';\n			} else {\n				options.y = chart.plotHeight - off;\n			}\n			justified = true;\n		}\n\n		if (justified) {\n			dataLabel.placed = !isNew;\n			dataLabel.align(options, null, alignTo);\n		}\n	};\n\n	/**\n	 * Override the base drawDataLabels method by pie specific functionality\n	 */\n	if (seriesTypes.pie) {\n		seriesTypes.pie.prototype.drawDataLabels = function () {\n			var series = this,\n				data = series.data,\n				point,\n				chart = series.chart,\n				options = series.options.dataLabels,\n				connectorPadding = pick(options.connectorPadding, 10),\n				connectorWidth = pick(options.connectorWidth, 1),\n				plotWidth = chart.plotWidth,\n				plotHeight = chart.plotHeight,\n				connector,\n				connectorPath,\n				softConnector = pick(options.softConnector, true),\n				distanceOption = options.distance,\n				seriesCenter = series.center,\n				radius = seriesCenter[2] / 2,\n				centerY = seriesCenter[1],\n				outside = distanceOption > 0,\n				dataLabel,\n				dataLabelWidth,\n				labelPos,\n				labelHeight,\n				halves = [// divide the points into right and left halves for anti collision\n					[], // right\n					[]  // left\n				],\n				x,\n				y,\n				visibility,\n				rankArr,\n				i,\n				j,\n				overflow = [0, 0, 0, 0], // top, right, bottom, left\n				sort = function (a, b) {\n					return b.y - a.y;\n				};\n\n			// get out if not enabled\n			if (!series.visible || (!options.enabled && !series._hasPointLabels)) {\n				return;\n			}\n\n			// run parent method\n			Series.prototype.drawDataLabels.apply(series);\n\n			// arrange points for detection collision\n			each(data, function (point) {\n				if (point.dataLabel && point.visible) { // #407, #2510\n					halves[point.half].push(point);\n				}\n			});\n\n			/* Loop over the points in each half, starting from the top and bottom\n			 * of the pie to detect overlapping labels.\n			 */\n			i = 2;\n			while (i--) {\n\n				var slots = [],\n					slotsLength,\n					usedSlots = [],\n					points = halves[i],\n					pos,\n					bottom,\n					length = points.length,\n					slotIndex;\n\n				if (!length) {\n					continue;\n				}\n\n				// Sort by angle\n				series.sortByAngle(points, i - 0.5);\n\n				// Assume equal label heights on either hemisphere (#2630)\n				j = labelHeight = 0;\n				while (!labelHeight && points[j]) { // #1569\n					labelHeight = points[j] && points[j].dataLabel && (points[j].dataLabel.getBBox().height || 21); // 21 is for #968\n					j++;\n				}\n\n				// Only do anti-collision when we are outside the pie and have connectors (#856)\n				if (distanceOption > 0) {\n\n					// Build the slots\n					bottom = mathMin(centerY + radius + distanceOption, chart.plotHeight);\n					for (pos = mathMax(0, centerY - radius - distanceOption); pos <= bottom; pos += labelHeight) {\n						slots.push(pos);\n					}\n					slotsLength = slots.length;\n\n\n					/* Visualize the slots\n					if (!series.slotElements) {\n						series.slotElements = [];\n					}\n					if (i === 1) {\n						series.slotElements.forEach(function (elem) {\n							elem.destroy();\n						});\n						series.slotElements.length = 0;\n					}\n						\n					slots.forEach(function (pos, no) {\n						var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),\n							slotY = pos + chart.plotTop;\n						\n						if (!isNaN(slotX)) {\n							series.slotElements.push(chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)\n								.attr({\n									'stroke-width': 1,\n									stroke: 'silver',\n									fill: 'rgba(0,0,255,0.1)'\n								})\n								.add());\n							series.slotElements.push(chart.renderer.text('Slot '+ no, slotX, slotY + 4)\n								.attr({\n									fill: 'silver'\n								}).add());\n						}\n					});\n					// */\n\n					// if there are more values than available slots, remove lowest values\n					if (length > slotsLength) {\n						// create an array for sorting and ranking the points within each quarter\n						rankArr = [].concat(points);\n						rankArr.sort(sort);\n						j = length;\n						while (j--) {\n							rankArr[j].rank = j;\n						}\n						j = length;\n						while (j--) {\n							if (points[j].rank >= slotsLength) {\n								points.splice(j, 1);\n							}\n						}\n						length = points.length;\n					}\n\n					// The label goes to the nearest open slot, but not closer to the edge than\n					// the label's index.\n					for (j = 0; j < length; j++) {\n\n						point = points[j];\n						labelPos = point.labelPos;\n\n						var closest = 9999,\n							distance,\n							slotI;\n\n						// find the closest slot index\n						for (slotI = 0; slotI < slotsLength; slotI++) {\n							distance = mathAbs(slots[slotI] - labelPos[1]);\n							if (distance < closest) {\n								closest = distance;\n								slotIndex = slotI;\n							}\n						}\n\n						// if that slot index is closer to the edges of the slots, move it\n						// to the closest appropriate slot\n						if (slotIndex < j && slots[j] !== null) { // cluster at the top\n							slotIndex = j;\n						} else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom\n							slotIndex = slotsLength - length + j;\n							while (slots[slotIndex] === null) { // make sure it is not taken\n								slotIndex++;\n							}\n						} else {\n							// Slot is taken, find next free slot below. In the next run, the next slice will find the\n							// slot above these, because it is the closest one\n							while (slots[slotIndex] === null) { // make sure it is not taken\n								slotIndex++;\n							}\n						}\n\n						usedSlots.push({ i: slotIndex, y: slots[slotIndex] });\n						slots[slotIndex] = null; // mark as taken\n					}\n					// sort them in order to fill in from the top\n					usedSlots.sort(sort);\n				}\n\n				// now the used slots are sorted, fill them up sequentially\n				for (j = 0; j < length; j++) {\n\n					var slot, naturalY;\n\n					point = points[j];\n					labelPos = point.labelPos;\n					dataLabel = point.dataLabel;\n					visibility = point.visible === false ? HIDDEN : VISIBLE;\n					naturalY = labelPos[1];\n\n					if (distanceOption > 0) {\n						slot = usedSlots.pop();\n						slotIndex = slot.i;\n\n						// if the slot next to currrent slot is free, the y value is allowed\n						// to fall back to the natural position\n						y = slot.y;\n						if ((naturalY > y && slots[slotIndex + 1] !== null) ||\n								(naturalY < y &&  slots[slotIndex - 1] !== null)) {\n							y = mathMin(mathMax(0, naturalY), chart.plotHeight);\n						}\n\n					} else {\n						y = naturalY;\n					}\n\n					// get the x - use the natural x position for first and last slot, to prevent the top\n					// and botton slice connectors from touching each other on either side\n					x = options.justify ?\n						seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :\n						series.getX(y === centerY - radius - distanceOption || y === centerY + radius + distanceOption ? naturalY : y, i);\n\n\n					// Record the placement and visibility\n					dataLabel._attr = {\n						visibility: visibility,\n						align: labelPos[6]\n					};\n					dataLabel._pos = {\n						x: x + options.x +\n							({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),\n						y: y + options.y - 10 // 10 is for the baseline (label vs text)\n					};\n					dataLabel.connX = x;\n					dataLabel.connY = y;\n\n\n					// Detect overflowing data labels\n					if (this.options.size === null) {\n						dataLabelWidth = dataLabel.width;\n						// Overflow left\n						if (x - dataLabelWidth < connectorPadding) {\n							overflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);\n\n						// Overflow right\n						} else if (x + dataLabelWidth > plotWidth - connectorPadding) {\n							overflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);\n						}\n\n						// Overflow top\n						if (y - labelHeight / 2 < 0) {\n							overflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);\n\n						// Overflow left\n						} else if (y + labelHeight / 2 > plotHeight) {\n							overflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);\n						}\n					}\n				} // for each point\n			} // for each half\n\n			// Do not apply the final placement and draw the connectors until we have verified\n			// that labels are not spilling over.\n			if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {\n\n				// Place the labels in the final position\n				this.placeDataLabels();\n\n				// Draw the connectors\n				if (outside && connectorWidth) {\n					each(this.points, function (point) {\n						connector = point.connector;\n						labelPos = point.labelPos;\n						dataLabel = point.dataLabel;\n\n						if (dataLabel && dataLabel._pos) {\n							visibility = dataLabel._attr.visibility;\n							x = dataLabel.connX;\n							y = dataLabel.connY;\n							connectorPath = softConnector ? [\n								M,\n								x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n								'C',\n								x, y, // first break, next to the label\n								2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],\n								labelPos[2], labelPos[3], // second break\n								L,\n								labelPos[4], labelPos[5] // base\n							] : [\n								M,\n								x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n								L,\n								labelPos[2], labelPos[3], // second break\n								L,\n								labelPos[4], labelPos[5] // base\n							];\n\n							if (connector) {\n								connector.animate({ d: connectorPath });\n								connector.attr('visibility', visibility);\n\n							} else {\n								point.connector = connector = series.chart.renderer.path(connectorPath).attr({\n									'stroke-width': connectorWidth,\n									stroke: options.connectorColor || point.color || '#606060',\n									visibility: visibility\n									//zIndex: 0 // #2722 (reversed)\n								})\n								.add(series.dataLabelsGroup);\n							}\n						} else if (connector) {\n							point.connector = connector.destroy();\n						}\n					});\n				}\n			}\n		};\n		/**\n		 * Perform the final placement of the data labels after we have verified that they\n		 * fall within the plot area.\n		 */\n		seriesTypes.pie.prototype.placeDataLabels = function () {\n			each(this.points, function (point) {\n				var dataLabel = point.dataLabel,\n					_pos;\n\n				if (dataLabel) {\n					_pos = dataLabel._pos;\n					if (_pos) {\n						dataLabel.attr(dataLabel._attr);\n						dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);\n						dataLabel.moved = true;\n					} else if (dataLabel) {\n						dataLabel.attr({ y: -999 });\n					}\n				}\n			});\n		};\n\n		seriesTypes.pie.prototype.alignDataLabel =  noop;\n\n		/**\n		 * Verify whether the data labels are allowed to draw, or we should run more translation and data\n		 * label positioning to keep them inside the plot area. Returns true when data labels are ready\n		 * to draw.\n		 */\n		seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {\n\n			var center = this.center,\n				options = this.options,\n				centerOption = options.center,\n				minSize = options.minSize || 80,\n				newSize = minSize,\n				ret;\n\n			// Handle horizontal size and center\n			if (centerOption[0] !== null) { // Fixed center\n				newSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);\n\n			} else { // Auto center\n				newSize = mathMax(\n					center[2] - overflow[1] - overflow[3], // horizontal overflow\n					minSize\n				);\n				center[0] += (overflow[3] - overflow[1]) / 2; // horizontal center\n			}\n\n			// Handle vertical size and center\n			if (centerOption[1] !== null) { // Fixed center\n				newSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);\n\n			} else { // Auto center\n				newSize = mathMax(\n					mathMin(\n						newSize,\n						center[2] - overflow[0] - overflow[2] // vertical overflow\n					),\n					minSize\n				);\n				center[1] += (overflow[0] - overflow[2]) / 2; // vertical center\n			}\n\n			// If the size must be decreased, we need to run translate and drawDataLabels again\n			if (newSize < center[2]) {\n				center[2] = newSize;\n				this.translate(center);\n				each(this.points, function (point) {\n					if (point.dataLabel) {\n						point.dataLabel._pos = null; // reset\n					}\n				});\n\n				if (this.drawDataLabels) {\n					this.drawDataLabels();\n				}\n			// Else, return true to indicate that the pie and its labels is within the plot area\n			} else {\n				ret = true;\n			}\n			return ret;\n		};\n	}\n\n	if (seriesTypes.column) {\n\n		/**\n		 * Override the basic data label alignment by adjusting for the position of the column\n		 */\n		seriesTypes.column.prototype.alignDataLabel = function (point, dataLabel, options,  alignTo, isNew) {\n			var inverted = this.chart.inverted,\n				series = point.series,\n				dlBox = point.dlBox || point.shapeArgs, // data label box for alignment\n				below = point.below || (point.plotY > pick(this.translatedThreshold, series.yAxis.len)),\n				inside = pick(options.inside, !!this.options.stacking); // draw it inside the box?\n\n			// Align to the column itself, or the top of it\n			if (dlBox) { // Area range uses this method but not alignTo\n				alignTo = merge(dlBox);\n\n				if (inverted) {\n					alignTo = {\n						x: series.yAxis.len - alignTo.y - alignTo.height,\n						y: series.xAxis.len - alignTo.x - alignTo.width,\n						width: alignTo.height,\n						height: alignTo.width\n					};\n				}\n\n				// Compute the alignment box\n				if (!inside) {\n					if (inverted) {\n						alignTo.x += below ? 0 : alignTo.width;\n						alignTo.width = 0;\n					} else {\n						alignTo.y += below ? alignTo.height : 0;\n						alignTo.height = 0;\n					}\n				}\n			}\n\n\n			// When alignment is undefined (typically columns and bars), display the individual\n			// point below or above the point depending on the threshold\n			options.align = pick(\n				options.align,\n				!inverted || inside ? 'center' : below ? 'right' : 'left'\n			);\n			options.verticalAlign = pick(\n				options.verticalAlign,\n				inverted || inside ? 'middle' : below ? 'top' : 'bottom'\n			);\n\n			// Call the parent method\n			Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);\n		};\n	}\n\n\n\n	/**\n	 * Highcharts JS v4.1.4-modified ()\n	 * Highcharts module to hide overlapping data labels. This module is included by default in Highmaps.\n	 *\n	 * (c) 2010-2014 Torstein Honsi\n	 *\n	 * License: www.highcharts.com/license\n	 */\n\n	/*global Highcharts, HighchartsAdapter */\n	(function (H) {\n		var Chart = H.Chart,\n			each = H.each,\n			addEvent = HighchartsAdapter.addEvent;\n\n		// Collect potensial overlapping data labels. Stack labels probably don't need to be \n		// considered because they are usually accompanied by data labels that lie inside the columns.\n		Chart.prototype.callbacks.push(function (chart) {\n			function collectAndHide() {\n				var labels = [];\n\n				each(chart.series, function (series) {\n					var dlOptions = series.options.dataLabels;\n					if ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) { // #3866\n						each(series.points, function (point) { \n							if (point.dataLabel) {\n								point.dataLabel.labelrank = point.labelrank;\n								labels.push(point.dataLabel);\n							}\n						});\n					}\n				});\n				chart.hideOverlappingLabels(labels);\n			}\n\n			// Do it now ...\n			collectAndHide();\n\n			// ... and after each chart redraw\n			addEvent(chart, 'redraw', collectAndHide);\n\n		});\n\n		/**\n		 * Hide overlapping labels. Labels are moved and faded in and out on zoom to provide a smooth \n		 * visual imression.\n		 */		\n		Chart.prototype.hideOverlappingLabels = function (labels) {\n\n			var len = labels.length,\n				label,\n				i,\n				j,\n				label1,\n				label2,\n				intersectRect = function (pos1, pos2, size1, size2) {\n					return !(\n						pos2.x > pos1.x + size1.width ||\n						pos2.x + size2.width < pos1.x ||\n						pos2.y > pos1.y + size1.height ||\n						pos2.y + size2.height < pos1.y\n					);\n				};\n		\n			// Mark with initial opacity\n			for (i = 0; i < len; i++) {\n				label = labels[i];\n				if (label) {\n					label.oldOpacity = label.opacity;\n					label.newOpacity = 1;\n				}\n			}\n\n			// Detect overlapping labels\n			for (i = 0; i < len; i++) {\n				label1 = labels[i];\n\n				for (j = i + 1; j < len; ++j) {\n					label2 = labels[j];\n					if (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0 && \n							intersectRect(label1.alignAttr, label2.alignAttr, label1, label2)) {\n						(label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;\n					}\n				}\n			}\n\n			// Hide or show\n			for (i = 0; i < len; i++) {\n				label = labels[i];\n				if (label) {\n					if (label.oldOpacity !== label.newOpacity && label.placed) {\n						label.alignAttr.opacity = label.newOpacity;\n						label[label.isOld && label.newOpacity ? 'animate' : 'attr'](label.alignAttr);\n					}\n					label.isOld = true;\n				}\n			}\n		};\n\n	}(Highcharts));/**\n	 * TrackerMixin for points and graphs\n	 */\n\n	var TrackerMixin = Highcharts.TrackerMixin = {\n\n		drawTrackerPoint: function () {\n			var series = this,\n				chart = series.chart,\n				pointer = chart.pointer,\n				cursor = series.options.cursor,\n				css = cursor && { cursor: cursor },\n				onMouseOver = function (e) {\n					var target = e.target,\n					point;\n\n					while (target && !point) {\n						point = target.point;\n						target = target.parentNode;\n					}\n\n					if (point !== UNDEFINED && point !== chart.hoverPoint) { // undefined on graph in scatterchart\n						point.onMouseOver(e);\n					}\n				};\n\n			// Add reference to the point\n			each(series.points, function (point) {\n				if (point.graphic) {\n					point.graphic.element.point = point;\n				}\n				if (point.dataLabel) {\n					point.dataLabel.element.point = point;\n				}\n			});\n\n			// Add the event listeners, we need to do this only once\n			if (!series._hasTracking) {\n				each(series.trackerGroups, function (key) {\n					if (series[key]) { // we don't always have dataLabelsGroup\n						series[key]\n							.addClass(PREFIX + 'tracker')\n							.on('mouseover', onMouseOver)\n							.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })\n							.css(css);\n						if (hasTouch) {\n							series[key].on('touchstart', onMouseOver);\n						}\n					}\n				});\n				series._hasTracking = true;\n			}\n		},\n\n		/**\n		 * Draw the tracker object that sits above all data labels and markers to\n		 * track mouse events on the graph or points. For the line type charts\n		 * the tracker uses the same graphPath, but with a greater stroke width\n		 * for better control.\n		 */\n		drawTrackerGraph: function () {\n			var series = this,\n				options = series.options,\n				trackByArea = options.trackByArea,\n				trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),\n				trackerPathLength = trackerPath.length,\n				chart = series.chart,\n				pointer = chart.pointer,\n				renderer = chart.renderer,\n				snap = chart.options.tooltip.snap,\n				tracker = series.tracker,\n				cursor = options.cursor,\n				css = cursor && { cursor: cursor },\n				singlePoints = series.singlePoints,\n				singlePoint,\n				i,\n				onMouseOver = function () {\n					if (chart.hoverSeries !== series) {\n						series.onMouseOver();\n					}\n				},\n				/*\n				 * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable\n				 * IE6: 0.002\n				 * IE7: 0.002\n				 * IE8: 0.002\n				 * IE9: 0.00000000001 (unlimited)\n				 * IE10: 0.0001 (exporting only)\n				 * FF: 0.00000000001 (unlimited)\n				 * Chrome: 0.000001\n				 * Safari: 0.000001\n				 * Opera: 0.00000000001 (unlimited)\n				 */\n				TRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.0001 : 0.002) + ')';\n\n			// Extend end points. A better way would be to use round linecaps,\n			// but those are not clickable in VML.\n			if (trackerPathLength && !trackByArea) {\n				i = trackerPathLength + 1;\n				while (i--) {\n					if (trackerPath[i] === M) { // extend left side\n						trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);\n					}\n					if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side\n						trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);\n					}\n				}\n			}\n\n			// handle single points\n			for (i = 0; i < singlePoints.length; i++) {\n				singlePoint = singlePoints[i];\n				trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,\n				L, singlePoint.plotX + snap, singlePoint.plotY);\n			}\n\n			// draw the tracker\n			if (tracker) {\n				tracker.attr({ d: trackerPath });\n			} else { // create\n\n				series.tracker = renderer.path(trackerPath)\n				.attr({\n					'stroke-linejoin': 'round', // #1225\n					visibility: series.visible ? VISIBLE : HIDDEN,\n					stroke: TRACKER_FILL,\n					fill: trackByArea ? TRACKER_FILL : NONE,\n					'stroke-width' : options.lineWidth + (trackByArea ? 0 : 2 * snap),\n					zIndex: 2\n				})\n				.add(series.group);\n\n				// The tracker is added to the series group, which is clipped, but is covered\n				// by the marker group. So the marker group also needs to capture events.\n				each([series.tracker, series.markerGroup], function (tracker) {\n					tracker.addClass(PREFIX + 'tracker')\n						.on('mouseover', onMouseOver)\n						.on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })\n						.css(css);\n\n					if (hasTouch) {\n						tracker.on('touchstart', onMouseOver);\n					}\n				});\n			}\n		}\n	};\n	/* End TrackerMixin */\n\n\n	/**\n	 * Add tracking event listener to the series group, so the point graphics\n	 * themselves act as trackers\n	 */ \n\n	if (seriesTypes.column) {\n		ColumnSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;	\n	}\n\n	if (seriesTypes.pie) {\n		seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n	}\n\n	if (seriesTypes.scatter) {\n		ScatterSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n	}\n\n	/* \n	 * Extend Legend for item events \n	 */ \n	extend(Legend.prototype, {\n\n		setItemEvents: function (item, legendItem, useHTML, itemStyle, itemHiddenStyle) {\n		var legend = this;\n		// Set the events on the item group, or in case of useHTML, the item itself (#1249)\n		(useHTML ? legendItem : item.legendGroup).on('mouseover', function () {\n				item.setState(HOVER_STATE);\n				legendItem.css(legend.options.itemHoverStyle);\n			})\n			.on('mouseout', function () {\n				legendItem.css(item.visible ? itemStyle : itemHiddenStyle);\n				item.setState();\n			})\n			.on('click', function (event) {\n				var strLegendItemClick = 'legendItemClick',\n					fnLegendItemClick = function () {\n						item.setVisible();\n					};\n					\n				// Pass over the click/touch event. #4.\n				event = {\n					browserEvent: event\n				};\n\n				// click the name or symbol\n				if (item.firePointEvent) { // point\n					item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);\n				} else {\n					fireEvent(item, strLegendItemClick, event, fnLegendItemClick);\n				}\n			});\n		},\n\n		createCheckboxForItem: function (item) {\n			var legend = this;\n\n			item.checkbox = createElement('input', {\n				type: 'checkbox',\n				checked: item.selected,\n				defaultChecked: item.selected // required by IE7\n			}, legend.options.itemCheckboxStyle, legend.chart.container);\n\n			addEvent(item.checkbox, 'click', function (event) {\n				var target = event.target;\n				fireEvent(item.series || item, 'checkboxClick', { // #3712\n						checked: target.checked,\n						item: item\n					},\n					function () {\n						item.select();\n					}\n				);\n			});\n		}	\n	});\n\n	/* \n	 * Add pointer cursor to legend itemstyle in defaultOptions\n	 */\n	defaultOptions.legend.itemStyle.cursor = 'pointer';\n\n\n	/* \n	 * Extend the Chart object with interaction\n	 */\n\n	extend(Chart.prototype, {\n		/**\n		 * Display the zoom button\n		 */\n		showResetZoom: function () {\n			var chart = this,\n				lang = defaultOptions.lang,\n				btnOptions = chart.options.chart.resetZoomButton,\n				theme = btnOptions.theme,\n				states = theme.states,\n				alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';\n				\n			this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, function () { chart.zoomOut(); }, theme, states && states.hover)\n				.attr({\n					align: btnOptions.position.align,\n					title: lang.resetZoomTitle\n				})\n				.add()\n				.align(btnOptions.position, false, alignTo);\n				\n		},\n\n		/**\n		 * Zoom out to 1:1\n		 */\n		zoomOut: function () {\n			var chart = this;\n			fireEvent(chart, 'selection', { resetSelection: true }, function () { \n				chart.zoom();\n			});\n		},\n\n		/**\n		 * Zoom into a given portion of the chart given by axis coordinates\n		 * @param {Object} event\n		 */\n		zoom: function (event) {\n			var chart = this,\n				hasZoomed,\n				pointer = chart.pointer,\n				displayButton = false,\n				resetZoomButton;\n\n			// If zoom is called with no arguments, reset the axes\n			if (!event || event.resetSelection) {\n				each(chart.axes, function (axis) {\n					hasZoomed = axis.zoom();\n				});\n			} else { // else, zoom in on all axes\n				each(event.xAxis.concat(event.yAxis), function (axisData) {\n					var axis = axisData.axis,\n						isXAxis = axis.isXAxis;\n\n					// don't zoom more than minRange\n					if (pointer[isXAxis ? 'zoomX' : 'zoomY'] || pointer[isXAxis ? 'pinchX' : 'pinchY']) {\n						hasZoomed = axis.zoom(axisData.min, axisData.max);\n						if (axis.displayBtn) {\n							displayButton = true;\n						}\n					}\n				});\n			}\n			\n			// Show or hide the Reset zoom button\n			resetZoomButton = chart.resetZoomButton;\n			if (displayButton && !resetZoomButton) {\n				chart.showResetZoom();\n			} else if (!displayButton && isObject(resetZoomButton)) {\n				chart.resetZoomButton = resetZoomButton.destroy();\n			}\n			\n\n			// Redraw\n			if (hasZoomed) {\n				chart.redraw(\n					pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation\n				);\n			}\n		},\n\n		/**\n		 * Pan the chart by dragging the mouse across the pane. This function is called\n		 * on mouse move, and the distance to pan is computed from chartX compared to\n		 * the first chartX position in the dragging operation.\n		 */\n		pan: function (e, panning) {\n\n			var chart = this,\n				hoverPoints = chart.hoverPoints,\n				doRedraw;\n\n			// remove active points for shared tooltip\n			if (hoverPoints) {\n				each(hoverPoints, function (point) {\n					point.setState();\n				});\n			}\n\n			each(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps\n				var mousePos = e[isX ? 'chartX' : 'chartY'],\n					axis = chart[isX ? 'xAxis' : 'yAxis'][0],\n					startPos = chart[isX ? 'mouseDownX' : 'mouseDownY'],\n					halfPointRange = (axis.pointRange || 0) / 2,\n					extremes = axis.getExtremes(),\n					newMin = axis.toValue(startPos - mousePos, true) + halfPointRange,\n					newMax = axis.toValue(startPos + chart[isX ? 'plotWidth' : 'plotHeight'] - mousePos, true) - halfPointRange,\n					goingLeft = startPos > mousePos; // #3613\n\n				if (axis.series.length && \n						(goingLeft || newMin > mathMin(extremes.dataMin, extremes.min)) && \n						(!goingLeft || newMax < mathMax(extremes.dataMax, extremes.max))) {\n					axis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });\n					doRedraw = true;\n				}\n\n				chart[isX ? 'mouseDownX' : 'mouseDownY'] = mousePos; // set new reference for next run\n			});\n\n			if (doRedraw) {\n				chart.redraw(false);\n			}\n			css(chart.container, { cursor: 'move' });\n		}\n	});\n\n	/*\n	 * Extend the Point object with interaction\n	 */\n	extend(Point.prototype, {\n		/**\n		 * Toggle the selection status of a point\n		 * @param {Boolean} selected Whether to select or unselect the point.\n		 * @param {Boolean} accumulate Whether to add to the previous selection. By default,\n		 *		 this happens if the control key (Cmd on Mac) was pressed during clicking.\n		 */\n		select: function (selected, accumulate) {\n			var point = this,\n				series = point.series,\n				chart = series.chart;\n\n			selected = pick(selected, !point.selected);\n\n			// fire the event with the defalut handler\n			point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {\n				point.selected = point.options.selected = selected;\n				series.options.data[inArray(point, series.data)] = point.options;\n\n				point.setState(selected && SELECT_STATE);\n\n				// unselect all other points unless Ctrl or Cmd + click\n				if (!accumulate) {\n					each(chart.getSelectedPoints(), function (loopPoint) {\n						if (loopPoint.selected && loopPoint !== point) {\n							loopPoint.selected = loopPoint.options.selected = false;\n							series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;\n							loopPoint.setState(NORMAL_STATE);\n								loopPoint.firePointEvent('unselect');\n						}\n					});\n				}\n			});\n		},\n\n		/**\n		 * Runs on mouse over the point\n		 */\n		onMouseOver: function (e) {\n			var point = this,\n				series = point.series,\n				chart = series.chart,\n				tooltip = chart.tooltip,\n				hoverPoint = chart.hoverPoint;\n\n			if (chart.hoverSeries !== series) {\n				series.onMouseOver();\n			}		\n\n			// set normal state to previous series\n			if (hoverPoint && hoverPoint !== point) {\n				hoverPoint.onMouseOut();\n			}\n\n			// trigger the event\n			point.firePointEvent('mouseOver');\n\n			// update the tooltip\n			if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {\n				tooltip.refresh(point, e);\n			}\n\n			// hover this\n			point.setState(HOVER_STATE);\n			chart.hoverPoint = point;\n		},\n\n		/**\n		 * Runs on mouse out from the point\n		 */\n		onMouseOut: function () {\n			var chart = this.series.chart,\n				hoverPoints = chart.hoverPoints;\n\n			this.firePointEvent('mouseOut');\n\n			if (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887, #2240\n				this.setState();\n				chart.hoverPoint = null;\n			}\n		},\n\n		/**\n		 * Import events from the series' and point's options. Only do it on\n		 * demand, to save processing time on hovering.\n		 */\n		importEvents: function () {\n			if (!this.hasImportedEvents) {\n				var point = this,\n					options = merge(point.series.options.point, point.options),\n					events = options.events,\n					eventType;\n\n				point.events = events;\n\n				for (eventType in events) {\n					addEvent(point, eventType, events[eventType]);\n				}\n				this.hasImportedEvents = true;\n\n			}\n		},\n\n		/**\n		 * Set the point's state\n		 * @param {String} state\n		 */\n		setState: function (state, move) {\n			var point = this,\n				plotX = point.plotX,\n				plotY = point.plotY,\n				series = point.series,\n				stateOptions = series.options.states,\n				markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,\n				normalDisabled = markerOptions && !markerOptions.enabled,\n				markerStateOptions = markerOptions && markerOptions.states[state],\n				stateDisabled = markerStateOptions && markerStateOptions.enabled === false,\n				stateMarkerGraphic = series.stateMarkerGraphic,\n				pointMarker = point.marker || {},\n				chart = series.chart,\n				radius,\n				halo = series.halo,\n				haloOptions,\n				newSymbol,\n				pointAttr;\n\n			state = state || NORMAL_STATE; // empty string\n			pointAttr = point.pointAttr[state] || series.pointAttr[state];\n\n			if (\n					// already has this state\n					(state === point.state && !move) ||\n					// selected points don't respond to hover\n					(point.selected && state !== SELECT_STATE) ||\n					// series' state options is disabled\n					(stateOptions[state] && stateOptions[state].enabled === false) ||\n					// general point marker's state options is disabled\n					(state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||\n					// individual point marker's state options is disabled\n					(state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610\n\n				) {\n				return;\n			}\n\n			// apply hover styles to the existing point\n			if (point.graphic) {\n				radius = markerOptions && point.graphic.symbolName && pointAttr.r;\n				point.graphic.attr(merge(\n					pointAttr,\n					radius ? { // new symbol attributes (#507, #612)\n						x: plotX - radius,\n						y: plotY - radius,\n						width: 2 * radius,\n						height: 2 * radius\n					} : {}\n				));\n\n				// Zooming in from a range with no markers to a range with markers\n				if (stateMarkerGraphic) {\n					stateMarkerGraphic.hide();\n				}\n			} else {\n				// if a graphic is not applied to each point in the normal state, create a shared\n				// graphic for the hover state\n				if (state && markerStateOptions) {\n					radius = markerStateOptions.radius;\n					newSymbol = pointMarker.symbol || series.symbol;\n\n					// If the point has another symbol than the previous one, throw away the\n					// state marker graphic and force a new one (#1459)\n					if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {\n						stateMarkerGraphic = stateMarkerGraphic.destroy();\n					}\n\n					// Add a new state marker graphic\n					if (!stateMarkerGraphic) {\n						if (newSymbol) {\n							series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(\n								newSymbol,\n								plotX - radius,\n								plotY - radius,\n								2 * radius,\n								2 * radius\n							)\n							.attr(pointAttr)\n							.add(series.markerGroup);\n							stateMarkerGraphic.currentSymbol = newSymbol;\n						}\n\n					// Move the existing graphic\n					} else {\n						stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054\n							x: plotX - radius,\n							y: plotY - radius\n						});\n					}\n				}\n\n				if (stateMarkerGraphic) {\n					stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450\n				}\n			}\n\n			// Show me your halo\n			haloOptions = stateOptions[state] && stateOptions[state].halo;\n			if (haloOptions && haloOptions.size) {\n				if (!halo) {\n					series.halo = halo = chart.renderer.path()\n						.add(chart.seriesGroup);\n				}\n				halo.attr(extend({\n					fill: Color(point.color || series.color).setOpacity(haloOptions.opacity).get()\n				}, haloOptions.attributes))[move ? 'animate' : 'attr']({\n					d: point.haloPath(haloOptions.size)\n				});\n			} else if (halo) {\n				halo.attr({ d: [] });\n			}\n\n			point.state = state;\n		},\n\n		haloPath: function (size) {\n			var series = this.series,\n				chart = series.chart,\n				plotBox = series.getPlotBox(),\n				inverted = chart.inverted;\n\n			return chart.renderer.symbols.circle(\n				plotBox.translateX + (inverted ? series.yAxis.len - this.plotY : this.plotX) - size, \n				plotBox.translateY + (inverted ? series.xAxis.len - this.plotX : this.plotY) - size, \n				size * 2, \n				size * 2\n			);\n		}\n	});\n\n	/*\n	 * Extend the Series object with interaction\n	 */\n\n	extend(Series.prototype, {\n		/**\n		 * Series mouse over handler\n		 */\n		onMouseOver: function () {\n			var series = this,\n				chart = series.chart,\n				hoverSeries = chart.hoverSeries;\n\n			// set normal state to previous series\n			if (hoverSeries && hoverSeries !== series) {\n				hoverSeries.onMouseOut();\n			}\n\n			// trigger the event, but to save processing time,\n			// only if defined\n			if (series.options.events.mouseOver) {\n				fireEvent(series, 'mouseOver');\n			}\n\n			// hover this\n			series.setState(HOVER_STATE);\n			chart.hoverSeries = series;\n		},\n\n		/**\n		 * Series mouse out handler\n		 */\n		onMouseOut: function () {\n			// trigger the event only if listeners exist\n			var series = this,\n				options = series.options,\n				chart = series.chart,\n				tooltip = chart.tooltip,\n				hoverPoint = chart.hoverPoint;\n\n			// trigger mouse out on the point, which must be in this series\n			if (hoverPoint) {\n				hoverPoint.onMouseOut();\n			}\n\n			// fire the mouse out event\n			if (series && options.events.mouseOut) {\n				fireEvent(series, 'mouseOut');\n			}\n\n\n			// hide the tooltip\n			if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {\n				tooltip.hide();\n			}\n\n			// set normal state\n			series.setState();\n			chart.hoverSeries = null;\n		},\n\n		/**\n		 * Set the state of the graph\n		 */\n		setState: function (state) {\n			var series = this,\n				options = series.options,\n				graph = series.graph,\n				graphNeg = series.graphNeg,\n				stateOptions = options.states,\n				lineWidth = options.lineWidth,\n				attribs;\n\n			state = state || NORMAL_STATE;\n\n			if (series.state !== state) {\n				series.state = state;\n\n				if (stateOptions[state] && stateOptions[state].enabled === false) {\n					return;\n				}\n\n				if (state) {\n					lineWidth = (stateOptions[state].lineWidth || lineWidth) + (stateOptions[state].lineWidthPlus || 0);\n				}\n\n				if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML\n					attribs = {\n						'stroke-width': lineWidth\n					};\n					// use attr because animate will cause any other animation on the graph to stop\n					graph.attr(attribs);\n					if (graphNeg) {\n						graphNeg.attr(attribs);\n					}\n				}\n			}\n		},\n\n		/**\n		 * Set the visibility of the graph\n		 *\n		 * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,\n		 *				the visibility is toggled.\n		 */\n		setVisible: function (vis, redraw) {\n			var series = this,\n				chart = series.chart,\n				legendItem = series.legendItem,\n				showOrHide,\n				ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,\n				oldVisibility = series.visible;\n\n			// if called without an argument, toggle visibility\n			series.visible = vis = series.userOptions.visible = vis === UNDEFINED ? !oldVisibility : vis;\n			showOrHide = vis ? 'show' : 'hide';\n\n			// show or hide elements\n			each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker'], function (key) {\n				if (series[key]) {\n					series[key][showOrHide]();\n				}\n			});\n\n\n			// hide tooltip (#1361)\n			if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {\n				series.onMouseOut();\n			}\n\n\n			if (legendItem) {\n				chart.legend.colorizeItem(series, vis);\n			}\n\n\n			// rescale or adapt to resized chart\n			series.isDirty = true;\n			// in a stack, all other series are affected\n			if (series.options.stacking) {\n				each(chart.series, function (otherSeries) {\n					if (otherSeries.options.stacking && otherSeries.visible) {\n						otherSeries.isDirty = true;\n					}\n				});\n			}\n\n			// show or hide linked series\n			each(series.linkedSeries, function (otherSeries) {\n				otherSeries.setVisible(vis, false);\n			});\n\n			if (ignoreHiddenSeries) {\n				chart.isDirtyBox = true;\n			}\n			if (redraw !== false) {\n				chart.redraw();\n			}\n\n			fireEvent(series, showOrHide);\n		},\n\n		/**\n		 * Show the graph\n		 */\n		show: function () {\n			this.setVisible(true);\n		},\n\n		/**\n		 * Hide the graph\n		 */\n		hide: function () {\n			this.setVisible(false);\n		},\n\n\n		/**\n		 * Set the selected state of the graph\n		 *\n		 * @param selected {Boolean} True to select the series, false to unselect. If\n		 *				UNDEFINED, the selection state is toggled.\n		 */\n		select: function (selected) {\n			var series = this;\n			// if called without an argument, toggle\n			series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;\n\n			if (series.checkbox) {\n				series.checkbox.checked = selected;\n			}\n\n			fireEvent(series, selected ? 'select' : 'unselect');\n		},\n\n		drawTracker: TrackerMixin.drawTrackerGraph\n	});\n	// global variables\n	extend(Highcharts, {\n		\n		// Constructors\n		Color: Color,\n		Point: Point,\n		Tick: Tick,	\n		Renderer: Renderer,\n		SVGElement: SVGElement,\n		SVGRenderer: SVGRenderer,\n		\n		// Various\n		arrayMin: arrayMin,\n		arrayMax: arrayMax,\n		charts: charts,\n		dateFormat: dateFormat,\n		error: error,\n		format: format,\n		pathAnim: pathAnim,\n		getOptions: getOptions,\n		hasBidiBug: hasBidiBug,\n		isTouchDevice: isTouchDevice,\n		setOptions: setOptions,\n		addEvent: addEvent,\n		removeEvent: removeEvent,\n		createElement: createElement,\n		discardElement: discardElement,\n		css: css,\n		each: each,\n		map: map,\n		merge: merge,\n		splat: splat,\n		extendClass: extendClass,\n		pInt: pInt,\n		svg: hasSVG,\n		canvas: useCanVG,\n		vml: !hasSVG && !useCanVG,\n		product: PRODUCT,\n		version: VERSION\n	});\n\n	}());\n\n\n	/*** EXPORTS FROM exports-loader ***/\n	module.exports = Highcharts\n\n/***/ }\n/******/ ])\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-highcharts/index.js\n ** module id = 121\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-highcharts/index.js?");
},/*!***************************!*\
  !*** ./~/react/addons.js ***!
  \***************************/
function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(/*! ./lib/ReactWithAddons */ 168);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/addons.js\n ** module id = 122\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/addons.js?")},/*!***********************************************!*\
  !*** ./~/react/lib/BeforeInputEventPlugin.js ***!
  \***********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015 Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule BeforeInputEventPlugin\n * @typechecks static-only\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(/*! ./EventConstants */ 7);\nvar EventPropagators = __webpack_require__(/*! ./EventPropagators */ 31);\nvar ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ 6);\nvar FallbackCompositionState = __webpack_require__(/*! ./FallbackCompositionState */ 132);\nvar SyntheticCompositionEvent = __webpack_require__(/*! ./SyntheticCompositionEvent */ 174);\nvar SyntheticInputEvent = __webpack_require__(/*! ./SyntheticInputEvent */ 177);\n\nvar keyOf = __webpack_require__(/*! ./keyOf */ 11);\n\nvar END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\nvar START_KEYCODE = 229;\n\nvar canUseCompositionEvent = (\n  ExecutionEnvironment.canUseDOM &&\n  'CompositionEvent' in window\n);\n\nvar documentMode = null;\nif (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {\n  documentMode = document.documentMode;\n}\n\n// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent = (\n  ExecutionEnvironment.canUseDOM &&\n  'TextEvent' in window &&\n  !documentMode &&\n  !isPresto()\n);\n\n// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData = (\n  ExecutionEnvironment.canUseDOM &&\n  (\n    (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11)\n  )\n);\n\n/**\n * Opera <= 12 includes TextEvent in window, but does not fire\n * text input events. Rely on keypress instead.\n */\nfunction isPresto() {\n  var opera = window.opera;\n  return (\n    typeof opera === 'object' &&\n    typeof opera.version === 'function' &&\n    parseInt(opera.version(), 10) <= 12\n  );\n}\n\nvar SPACEBAR_CODE = 32;\nvar SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\n// Events and their corresponding property names.\nvar eventTypes = {\n  beforeInput: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onBeforeInput: null}),\n      captured: keyOf({onBeforeInputCapture: null})\n    },\n    dependencies: [\n      topLevelTypes.topCompositionEnd,\n      topLevelTypes.topKeyPress,\n      topLevelTypes.topTextInput,\n      topLevelTypes.topPaste\n    ]\n  },\n  compositionEnd: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onCompositionEnd: null}),\n      captured: keyOf({onCompositionEndCapture: null})\n    },\n    dependencies: [\n      topLevelTypes.topBlur,\n      topLevelTypes.topCompositionEnd,\n      topLevelTypes.topKeyDown,\n      topLevelTypes.topKeyPress,\n      topLevelTypes.topKeyUp,\n      topLevelTypes.topMouseDown\n    ]\n  },\n  compositionStart: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onCompositionStart: null}),\n      captured: keyOf({onCompositionStartCapture: null})\n    },\n    dependencies: [\n      topLevelTypes.topBlur,\n      topLevelTypes.topCompositionStart,\n      topLevelTypes.topKeyDown,\n      topLevelTypes.topKeyPress,\n      topLevelTypes.topKeyUp,\n      topLevelTypes.topMouseDown\n    ]\n  },\n  compositionUpdate: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onCompositionUpdate: null}),\n      captured: keyOf({onCompositionUpdateCapture: null})\n    },\n    dependencies: [\n      topLevelTypes.topBlur,\n      topLevelTypes.topCompositionUpdate,\n      topLevelTypes.topKeyDown,\n      topLevelTypes.topKeyPress,\n      topLevelTypes.topKeyUp,\n      topLevelTypes.topMouseDown\n    ]\n  }\n};\n\n// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress = false;\n\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\nfunction isKeypressCommand(nativeEvent) {\n  return (\n    (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\n    // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n    !(nativeEvent.ctrlKey && nativeEvent.altKey)\n  );\n}\n\n\n/**\n * Translate native top level events into event types.\n *\n * @param {string} topLevelType\n * @return {object}\n */\nfunction getCompositionEventType(topLevelType) {\n  switch (topLevelType) {\n    case topLevelTypes.topCompositionStart:\n      return eventTypes.compositionStart;\n    case topLevelTypes.topCompositionEnd:\n      return eventTypes.compositionEnd;\n    case topLevelTypes.topCompositionUpdate:\n      return eventTypes.compositionUpdate;\n  }\n}\n\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionStart(topLevelType, nativeEvent) {\n  return (\n    topLevelType === topLevelTypes.topKeyDown &&\n    nativeEvent.keyCode === START_KEYCODE\n  );\n}\n\n/**\n * Does our fallback mode think that this event is the end of composition?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionEnd(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case topLevelTypes.topKeyUp:\n      // Command keys insert or clear IME input.\n      return (END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1);\n    case topLevelTypes.topKeyDown:\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return (nativeEvent.keyCode !== START_KEYCODE);\n    case topLevelTypes.topKeyPress:\n    case topLevelTypes.topMouseDown:\n    case topLevelTypes.topBlur:\n      // Events are not possible without cancelling IME.\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */\nfunction getDataFromCustomEvent(nativeEvent) {\n  var detail = nativeEvent.detail;\n  if (typeof detail === 'object' && 'data' in detail) {\n    return detail.data;\n  }\n  return null;\n}\n\n// Track the current IME composition fallback object, if any.\nvar currentComposition = null;\n\n/**\n * @param {string} topLevelType Record from `EventConstants`.\n * @param {DOMEventTarget} topLevelTarget The listening component root node.\n * @param {string} topLevelTargetID ID of `topLevelTarget`.\n * @param {object} nativeEvent Native browser event.\n * @return {?object} A SyntheticCompositionEvent.\n */\nfunction extractCompositionEvent(\n  topLevelType,\n  topLevelTarget,\n  topLevelTargetID,\n  nativeEvent\n) {\n  var eventType;\n  var fallbackData;\n\n  if (canUseCompositionEvent) {\n    eventType = getCompositionEventType(topLevelType);\n  } else if (!currentComposition) {\n    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {\n      eventType = eventTypes.compositionStart;\n    }\n  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n    eventType = eventTypes.compositionEnd;\n  }\n\n  if (!eventType) {\n    return null;\n  }\n\n  if (useFallbackCompositionData) {\n    // The current composition is stored statically and must not be\n    // overwritten while composition continues.\n    if (!currentComposition && eventType === eventTypes.compositionStart) {\n      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);\n    } else if (eventType === eventTypes.compositionEnd) {\n      if (currentComposition) {\n        fallbackData = currentComposition.getData();\n      }\n    }\n  }\n\n  var event = SyntheticCompositionEvent.getPooled(\n    eventType,\n    topLevelTargetID,\n    nativeEvent\n  );\n\n  if (fallbackData) {\n    // Inject data generated from fallback path into the synthetic event.\n    // This matches the property of native CompositionEventInterface.\n    event.data = fallbackData;\n  } else {\n    var customData = getDataFromCustomEvent(nativeEvent);\n    if (customData !== null) {\n      event.data = customData;\n    }\n  }\n\n  EventPropagators.accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * @param {string} topLevelType Record from `EventConstants`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The string corresponding to this `beforeInput` event.\n */\nfunction getNativeBeforeInputChars(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case topLevelTypes.topCompositionEnd:\n      return getDataFromCustomEvent(nativeEvent);\n    case topLevelTypes.topKeyPress:\n      /**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */\n      var which = nativeEvent.which;\n      if (which !== SPACEBAR_CODE) {\n        return null;\n      }\n\n      hasSpaceKeypress = true;\n      return SPACEBAR_CHAR;\n\n    case topLevelTypes.topTextInput:\n      // Record the characters to be added to the DOM.\n      var chars = nativeEvent.data;\n\n      // If it's a spacebar character, assume that we have already handled\n      // it at the keypress level and bail immediately. Android Chrome\n      // doesn't give us keycodes, so we need to blacklist it.\n      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n        return null;\n      }\n\n      return chars;\n\n    default:\n      // For other native event types, do nothing.\n      return null;\n  }\n}\n\n/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n *\n * @param {string} topLevelType Record from `EventConstants`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The fallback string for this `beforeInput` event.\n */\nfunction getFallbackBeforeInputChars(topLevelType, nativeEvent) {\n  // If we are currently composing (IME) and using a fallback to do so,\n  // try to extract the composed characters from the fallback object.\n  if (currentComposition) {\n    if (\n      topLevelType === topLevelTypes.topCompositionEnd ||\n      isFallbackCompositionEnd(topLevelType, nativeEvent)\n    ) {\n      var chars = currentComposition.getData();\n      FallbackCompositionState.release(currentComposition);\n      currentComposition = null;\n      return chars;\n    }\n    return null;\n  }\n\n  switch (topLevelType) {\n    case topLevelTypes.topPaste:\n      // If a paste event occurs after a keypress, throw out the input\n      // chars. Paste events should not lead to BeforeInput events.\n      return null;\n    case topLevelTypes.topKeyPress:\n      /**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */\n      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {\n        return String.fromCharCode(nativeEvent.which);\n      }\n      return null;\n    case topLevelTypes.topCompositionEnd:\n      return useFallbackCompositionData ? null : nativeEvent.data;\n    default:\n      return null;\n  }\n}\n\n/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @param {string} topLevelType Record from `EventConstants`.\n * @param {DOMEventTarget} topLevelTarget The listening component root node.\n * @param {string} topLevelTargetID ID of `topLevelTarget`.\n * @param {object} nativeEvent Native browser event.\n * @return {?object} A SyntheticInputEvent.\n */\nfunction extractBeforeInputEvent(\n  topLevelType,\n  topLevelTarget,\n  topLevelTargetID,\n  nativeEvent\n) {\n  var chars;\n\n  if (canUseTextInputEvent) {\n    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);\n  } else {\n    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);\n  }\n\n  // If no characters are being inserted, no BeforeInput event should\n  // be fired.\n  if (!chars) {\n    return null;\n  }\n\n  var event = SyntheticInputEvent.getPooled(\n    eventTypes.beforeInput,\n    topLevelTargetID,\n    nativeEvent\n  );\n\n  event.data = chars;\n  EventPropagators.accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */\nvar BeforeInputEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n    topLevelType,\n    topLevelTarget,\n    topLevelTargetID,\n    nativeEvent\n  ) {\n    return [\n      extractCompositionEvent(\n        topLevelType,\n        topLevelTarget,\n        topLevelTargetID,\n        nativeEvent\n      ),\n      extractBeforeInputEvent(\n        topLevelType,\n        topLevelTarget,\n        topLevelTargetID,\n        nativeEvent\n      )\n    ];\n  }\n};\n\nmodule.exports = BeforeInputEventPlugin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/BeforeInputEventPlugin.js\n ** module id = 123\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/BeforeInputEventPlugin.js?")},/*!********************************!*\
  !*** ./~/react/lib/CSSCore.js ***!
  \********************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule CSSCore\n * @typechecks\n */\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\n/**\n * The CSSCore module specifies the API (and implements most of the methods)\n * that should be used when dealing with the display of elements (via their\n * CSS classes and visibility on screen. It is an API focused on mutating the\n * display and not reading it as no logical state should be encoded in the\n * display of elements.\n */\n\nvar CSSCore = {\n\n  /**\n   * Adds the class passed in to the element if it doesn't already have it.\n   *\n   * @param {DOMElement} element the element to set the class on\n   * @param {string} className the CSS className\n   * @return {DOMElement} the element passed in\n   */\n  addClass: function(element, className) {\n    (false ? invariant(\n      !/\\s/.test(className),\n      'CSSCore.addClass takes only a single class name. \"%s\" contains ' +\n      'multiple classes.', className\n    ) : invariant(!/\\s/.test(className)));\n\n    if (className) {\n      if (element.classList) {\n        element.classList.add(className);\n      } else if (!CSSCore.hasClass(element, className)) {\n        element.className = element.className + ' ' + className;\n      }\n    }\n    return element;\n  },\n\n  /**\n   * Removes the class passed in from the element\n   *\n   * @param {DOMElement} element the element to set the class on\n   * @param {string} className the CSS className\n   * @return {DOMElement} the element passed in\n   */\n  removeClass: function(element, className) {\n    (false ? invariant(\n      !/\\s/.test(className),\n      'CSSCore.removeClass takes only a single class name. \"%s\" contains ' +\n      'multiple classes.', className\n    ) : invariant(!/\\s/.test(className)));\n\n    if (className) {\n      if (element.classList) {\n        element.classList.remove(className);\n      } else if (CSSCore.hasClass(element, className)) {\n        element.className = element.className\n          .replace(new RegExp('(^|\\\\s)' + className + '(?:\\\\s|$)', 'g'), '$1')\n          .replace(/\\s+/g, ' ') // multiple spaces to one\n          .replace(/^\\s*|\\s*$/g, ''); // trim the ends\n      }\n    }\n    return element;\n  },\n\n  /**\n   * Helper to add or remove a class from an element based on a condition.\n   *\n   * @param {DOMElement} element the element to set the class on\n   * @param {string} className the CSS className\n   * @param {*} bool condition to whether to add or remove the class\n   * @return {DOMElement} the element passed in\n   */\n  conditionClass: function(element, className, bool) {\n    return (bool ? CSSCore.addClass : CSSCore.removeClass)(element, className);\n  },\n\n  /**\n   * Tests whether the element has the class specified.\n   *\n   * @param {DOMNode|DOMWindow} element the element to set the class on\n   * @param {string} className the CSS className\n   * @return {boolean} true if the element has the class, false if not\n   */\n  hasClass: function(element, className) {\n    (false ? invariant(\n      !/\\s/.test(className),\n      'CSS.hasClass takes only a single class name.'\n    ) : invariant(!/\\s/.test(className)));\n    if (element.classList) {\n      return !!className && element.classList.contains(className);\n    }\n    return (' ' + element.className + ' ').indexOf(' ' + className + ' ') > -1;\n  }\n\n};\n\nmodule.exports = CSSCore;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/CSSCore.js\n ** module id = 124\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/CSSCore.js?")},/*!******************************************!*\
  !*** ./~/react/lib/ChangeEventPlugin.js ***!
  \******************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ChangeEventPlugin\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(/*! ./EventConstants */ 7);\nvar EventPluginHub = __webpack_require__(/*! ./EventPluginHub */ 30);\nvar EventPropagators = __webpack_require__(/*! ./EventPropagators */ 31);\nvar ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ 6);\nvar ReactUpdates = __webpack_require__(/*! ./ReactUpdates */ 9);\nvar SyntheticEvent = __webpack_require__(/*! ./SyntheticEvent */ 18);\n\nvar isEventSupported = __webpack_require__(/*! ./isEventSupported */ 63);\nvar isTextInputElement = __webpack_require__(/*! ./isTextInputElement */ 95);\nvar keyOf = __webpack_require__(/*! ./keyOf */ 11);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\nvar eventTypes = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onChange: null}),\n      captured: keyOf({onChangeCapture: null})\n    },\n    dependencies: [\n      topLevelTypes.topBlur,\n      topLevelTypes.topChange,\n      topLevelTypes.topClick,\n      topLevelTypes.topFocus,\n      topLevelTypes.topInput,\n      topLevelTypes.topKeyDown,\n      topLevelTypes.topKeyUp,\n      topLevelTypes.topSelectionChange\n    ]\n  }\n};\n\n/**\n * For IE shims\n */\nvar activeElement = null;\nvar activeElementID = null;\nvar activeElementValue = null;\nvar activeElementValueProp = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  return (\n    elem.nodeName === 'SELECT' ||\n    (elem.nodeName === 'INPUT' && elem.type === 'file')\n  );\n}\n\nvar doesChangeEventBubble = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // See `handleChange` comment below\n  doesChangeEventBubble = isEventSupported('change') && (\n    (!('documentMode' in document) || document.documentMode > 8)\n  );\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = SyntheticEvent.getPooled(\n    eventTypes.change,\n    activeElementID,\n    nativeEvent\n  );\n  EventPropagators.accumulateTwoPhaseDispatches(event);\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  ReactUpdates.batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  EventPluginHub.enqueueEvents(event);\n  EventPluginHub.processEventQueue();\n}\n\nfunction startWatchingForChangeEventIE8(target, targetID) {\n  activeElement = target;\n  activeElementID = targetID;\n  activeElement.attachEvent('onchange', manualDispatchChangeEvent);\n}\n\nfunction stopWatchingForChangeEventIE8() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onchange', manualDispatchChangeEvent);\n  activeElement = null;\n  activeElementID = null;\n}\n\nfunction getTargetIDForChangeEvent(\n    topLevelType,\n    topLevelTarget,\n    topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topChange) {\n    return topLevelTargetID;\n  }\n}\nfunction handleEventsForChangeEventIE8(\n    topLevelType,\n    topLevelTarget,\n    topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topFocus) {\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForChangeEventIE8();\n    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);\n  } else if (topLevelType === topLevelTypes.topBlur) {\n    stopWatchingForChangeEventIE8();\n  }\n}\n\n\n/**\n * SECTION: handle `input` event\n */\nvar isInputEventSupported = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events\n  isInputEventSupported = isEventSupported('input') && (\n    (!('documentMode' in document) || document.documentMode > 9)\n  );\n}\n\n/**\n * (For old IE.) Replacement getter/setter for the `value` property that gets\n * set on the active element.\n */\nvar newValueProp =  {\n  get: function() {\n    return activeElementValueProp.get.call(this);\n  },\n  set: function(val) {\n    // Cast to a string so we can do equality checks.\n    activeElementValue = '' + val;\n    activeElementValueProp.set.call(this, val);\n  }\n};\n\n/**\n * (For old IE.) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetID) {\n  activeElement = target;\n  activeElementID = targetID;\n  activeElementValue = target.value;\n  activeElementValueProp = Object.getOwnPropertyDescriptor(\n    target.constructor.prototype,\n    'value'\n  );\n\n  Object.defineProperty(activeElement, 'value', newValueProp);\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n\n/**\n * (For old IE.) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n\n  // delete restores the original property definition\n  delete activeElement.value;\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n\n  activeElement = null;\n  activeElementID = null;\n  activeElementValue = null;\n  activeElementValueProp = null;\n}\n\n/**\n * (For old IE.) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  var value = nativeEvent.srcElement.value;\n  if (value === activeElementValue) {\n    return;\n  }\n  activeElementValue = value;\n\n  manualDispatchChangeEvent(nativeEvent);\n}\n\n/**\n * If a `change` event should be fired, returns the target's ID.\n */\nfunction getTargetIDForInputEvent(\n    topLevelType,\n    topLevelTarget,\n    topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topInput) {\n    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly\n    // what we want so fall through here and trigger an abstract event\n    return topLevelTargetID;\n  }\n}\n\n// For IE8 and IE9.\nfunction handleEventsForInputEventIE(\n    topLevelType,\n    topLevelTarget,\n    topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topFocus) {\n    // In IE8, we can capture almost all .value changes by adding a\n    // propertychange handler and looking for events with propertyName\n    // equal to 'value'\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(topLevelTarget, topLevelTargetID);\n  } else if (topLevelType === topLevelTypes.topBlur) {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetIDForInputEventIE(\n    topLevelType,\n    topLevelTarget,\n    topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topSelectionChange ||\n      topLevelType === topLevelTypes.topKeyUp ||\n      topLevelType === topLevelTypes.topKeyDown) {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    if (activeElement && activeElement.value !== activeElementValue) {\n      activeElementValue = activeElement.value;\n      return activeElementID;\n    }\n  }\n}\n\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  return (\n    elem.nodeName === 'INPUT' &&\n    (elem.type === 'checkbox' || elem.type === 'radio')\n  );\n}\n\nfunction getTargetIDForClickEvent(\n    topLevelType,\n    topLevelTarget,\n    topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topClick) {\n    return topLevelTargetID;\n  }\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nvar ChangeEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n\n    var getTargetIDFunc, handleEventFunc;\n    if (shouldUseChangeEvent(topLevelTarget)) {\n      if (doesChangeEventBubble) {\n        getTargetIDFunc = getTargetIDForChangeEvent;\n      } else {\n        handleEventFunc = handleEventsForChangeEventIE8;\n      }\n    } else if (isTextInputElement(topLevelTarget)) {\n      if (isInputEventSupported) {\n        getTargetIDFunc = getTargetIDForInputEvent;\n      } else {\n        getTargetIDFunc = getTargetIDForInputEventIE;\n        handleEventFunc = handleEventsForInputEventIE;\n      }\n    } else if (shouldUseClickEvent(topLevelTarget)) {\n      getTargetIDFunc = getTargetIDForClickEvent;\n    }\n\n    if (getTargetIDFunc) {\n      var targetID = getTargetIDFunc(\n        topLevelType,\n        topLevelTarget,\n        topLevelTargetID\n      );\n      if (targetID) {\n        var event = SyntheticEvent.getPooled(\n          eventTypes.change,\n          targetID,\n          nativeEvent\n        );\n        EventPropagators.accumulateTwoPhaseDispatches(event);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(\n        topLevelType,\n        topLevelTarget,\n        topLevelTargetID\n      );\n    }\n  }\n\n};\n\nmodule.exports = ChangeEventPlugin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ChangeEventPlugin.js\n ** module id = 125\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ChangeEventPlugin.js?")},/*!*********************************************!*\
  !*** ./~/react/lib/ClientReactRootIndex.js ***!
  \*********************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ClientReactRootIndex\n * @typechecks\n */\n\n'use strict';\n\nvar nextReactRootIndex = 0;\n\nvar ClientReactRootIndex = {\n  createReactRootIndex: function() {\n    return nextReactRootIndex++;\n  }\n};\n\nmodule.exports = ClientReactRootIndex;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ClientReactRootIndex.js\n ** module id = 126\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ClientReactRootIndex.js?")},/*!**********************************************!*\
  !*** ./~/react/lib/DOMChildrenOperations.js ***!
  \**********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DOMChildrenOperations\n * @typechecks static-only\n */\n\n'use strict';\n\nvar Danger = __webpack_require__(/*! ./Danger */ 128);\nvar ReactMultiChildUpdateTypes = __webpack_require__(/*! ./ReactMultiChildUpdateTypes */ 80);\n\nvar setTextContent = __webpack_require__(/*! ./setTextContent */ 201);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\n/**\n * Inserts `childNode` as a child of `parentNode` at the `index`.\n *\n * @param {DOMElement} parentNode Parent node in which to insert.\n * @param {DOMElement} childNode Child node to insert.\n * @param {number} index Index at which to insert the child.\n * @internal\n */\nfunction insertChildAt(parentNode, childNode, index) {\n  // By exploiting arrays returning `undefined` for an undefined index, we can\n  // rely exclusively on `insertBefore(node, null)` instead of also using\n  // `appendChild(node)`. However, using `undefined` is not allowed by all\n  // browsers so we must replace it with `null`.\n  parentNode.insertBefore(\n    childNode,\n    parentNode.childNodes[index] || null\n  );\n}\n\n/**\n * Operations for updating with DOM children.\n */\nvar DOMChildrenOperations = {\n\n  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,\n\n  updateTextContent: setTextContent,\n\n  /**\n   * Updates a component's children by processing a series of updates. The\n   * update configurations are each expected to have a `parentNode` property.\n   *\n   * @param {array<object>} updates List of update configurations.\n   * @param {array<string>} markupList List of markup strings.\n   * @internal\n   */\n  processUpdates: function(updates, markupList) {\n    var update;\n    // Mapping from parent IDs to initial child orderings.\n    var initialChildren = null;\n    // List of children that will be moved or removed.\n    var updatedChildren = null;\n\n    for (var i = 0; i < updates.length; i++) {\n      update = updates[i];\n      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING ||\n          update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {\n        var updatedIndex = update.fromIndex;\n        var updatedChild = update.parentNode.childNodes[updatedIndex];\n        var parentID = update.parentID;\n\n        (false ? invariant(\n          updatedChild,\n          'processUpdates(): Unable to find child %s of element. This ' +\n          'probably means the DOM was unexpectedly mutated (e.g., by the ' +\n          'browser), usually due to forgetting a <tbody> when using tables, ' +\n          'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' +\n          'in an <svg> parent. Try inspecting the child nodes of the element ' +\n          'with React ID `%s`.',\n          updatedIndex,\n          parentID\n        ) : invariant(updatedChild));\n\n        initialChildren = initialChildren || {};\n        initialChildren[parentID] = initialChildren[parentID] || [];\n        initialChildren[parentID][updatedIndex] = updatedChild;\n\n        updatedChildren = updatedChildren || [];\n        updatedChildren.push(updatedChild);\n      }\n    }\n\n    var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);\n\n    // Remove updated children first so that `toIndex` is consistent.\n    if (updatedChildren) {\n      for (var j = 0; j < updatedChildren.length; j++) {\n        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);\n      }\n    }\n\n    for (var k = 0; k < updates.length; k++) {\n      update = updates[k];\n      switch (update.type) {\n        case ReactMultiChildUpdateTypes.INSERT_MARKUP:\n          insertChildAt(\n            update.parentNode,\n            renderedMarkup[update.markupIndex],\n            update.toIndex\n          );\n          break;\n        case ReactMultiChildUpdateTypes.MOVE_EXISTING:\n          insertChildAt(\n            update.parentNode,\n            initialChildren[update.parentID][update.fromIndex],\n            update.toIndex\n          );\n          break;\n        case ReactMultiChildUpdateTypes.TEXT_CONTENT:\n          setTextContent(\n            update.parentNode,\n            update.textContent\n          );\n          break;\n        case ReactMultiChildUpdateTypes.REMOVE_NODE:\n          // Already removed by the for-loop above.\n          break;\n      }\n    }\n  }\n\n};\n\nmodule.exports = DOMChildrenOperations;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/DOMChildrenOperations.js\n ** module id = 127\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/DOMChildrenOperations.js?")},/*!*******************************!*\
  !*** ./~/react/lib/Danger.js ***!
  \*******************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Danger\n * @typechecks static-only\n */\n\n/*jslint evil: true, sub: true */\n\n'use strict';\n\nvar ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ 6);\n\nvar createNodesFromMarkup = __webpack_require__(/*! ./createNodesFromMarkup */ 186);\nvar emptyFunction = __webpack_require__(/*! ./emptyFunction */ 10);\nvar getMarkupWrap = __webpack_require__(/*! ./getMarkupWrap */ 92);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\nvar OPEN_TAG_NAME_EXP = /^(<[^ \\/>]+)/;\nvar RESULT_INDEX_ATTR = 'data-danger-index';\n\n/**\n * Extracts the `nodeName` from a string of markup.\n *\n * NOTE: Extracting the `nodeName` does not require a regular expression match\n * because we make assumptions about React-generated markup (i.e. there are no\n * spaces surrounding the opening tag and there is at least one attribute).\n *\n * @param {string} markup String of markup.\n * @return {string} Node name of the supplied markup.\n * @see http://jsperf.com/extract-nodename\n */\nfunction getNodeName(markup) {\n  return markup.substring(1, markup.indexOf(' '));\n}\n\nvar Danger = {\n\n  /**\n   * Renders markup into an array of nodes. The markup is expected to render\n   * into a list of root nodes. Also, the length of `resultList` and\n   * `markupList` should be the same.\n   *\n   * @param {array<string>} markupList List of markup strings to render.\n   * @return {array<DOMElement>} List of rendered nodes.\n   * @internal\n   */\n  dangerouslyRenderMarkup: function(markupList) {\n    (false ? invariant(\n      ExecutionEnvironment.canUseDOM,\n      'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' +\n      'thread. Make sure `window` and `document` are available globally ' +\n      'before requiring React when unit testing or use ' +\n      'React.renderToString for server rendering.'\n    ) : invariant(ExecutionEnvironment.canUseDOM));\n    var nodeName;\n    var markupByNodeName = {};\n    // Group markup by `nodeName` if a wrap is necessary, else by '*'.\n    for (var i = 0; i < markupList.length; i++) {\n      (false ? invariant(\n        markupList[i],\n        'dangerouslyRenderMarkup(...): Missing markup.'\n      ) : invariant(markupList[i]));\n      nodeName = getNodeName(markupList[i]);\n      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';\n      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];\n      markupByNodeName[nodeName][i] = markupList[i];\n    }\n    var resultList = [];\n    var resultListAssignmentCount = 0;\n    for (nodeName in markupByNodeName) {\n      if (!markupByNodeName.hasOwnProperty(nodeName)) {\n        continue;\n      }\n      var markupListByNodeName = markupByNodeName[nodeName];\n\n      // This for-in loop skips the holes of the sparse array. The order of\n      // iteration should follow the order of assignment, which happens to match\n      // numerical index order, but we don't rely on that.\n      var resultIndex;\n      for (resultIndex in markupListByNodeName) {\n        if (markupListByNodeName.hasOwnProperty(resultIndex)) {\n          var markup = markupListByNodeName[resultIndex];\n\n          // Push the requested markup with an additional RESULT_INDEX_ATTR\n          // attribute.  If the markup does not start with a < character, it\n          // will be discarded below (with an appropriate console.error).\n          markupListByNodeName[resultIndex] = markup.replace(\n            OPEN_TAG_NAME_EXP,\n            // This index will be parsed back out below.\n            '$1 ' + RESULT_INDEX_ATTR + '=\"' + resultIndex + '\" '\n          );\n        }\n      }\n\n      // Render each group of markup with similar wrapping `nodeName`.\n      var renderNodes = createNodesFromMarkup(\n        markupListByNodeName.join(''),\n        emptyFunction // Do nothing special with <script> tags.\n      );\n\n      for (var j = 0; j < renderNodes.length; ++j) {\n        var renderNode = renderNodes[j];\n        if (renderNode.hasAttribute &&\n            renderNode.hasAttribute(RESULT_INDEX_ATTR)) {\n\n          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);\n          renderNode.removeAttribute(RESULT_INDEX_ATTR);\n\n          (false ? invariant(\n            !resultList.hasOwnProperty(resultIndex),\n            'Danger: Assigning to an already-occupied result index.'\n          ) : invariant(!resultList.hasOwnProperty(resultIndex)));\n\n          resultList[resultIndex] = renderNode;\n\n          // This should match resultList.length and markupList.length when\n          // we're done.\n          resultListAssignmentCount += 1;\n\n        } else if (false) {\n          console.error(\n            'Danger: Discarding unexpected node:',\n            renderNode\n          );\n        }\n      }\n    }\n\n    // Although resultList was populated out of order, it should now be a dense\n    // array.\n    (false ? invariant(\n      resultListAssignmentCount === resultList.length,\n      'Danger: Did not assign to every index of resultList.'\n    ) : invariant(resultListAssignmentCount === resultList.length));\n\n    (false ? invariant(\n      resultList.length === markupList.length,\n      'Danger: Expected markup to render %s nodes, but rendered %s.',\n      markupList.length,\n      resultList.length\n    ) : invariant(resultList.length === markupList.length));\n\n    return resultList;\n  },\n\n  /**\n   * Replaces a node with a string of markup at its current position within its\n   * parent. The markup must render into a single root node.\n   *\n   * @param {DOMElement} oldChild Child node to replace.\n   * @param {string} markup Markup to render in place of the child node.\n   * @internal\n   */\n  dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {\n    (false ? invariant(\n      ExecutionEnvironment.canUseDOM,\n      'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' +\n      'worker thread. Make sure `window` and `document` are available ' +\n      'globally before requiring React when unit testing or use ' +\n      'React.renderToString for server rendering.'\n    ) : invariant(ExecutionEnvironment.canUseDOM));\n    (false ? invariant(markup, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(markup));\n    (false ? invariant(\n      oldChild.tagName.toLowerCase() !== 'html',\n      'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' +\n      '<html> node. This is because browser quirks make this unreliable ' +\n      'and/or slow. If you want to render to the root you must use ' +\n      'server rendering. See React.renderToString().'\n    ) : invariant(oldChild.tagName.toLowerCase() !== 'html'));\n\n    var newChild = createNodesFromMarkup(markup, emptyFunction)[0];\n    oldChild.parentNode.replaceChild(newChild, oldChild);\n  }\n\n};\n\nmodule.exports = Danger;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/Danger.js\n ** module id = 128\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/Danger.js?")},/*!************************************************!*\
  !*** ./~/react/lib/DefaultEventPluginOrder.js ***!
  \************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DefaultEventPluginOrder\n */\n\n'use strict';\n\nvar keyOf = __webpack_require__(/*! ./keyOf */ 11);\n\n/**\n * Module that is injectable into `EventPluginHub`, that specifies a\n * deterministic ordering of `EventPlugin`s. A convenient way to reason about\n * plugins, without having to package every one of them. This is better than\n * having plugins be ordered in the same order that they are injected because\n * that ordering would be influenced by the packaging order.\n * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that\n * preventing default on events is convenient in `SimpleEventPlugin` handlers.\n */\nvar DefaultEventPluginOrder = [\n  keyOf({ResponderEventPlugin: null}),\n  keyOf({SimpleEventPlugin: null}),\n  keyOf({TapEventPlugin: null}),\n  keyOf({EnterLeaveEventPlugin: null}),\n  keyOf({ChangeEventPlugin: null}),\n  keyOf({SelectEventPlugin: null}),\n  keyOf({BeforeInputEventPlugin: null}),\n  keyOf({AnalyticsEventPlugin: null}),\n  keyOf({MobileSafariClickEventPlugin: null})\n];\n\nmodule.exports = DefaultEventPluginOrder;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/DefaultEventPluginOrder.js\n ** module id = 129\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/DefaultEventPluginOrder.js?")},/*!**********************************************!*\
  !*** ./~/react/lib/EnterLeaveEventPlugin.js ***!
  \**********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EnterLeaveEventPlugin\n * @typechecks static-only\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(/*! ./EventConstants */ 7);\nvar EventPropagators = __webpack_require__(/*! ./EventPropagators */ 31);\nvar SyntheticMouseEvent = __webpack_require__(/*! ./SyntheticMouseEvent */ 40);\n\nvar ReactMount = __webpack_require__(/*! ./ReactMount */ 15);\nvar keyOf = __webpack_require__(/*! ./keyOf */ 11);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\nvar getFirstReactDOM = ReactMount.getFirstReactDOM;\n\nvar eventTypes = {\n  mouseEnter: {\n    registrationName: keyOf({onMouseEnter: null}),\n    dependencies: [\n      topLevelTypes.topMouseOut,\n      topLevelTypes.topMouseOver\n    ]\n  },\n  mouseLeave: {\n    registrationName: keyOf({onMouseLeave: null}),\n    dependencies: [\n      topLevelTypes.topMouseOut,\n      topLevelTypes.topMouseOver\n    ]\n  }\n};\n\nvar extractedEvents = [null, null];\n\nvar EnterLeaveEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  /**\n   * For almost every interaction we care about, there will be both a top-level\n   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n   * we do not extract duplicate events. However, moving the mouse into the\n   * browser from outside will not fire a `mouseout` event. In this case, we use\n   * the `mouseover` top-level event.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n    if (topLevelType === topLevelTypes.topMouseOver &&\n        (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\n      return null;\n    }\n    if (topLevelType !== topLevelTypes.topMouseOut &&\n        topLevelType !== topLevelTypes.topMouseOver) {\n      // Must not be a mouse in or mouse out - ignoring.\n      return null;\n    }\n\n    var win;\n    if (topLevelTarget.window === topLevelTarget) {\n      // `topLevelTarget` is probably a window object.\n      win = topLevelTarget;\n    } else {\n      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n      var doc = topLevelTarget.ownerDocument;\n      if (doc) {\n        win = doc.defaultView || doc.parentWindow;\n      } else {\n        win = window;\n      }\n    }\n\n    var from, to;\n    if (topLevelType === topLevelTypes.topMouseOut) {\n      from = topLevelTarget;\n      to =\n        getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement) ||\n        win;\n    } else {\n      from = win;\n      to = topLevelTarget;\n    }\n\n    if (from === to) {\n      // Nothing pertains to our managed components.\n      return null;\n    }\n\n    var fromID = from ? ReactMount.getID(from) : '';\n    var toID = to ? ReactMount.getID(to) : '';\n\n    var leave = SyntheticMouseEvent.getPooled(\n      eventTypes.mouseLeave,\n      fromID,\n      nativeEvent\n    );\n    leave.type = 'mouseleave';\n    leave.target = from;\n    leave.relatedTarget = to;\n\n    var enter = SyntheticMouseEvent.getPooled(\n      eventTypes.mouseEnter,\n      toID,\n      nativeEvent\n    );\n    enter.type = 'mouseenter';\n    enter.target = to;\n    enter.relatedTarget = from;\n\n    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);\n\n    extractedEvents[0] = leave;\n    extractedEvents[1] = enter;\n\n    return extractedEvents;\n  }\n\n};\n\nmodule.exports = EnterLeaveEventPlugin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EnterLeaveEventPlugin.js\n ** module id = 130\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EnterLeaveEventPlugin.js?")},/*!**************************************!*\
  !*** ./~/react/lib/EventListener.js ***!
  \**************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule EventListener\n * @typechecks\n */\n\nvar emptyFunction = __webpack_require__(/*! ./emptyFunction */ 10);\n\n/**\n * Upstream version of event listener. Does not take into account specific\n * nature of platform.\n */\nvar EventListener = {\n  /**\n   * Listen to DOM events during the bubble phase.\n   *\n   * @param {DOMEventTarget} target DOM element to register listener on.\n   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.\n   * @param {function} callback Callback function.\n   * @return {object} Object with a `remove` method.\n   */\n  listen: function(target, eventType, callback) {\n    if (target.addEventListener) {\n      target.addEventListener(eventType, callback, false);\n      return {\n        remove: function() {\n          target.removeEventListener(eventType, callback, false);\n        }\n      };\n    } else if (target.attachEvent) {\n      target.attachEvent('on' + eventType, callback);\n      return {\n        remove: function() {\n          target.detachEvent('on' + eventType, callback);\n        }\n      };\n    }\n  },\n\n  /**\n   * Listen to DOM events during the capture phase.\n   *\n   * @param {DOMEventTarget} target DOM element to register listener on.\n   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.\n   * @param {function} callback Callback function.\n   * @return {object} Object with a `remove` method.\n   */\n  capture: function(target, eventType, callback) {\n    if (!target.addEventListener) {\n      if (false) {\n        console.error(\n          'Attempted to listen to events during the capture phase on a ' +\n          'browser that does not support the capture phase. Your application ' +\n          'will not receive some events.'\n        );\n      }\n      return {\n        remove: emptyFunction\n      };\n    } else {\n      target.addEventListener(eventType, callback, true);\n      return {\n        remove: function() {\n          target.removeEventListener(eventType, callback, true);\n        }\n      };\n    }\n  },\n\n  registerDefault: function() {}\n};\n\nmodule.exports = EventListener;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EventListener.js\n ** module id = 131\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EventListener.js?")},/*!*************************************************!*\
  !*** ./~/react/lib/FallbackCompositionState.js ***!
  \*************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FallbackCompositionState\n * @typechecks static-only\n */\n\n'use strict';\n\nvar PooledClass = __webpack_require__(/*! ./PooledClass */ 12);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar getTextContentAccessor = __webpack_require__(/*! ./getTextContentAccessor */ 93);\n\n/**\n * This helper class stores information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n * @param {DOMEventTarget} root\n */\nfunction FallbackCompositionState(root) {\n  this._root = root;\n  this._startText = this.getText();\n  this._fallbackText = null;\n}\n\nassign(FallbackCompositionState.prototype, {\n  /**\n   * Get current text of input.\n   *\n   * @return {string}\n   */\n  getText: function() {\n    if ('value' in this._root) {\n      return this._root.value;\n    }\n    return this._root[getTextContentAccessor()];\n  },\n\n  /**\n   * Determine the differing substring between the initially stored\n   * text content and the current content.\n   *\n   * @return {string}\n   */\n  getData: function() {\n    if (this._fallbackText) {\n      return this._fallbackText;\n    }\n\n    var start;\n    var startValue = this._startText;\n    var startLength = startValue.length;\n    var end;\n    var endValue = this.getText();\n    var endLength = endValue.length;\n\n    for (start = 0; start < startLength; start++) {\n      if (startValue[start] !== endValue[start]) {\n        break;\n      }\n    }\n\n    var minEnd = startLength - start;\n    for (end = 1; end <= minEnd; end++) {\n      if (startValue[startLength - end] !== endValue[endLength - end]) {\n        break;\n      }\n    }\n\n    var sliceTail = end > 1 ? 1 - end : undefined;\n    this._fallbackText = endValue.slice(start, sliceTail);\n    return this._fallbackText;\n  }\n});\n\nPooledClass.addPoolingTo(FallbackCompositionState);\n\nmodule.exports = FallbackCompositionState;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/FallbackCompositionState.js\n ** module id = 132\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/FallbackCompositionState.js?")},/*!**********************************************!*\
  !*** ./~/react/lib/HTMLDOMPropertyConfig.js ***!
  \**********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule HTMLDOMPropertyConfig\n */\n\n/*jslint bitwise: true*/\n\n'use strict';\n\nvar DOMProperty = __webpack_require__(/*! ./DOMProperty */ 19);\nvar ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ 6);\n\nvar MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;\nvar MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;\nvar HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;\nvar HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;\nvar HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;\nvar HAS_POSITIVE_NUMERIC_VALUE =\n  DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;\nvar HAS_OVERLOADED_BOOLEAN_VALUE =\n  DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;\n\nvar hasSVG;\nif (ExecutionEnvironment.canUseDOM) {\n  var implementation = document.implementation;\n  hasSVG = (\n    implementation &&\n    implementation.hasFeature &&\n    implementation.hasFeature(\n      'http://www.w3.org/TR/SVG11/feature#BasicStructure',\n      '1.1'\n    )\n  );\n}\n\n\nvar HTMLDOMPropertyConfig = {\n  isCustomAttribute: RegExp.prototype.test.bind(\n    /^(data|aria)-[a-z_][a-z\\d_.\\-]*$/\n  ),\n  Properties: {\n    /**\n     * Standard Properties\n     */\n    accept: null,\n    acceptCharset: null,\n    accessKey: null,\n    action: null,\n    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,\n    allowTransparency: MUST_USE_ATTRIBUTE,\n    alt: null,\n    async: HAS_BOOLEAN_VALUE,\n    autoComplete: null,\n    // autoFocus is polyfilled/normalized by AutoFocusMixin\n    // autoFocus: HAS_BOOLEAN_VALUE,\n    autoPlay: HAS_BOOLEAN_VALUE,\n    cellPadding: null,\n    cellSpacing: null,\n    charSet: MUST_USE_ATTRIBUTE,\n    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    classID: MUST_USE_ATTRIBUTE,\n    // To set className on SVG elements, it's necessary to use .setAttribute;\n    // this works on HTML elements too in all browsers except IE8. Conveniently,\n    // IE8 doesn't support SVG and so we can simply use the attribute in\n    // browsers that support SVG and the property in browsers that don't,\n    // regardless of whether the element is HTML or SVG.\n    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,\n    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,\n    colSpan: null,\n    content: null,\n    contentEditable: null,\n    contextMenu: MUST_USE_ATTRIBUTE,\n    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    coords: null,\n    crossOrigin: null,\n    data: null, // For `<object />` acts as `src`.\n    dateTime: MUST_USE_ATTRIBUTE,\n    defer: HAS_BOOLEAN_VALUE,\n    dir: null,\n    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,\n    download: HAS_OVERLOADED_BOOLEAN_VALUE,\n    draggable: null,\n    encType: null,\n    form: MUST_USE_ATTRIBUTE,\n    formAction: MUST_USE_ATTRIBUTE,\n    formEncType: MUST_USE_ATTRIBUTE,\n    formMethod: MUST_USE_ATTRIBUTE,\n    formNoValidate: HAS_BOOLEAN_VALUE,\n    formTarget: MUST_USE_ATTRIBUTE,\n    frameBorder: MUST_USE_ATTRIBUTE,\n    headers: null,\n    height: MUST_USE_ATTRIBUTE,\n    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,\n    high: null,\n    href: null,\n    hrefLang: null,\n    htmlFor: null,\n    httpEquiv: null,\n    icon: null,\n    id: MUST_USE_PROPERTY,\n    label: null,\n    lang: null,\n    list: MUST_USE_ATTRIBUTE,\n    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    low: null,\n    manifest: MUST_USE_ATTRIBUTE,\n    marginHeight: null,\n    marginWidth: null,\n    max: null,\n    maxLength: MUST_USE_ATTRIBUTE,\n    media: MUST_USE_ATTRIBUTE,\n    mediaGroup: null,\n    method: null,\n    min: null,\n    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    name: null,\n    noValidate: HAS_BOOLEAN_VALUE,\n    open: HAS_BOOLEAN_VALUE,\n    optimum: null,\n    pattern: null,\n    placeholder: null,\n    poster: null,\n    preload: null,\n    radioGroup: null,\n    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    rel: null,\n    required: HAS_BOOLEAN_VALUE,\n    role: MUST_USE_ATTRIBUTE,\n    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,\n    rowSpan: null,\n    sandbox: null,\n    scope: null,\n    scoped: HAS_BOOLEAN_VALUE,\n    scrolling: null,\n    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,\n    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    shape: null,\n    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,\n    sizes: MUST_USE_ATTRIBUTE,\n    span: HAS_POSITIVE_NUMERIC_VALUE,\n    spellCheck: null,\n    src: null,\n    srcDoc: MUST_USE_PROPERTY,\n    srcSet: MUST_USE_ATTRIBUTE,\n    start: HAS_NUMERIC_VALUE,\n    step: null,\n    style: null,\n    tabIndex: null,\n    target: null,\n    title: null,\n    type: null,\n    useMap: null,\n    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,\n    width: MUST_USE_ATTRIBUTE,\n    wmode: MUST_USE_ATTRIBUTE,\n\n    /**\n     * Non-standard Properties\n     */\n    // autoCapitalize and autoCorrect are supported in Mobile Safari for\n    // keyboard hints.\n    autoCapitalize: null,\n    autoCorrect: null,\n    // itemProp, itemScope, itemType are for\n    // Microdata support. See http://schema.org/docs/gs.html\n    itemProp: MUST_USE_ATTRIBUTE,\n    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,\n    itemType: MUST_USE_ATTRIBUTE,\n    // itemID and itemRef are for Microdata support as well but\n    // only specified in the the WHATWG spec document. See\n    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api\n    itemID: MUST_USE_ATTRIBUTE,\n    itemRef: MUST_USE_ATTRIBUTE,\n    // property is supported for OpenGraph in meta tags.\n    property: null,\n    // IE-only attribute that controls focus behavior\n    unselectable: MUST_USE_ATTRIBUTE\n  },\n  DOMAttributeNames: {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv'\n  },\n  DOMPropertyNames: {\n    autoCapitalize: 'autocapitalize',\n    autoComplete: 'autocomplete',\n    autoCorrect: 'autocorrect',\n    autoFocus: 'autofocus',\n    autoPlay: 'autoplay',\n    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.\n    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding\n    encType: 'encoding',\n    hrefLang: 'hreflang',\n    radioGroup: 'radiogroup',\n    spellCheck: 'spellcheck',\n    srcDoc: 'srcdoc',\n    srcSet: 'srcset'\n  }\n};\n\nmodule.exports = HTMLDOMPropertyConfig;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/HTMLDOMPropertyConfig.js\n ** module id = 133\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/HTMLDOMPropertyConfig.js?")},/*!*****************************************!*\
  !*** ./~/react/lib/LinkedStateMixin.js ***!
  \*****************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule LinkedStateMixin\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactLink = __webpack_require__(/*! ./ReactLink */ 157);\nvar ReactStateSetters = __webpack_require__(/*! ./ReactStateSetters */ 165);\n\n/**\n * A simple mixin around ReactLink.forState().\n */\nvar LinkedStateMixin = {\n  /**\n   * Create a ReactLink that's linked to part of this component's state. The\n   * ReactLink will have the current value of this.state[key] and will call\n   * setState() when a change is requested.\n   *\n   * @param {string} key state key to update. Note: you may want to use keyOf()\n   * if you're using Google Closure Compiler advanced mode.\n   * @return {ReactLink} ReactLink instance linking to the state.\n   */\n  linkState: function(key) {\n    return new ReactLink(\n      this.state[key],\n      ReactStateSetters.createStateKeySetter(this, key)\n    );\n  }\n};\n\nmodule.exports = LinkedStateMixin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/LinkedStateMixin.js\n ** module id = 134\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/LinkedStateMixin.js?")},/*!*****************************************************!*\
  !*** ./~/react/lib/MobileSafariClickEventPlugin.js ***!
  \*****************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule MobileSafariClickEventPlugin\n * @typechecks static-only\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(/*! ./EventConstants */ 7);\n\nvar emptyFunction = __webpack_require__(/*! ./emptyFunction */ 10);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\n/**\n * Mobile Safari does not fire properly bubble click events on non-interactive\n * elements, which means delegated click listeners do not fire. The workaround\n * for this bug involves attaching an empty click listener on the target node.\n *\n * This particular plugin works around the bug by attaching an empty click\n * listener on `touchstart` (which does fire on every element).\n */\nvar MobileSafariClickEventPlugin = {\n\n  eventTypes: null,\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n    if (topLevelType === topLevelTypes.topTouchStart) {\n      var target = nativeEvent.target;\n      if (target && !target.onclick) {\n        target.onclick = emptyFunction;\n      }\n    }\n  }\n\n};\n\nmodule.exports = MobileSafariClickEventPlugin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/MobileSafariClickEventPlugin.js\n ** module id = 135\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/MobileSafariClickEventPlugin.js?")},/*!************************************************!*\
  !*** ./~/react/lib/ReactCSSTransitionGroup.js ***!
  \************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks\n * @providesModule ReactCSSTransitionGroup\n */\n\n'use strict';\n\nvar React = __webpack_require__(/*! ./React */ 20);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\n\nvar ReactTransitionGroup = React.createFactory(\n  __webpack_require__(/*! ./ReactTransitionGroup */ 84)\n);\nvar ReactCSSTransitionGroupChild = React.createFactory(\n  __webpack_require__(/*! ./ReactCSSTransitionGroupChild */ 137)\n);\n\nvar ReactCSSTransitionGroup = React.createClass({\n  displayName: 'ReactCSSTransitionGroup',\n\n  propTypes: {\n    transitionName: React.PropTypes.string.isRequired,\n    transitionAppear: React.PropTypes.bool,\n    transitionEnter: React.PropTypes.bool,\n    transitionLeave: React.PropTypes.bool\n  },\n\n  getDefaultProps: function() {\n    return {\n      transitionAppear: false,\n      transitionEnter: true,\n      transitionLeave: true\n    };\n  },\n\n  _wrapChild: function(child) {\n    // We need to provide this childFactory so that\n    // ReactCSSTransitionGroupChild can receive updates to name, enter, and\n    // leave while it is leaving.\n    return ReactCSSTransitionGroupChild(\n      {\n        name: this.props.transitionName,\n        appear: this.props.transitionAppear,\n        enter: this.props.transitionEnter,\n        leave: this.props.transitionLeave\n      },\n      child\n    );\n  },\n\n  render: function() {\n    return (\n      ReactTransitionGroup(\n        assign({}, this.props, {childFactory: this._wrapChild})\n      )\n    );\n  }\n});\n\nmodule.exports = ReactCSSTransitionGroup;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactCSSTransitionGroup.js\n ** module id = 136\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactCSSTransitionGroup.js?")},/*!*****************************************************!*\
  !*** ./~/react/lib/ReactCSSTransitionGroupChild.js ***!
  \*****************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks\n * @providesModule ReactCSSTransitionGroupChild\n */\n\n'use strict';\n\nvar React = __webpack_require__(/*! ./React */ 20);\n\nvar CSSCore = __webpack_require__(/*! ./CSSCore */ 124);\nvar ReactTransitionEvents = __webpack_require__(/*! ./ReactTransitionEvents */ 167);\n\nvar onlyChild = __webpack_require__(/*! ./onlyChild */ 96);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\n// We don't remove the element from the DOM until we receive an animationend or\n// transitionend event. If the user screws up and forgets to add an animation\n// their node will be stuck in the DOM forever, so we detect if an animation\n// does not start and if it doesn't, we just call the end listener immediately.\nvar TICK = 17;\nvar NO_EVENT_TIMEOUT = 5000;\n\nvar noEventListener = null;\n\n\nif (false) {\n  noEventListener = function() {\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      false,\n      'transition(): tried to perform an animation without ' +\n      'an animationend or transitionend event after timeout (' +\n      '%sms). You should either disable this ' +\n      'transition in JS or add a CSS animation/transition.',\n      NO_EVENT_TIMEOUT\n    ) : null);\n  };\n}\n\nvar ReactCSSTransitionGroupChild = React.createClass({\n  displayName: 'ReactCSSTransitionGroupChild',\n\n  transition: function(animationType, finishCallback) {\n    var node = this.getDOMNode();\n    var className = this.props.name + '-' + animationType;\n    var activeClassName = className + '-active';\n    var noEventTimeout = null;\n\n    var endListener = function(e) {\n      if (e && e.target !== node) {\n        return;\n      }\n      if (false) {\n        clearTimeout(noEventTimeout);\n      }\n\n      CSSCore.removeClass(node, className);\n      CSSCore.removeClass(node, activeClassName);\n\n      ReactTransitionEvents.removeEndEventListener(node, endListener);\n\n      // Usually this optional callback is used for informing an owner of\n      // a leave animation and telling it to remove the child.\n      if (finishCallback) {\n        finishCallback();\n      }\n    };\n\n    ReactTransitionEvents.addEndEventListener(node, endListener);\n\n    CSSCore.addClass(node, className);\n\n    // Need to do this to actually trigger a transition.\n    this.queueClass(activeClassName);\n\n    if (false) {\n      noEventTimeout = setTimeout(noEventListener, NO_EVENT_TIMEOUT);\n    }\n  },\n\n  queueClass: function(className) {\n    this.classNameQueue.push(className);\n\n    if (!this.timeout) {\n      this.timeout = setTimeout(this.flushClassNameQueue, TICK);\n    }\n  },\n\n  flushClassNameQueue: function() {\n    if (this.isMounted()) {\n      this.classNameQueue.forEach(\n        CSSCore.addClass.bind(CSSCore, this.getDOMNode())\n      );\n    }\n    this.classNameQueue.length = 0;\n    this.timeout = null;\n  },\n\n  componentWillMount: function() {\n    this.classNameQueue = [];\n  },\n\n  componentWillUnmount: function() {\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n    }\n  },\n\n  componentWillAppear: function(done) {\n    if (this.props.appear) {\n      this.transition('appear', done);\n    } else {\n      done();\n    }\n  },\n\n  componentWillEnter: function(done) {\n    if (this.props.enter) {\n      this.transition('enter', done);\n    } else {\n      done();\n    }\n  },\n\n  componentWillLeave: function(done) {\n    if (this.props.leave) {\n      this.transition('leave', done);\n    } else {\n      done();\n    }\n  },\n\n  render: function() {\n    return onlyChild(this.props.children);\n  }\n});\n\nmodule.exports = ReactCSSTransitionGroupChild;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactCSSTransitionGroupChild.js\n ** module id = 137\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactCSSTransitionGroupChild.js?")},/*!*********************************************!*\
  !*** ./~/react/lib/ReactChildReconciler.js ***!
  \*********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactChildReconciler\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactReconciler = __webpack_require__(/*! ./ReactReconciler */ 25);\n\nvar flattenChildren = __webpack_require__(/*! ./flattenChildren */ 189);\nvar instantiateReactComponent = __webpack_require__(/*! ./instantiateReactComponent */ 62);\nvar shouldUpdateReactComponent = __webpack_require__(/*! ./shouldUpdateReactComponent */ 65);\n\n/**\n * ReactChildReconciler provides helpers for initializing or updating a set of\n * children. Its output is suitable for passing it onto ReactMultiChild which\n * does diffed reordering and insertion.\n */\nvar ReactChildReconciler = {\n\n  /**\n   * Generates a \"mount image\" for each of the supplied children. In the case\n   * of `ReactDOMComponent`, a mount image is a string of markup.\n   *\n   * @param {?object} nestedChildNodes Nested child maps.\n   * @return {?object} A set of child instances.\n   * @internal\n   */\n  instantiateChildren: function(nestedChildNodes, transaction, context) {\n    var children = flattenChildren(nestedChildNodes);\n    for (var name in children) {\n      if (children.hasOwnProperty(name)) {\n        var child = children[name];\n        // The rendered children must be turned into instances as they're\n        // mounted.\n        var childInstance = instantiateReactComponent(child, null);\n        children[name] = childInstance;\n      }\n    }\n    return children;\n  },\n\n  /**\n   * Updates the rendered children and returns a new set of children.\n   *\n   * @param {?object} prevChildren Previously initialized set of children.\n   * @param {?object} nextNestedChildNodes Nested child maps.\n   * @param {ReactReconcileTransaction} transaction\n   * @param {object} context\n   * @return {?object} A new set of child instances.\n   * @internal\n   */\n  updateChildren: function(\n    prevChildren,\n    nextNestedChildNodes,\n    transaction,\n    context) {\n    // We currently don't have a way to track moves here but if we use iterators\n    // instead of for..in we can zip the iterators and check if an item has\n    // moved.\n    // TODO: If nothing has changed, return the prevChildren object so that we\n    // can quickly bailout if nothing has changed.\n    var nextChildren = flattenChildren(nextNestedChildNodes);\n    if (!nextChildren && !prevChildren) {\n      return null;\n    }\n    var name;\n    for (name in nextChildren) {\n      if (!nextChildren.hasOwnProperty(name)) {\n        continue;\n      }\n      var prevChild = prevChildren && prevChildren[name];\n      var prevElement = prevChild && prevChild._currentElement;\n      var nextElement = nextChildren[name];\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        ReactReconciler.receiveComponent(\n          prevChild, nextElement, transaction, context\n        );\n        nextChildren[name] = prevChild;\n      } else {\n        if (prevChild) {\n          ReactReconciler.unmountComponent(prevChild, name);\n        }\n        // The child must be instantiated before it's mounted.\n        var nextChildInstance = instantiateReactComponent(\n          nextElement,\n          null\n        );\n        nextChildren[name] = nextChildInstance;\n      }\n    }\n    // Unmount children that are no longer present.\n    for (name in prevChildren) {\n      if (prevChildren.hasOwnProperty(name) &&\n          !(nextChildren && nextChildren.hasOwnProperty(name))) {\n        ReactReconciler.unmountComponent(prevChildren[name]);\n      }\n    }\n    return nextChildren;\n  },\n\n  /**\n   * Unmounts all rendered children. This should be used to clean up children\n   * when this component is unmounted.\n   *\n   * @param {?object} renderedChildren Previously initialized set of children.\n   * @internal\n   */\n  unmountChildren: function(renderedChildren) {\n    for (var name in renderedChildren) {\n      var renderedChild = renderedChildren[name];\n      ReactReconciler.unmountComponent(renderedChild);\n    }\n  }\n\n};\n\nmodule.exports = ReactChildReconciler;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactChildReconciler.js\n ** module id = 138\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactChildReconciler.js?")},/*!**********************************************************!*\
  !*** ./~/react/lib/ReactComponentWithPureRenderMixin.js ***!
  \**********************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n* @providesModule ReactComponentWithPureRenderMixin\n*/\n\n'use strict';\n\nvar shallowEqual = __webpack_require__(/*! ./shallowEqual */ 97);\n\n/**\n * If your React component's render function is \"pure\", e.g. it will render the\n * same result given the same props and state, provide this Mixin for a\n * considerable performance boost.\n *\n * Most React components have pure render functions.\n *\n * Example:\n *\n *   var ReactComponentWithPureRenderMixin =\n *     require('ReactComponentWithPureRenderMixin');\n *   React.createClass({\n *     mixins: [ReactComponentWithPureRenderMixin],\n *\n *     render: function() {\n *       return <div className={this.props.className}>foo</div>;\n *     }\n *   });\n *\n * Note: This only checks shallow equality for props and state. If these contain\n * complex data structures this mixin may have false-negatives for deeper\n * differences. Only mixin to components which have simple props and state, or\n * use `forceUpdate()` when you know deep data structures have changed.\n */\nvar ReactComponentWithPureRenderMixin = {\n  shouldComponentUpdate: function(nextProps, nextState) {\n    return !shallowEqual(this.props, nextProps) ||\n           !shallowEqual(this.state, nextState);\n  }\n};\n\nmodule.exports = ReactComponentWithPureRenderMixin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactComponentWithPureRenderMixin.js\n ** module id = 139\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactComponentWithPureRenderMixin.js?")},/*!************************************************!*\
  !*** ./~/react/lib/ReactCompositeComponent.js ***!
  \************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactCompositeComponent\n */\n\n'use strict';\n\nvar ReactComponentEnvironment = __webpack_require__(/*! ./ReactComponentEnvironment */ 50);\nvar ReactContext = __webpack_require__(/*! ./ReactContext */ 51);\nvar ReactCurrentOwner = __webpack_require__(/*! ./ReactCurrentOwner */ 14);\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\nvar ReactElementValidator = __webpack_require__(/*! ./ReactElementValidator */ 32);\nvar ReactInstanceMap = __webpack_require__(/*! ./ReactInstanceMap */ 24);\nvar ReactLifeCycle = __webpack_require__(/*! ./ReactLifeCycle */ 54);\nvar ReactNativeComponent = __webpack_require__(/*! ./ReactNativeComponent */ 38);\nvar ReactPerf = __webpack_require__(/*! ./ReactPerf */ 17);\nvar ReactPropTypeLocations = __webpack_require__(/*! ./ReactPropTypeLocations */ 55);\nvar ReactPropTypeLocationNames = __webpack_require__(/*! ./ReactPropTypeLocationNames */ 39);\nvar ReactReconciler = __webpack_require__(/*! ./ReactReconciler */ 25);\nvar ReactUpdates = __webpack_require__(/*! ./ReactUpdates */ 9);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar emptyObject = __webpack_require__(/*! ./emptyObject */ 42);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\nvar shouldUpdateReactComponent = __webpack_require__(/*! ./shouldUpdateReactComponent */ 65);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nfunction getDeclarationErrorAddendum(component) {\n  var owner = component._currentElement._owner || null;\n  if (owner) {\n    var name = owner.getName();\n    if (name) {\n      return ' Check the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\n/**\n * ------------------ The Life-Cycle of a Composite Component ------------------\n *\n * - constructor: Initialization of state. The instance is now retained.\n *   - componentWillMount\n *   - render\n *   - [children's constructors]\n *     - [children's componentWillMount and render]\n *     - [children's componentDidMount]\n *     - componentDidMount\n *\n *       Update Phases:\n *       - componentWillReceiveProps (only called if parent updated)\n *       - shouldComponentUpdate\n *         - componentWillUpdate\n *           - render\n *           - [children's constructors or receive props phases]\n *         - componentDidUpdate\n *\n *     - componentWillUnmount\n *     - [children's componentWillUnmount]\n *   - [children destroyed]\n * - (destroyed): The instance is now blank, released by React and ready for GC.\n *\n * -----------------------------------------------------------------------------\n */\n\n/**\n * An incrementing ID assigned to each component when it is mounted. This is\n * used to enforce the order in which `ReactUpdates` updates dirty components.\n *\n * @private\n */\nvar nextMountID = 1;\n\n/**\n * @lends {ReactCompositeComponent.prototype}\n */\nvar ReactCompositeComponentMixin = {\n\n  /**\n   * Base constructor for all composite component.\n   *\n   * @param {ReactElement} element\n   * @final\n   * @internal\n   */\n  construct: function(element) {\n    this._currentElement = element;\n    this._rootNodeID = null;\n    this._instance = null;\n\n    // See ReactUpdateQueue\n    this._pendingElement = null;\n    this._pendingStateQueue = null;\n    this._pendingReplaceState = false;\n    this._pendingForceUpdate = false;\n\n    this._renderedComponent = null;\n\n    this._context = null;\n    this._mountOrder = 0;\n    this._isTopLevel = false;\n\n    // See ReactUpdates and ReactUpdateQueue.\n    this._pendingCallbacks = null;\n  },\n\n  /**\n   * Initializes the component, renders markup, and registers event listeners.\n   *\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {?string} Rendered markup to be inserted into the DOM.\n   * @final\n   * @internal\n   */\n  mountComponent: function(rootID, transaction, context) {\n    this._context = context;\n    this._mountOrder = nextMountID++;\n    this._rootNodeID = rootID;\n\n    var publicProps = this._processProps(this._currentElement.props);\n    var publicContext = this._processContext(this._currentElement._context);\n\n    var Component = ReactNativeComponent.getComponentClassForElement(\n      this._currentElement\n    );\n\n    // Initialize the public class\n    var inst = new Component(publicProps, publicContext);\n\n    if (false) {\n      // This will throw later in _renderValidatedComponent, but add an early\n      // warning now to help debugging\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        inst.render != null,\n        '%s(...): No `render` method found on the returned component ' +\n        'instance: you may have forgotten to define `render` in your ' +\n        'component or you may have accidentally tried to render an element ' +\n        'whose type is a function that isn\\'t a React component.',\n        Component.displayName || Component.name || 'Component'\n      ) : null);\n    }\n\n    // These should be set up in the constructor, but as a convenience for\n    // simpler class abstractions, we set them up after the fact.\n    inst.props = publicProps;\n    inst.context = publicContext;\n    inst.refs = emptyObject;\n\n    this._instance = inst;\n\n    // Store a reference from the instance back to the internal representation\n    ReactInstanceMap.set(inst, this);\n\n    if (false) {\n      this._warnIfContextsDiffer(this._currentElement._context, context);\n    }\n\n    if (false) {\n      // Since plain JS classes are defined without any special initialization\n      // logic, we can not catch common errors early. Therefore, we have to\n      // catch them here, at initialization time, instead.\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        !inst.getInitialState ||\n        inst.getInitialState.isReactClassApproved,\n        'getInitialState was defined on %s, a plain JavaScript class. ' +\n        'This is only supported for classes created using React.createClass. ' +\n        'Did you mean to define a state property instead?',\n        this.getName() || 'a component'\n      ) : null);\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        !inst.getDefaultProps ||\n        inst.getDefaultProps.isReactClassApproved,\n        'getDefaultProps was defined on %s, a plain JavaScript class. ' +\n        'This is only supported for classes created using React.createClass. ' +\n        'Use a static property to define defaultProps instead.',\n        this.getName() || 'a component'\n      ) : null);\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        !inst.propTypes,\n        'propTypes was defined as an instance property on %s. Use a static ' +\n        'property to define propTypes instead.',\n        this.getName() || 'a component'\n      ) : null);\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        !inst.contextTypes,\n        'contextTypes was defined as an instance property on %s. Use a ' +\n        'static property to define contextTypes instead.',\n        this.getName() || 'a component'\n      ) : null);\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        typeof inst.componentShouldUpdate !== 'function',\n        '%s has a method called ' +\n        'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +\n        'The name is phrased as a question because the function is ' +\n        'expected to return a value.',\n        (this.getName() || 'A component')\n      ) : null);\n    }\n\n    var initialState = inst.state;\n    if (initialState === undefined) {\n      inst.state = initialState = null;\n    }\n    (false ? invariant(\n      typeof initialState === 'object' && !Array.isArray(initialState),\n      '%s.state: must be set to an object or null',\n      this.getName() || 'ReactCompositeComponent'\n    ) : invariant(typeof initialState === 'object' && !Array.isArray(initialState)));\n\n    this._pendingStateQueue = null;\n    this._pendingReplaceState = false;\n    this._pendingForceUpdate = false;\n\n    var childContext;\n    var renderedElement;\n\n    var previouslyMounting = ReactLifeCycle.currentlyMountingInstance;\n    ReactLifeCycle.currentlyMountingInstance = this;\n    try {\n      if (inst.componentWillMount) {\n        inst.componentWillMount();\n        // When mounting, calls to `setState` by `componentWillMount` will set\n        // `this._pendingStateQueue` without triggering a re-render.\n        if (this._pendingStateQueue) {\n          inst.state = this._processPendingState(inst.props, inst.context);\n        }\n      }\n\n      childContext = this._getValidatedChildContext(context);\n      renderedElement = this._renderValidatedComponent(childContext);\n    } finally {\n      ReactLifeCycle.currentlyMountingInstance = previouslyMounting;\n    }\n\n    this._renderedComponent = this._instantiateReactComponent(\n      renderedElement,\n      this._currentElement.type // The wrapping type\n    );\n\n    var markup = ReactReconciler.mountComponent(\n      this._renderedComponent,\n      rootID,\n      transaction,\n      this._mergeChildContext(context, childContext)\n    );\n    if (inst.componentDidMount) {\n      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);\n    }\n\n    return markup;\n  },\n\n  /**\n   * Releases any resources allocated by `mountComponent`.\n   *\n   * @final\n   * @internal\n   */\n  unmountComponent: function() {\n    var inst = this._instance;\n\n    if (inst.componentWillUnmount) {\n      var previouslyUnmounting = ReactLifeCycle.currentlyUnmountingInstance;\n      ReactLifeCycle.currentlyUnmountingInstance = this;\n      try {\n        inst.componentWillUnmount();\n      } finally {\n        ReactLifeCycle.currentlyUnmountingInstance = previouslyUnmounting;\n      }\n    }\n\n    ReactReconciler.unmountComponent(this._renderedComponent);\n    this._renderedComponent = null;\n\n    // Reset pending fields\n    this._pendingStateQueue = null;\n    this._pendingReplaceState = false;\n    this._pendingForceUpdate = false;\n    this._pendingCallbacks = null;\n    this._pendingElement = null;\n\n    // These fields do not really need to be reset since this object is no\n    // longer accessible.\n    this._context = null;\n    this._rootNodeID = null;\n\n    // Delete the reference from the instance to this internal representation\n    // which allow the internals to be properly cleaned up even if the user\n    // leaks a reference to the public instance.\n    ReactInstanceMap.remove(inst);\n\n    // Some existing components rely on inst.props even after they've been\n    // destroyed (in event handlers).\n    // TODO: inst.props = null;\n    // TODO: inst.state = null;\n    // TODO: inst.context = null;\n  },\n\n  /**\n   * Schedule a partial update to the props. Only used for internal testing.\n   *\n   * @param {object} partialProps Subset of the next props.\n   * @param {?function} callback Called after props are updated.\n   * @final\n   * @internal\n   */\n  _setPropsInternal: function(partialProps, callback) {\n    // This is a deoptimized path. We optimize for always having an element.\n    // This creates an extra internal element.\n    var element = this._pendingElement || this._currentElement;\n    this._pendingElement = ReactElement.cloneAndReplaceProps(\n      element,\n      assign({}, element.props, partialProps)\n    );\n    ReactUpdates.enqueueUpdate(this, callback);\n  },\n\n  /**\n   * Filters the context object to only contain keys specified in\n   * `contextTypes`\n   *\n   * @param {object} context\n   * @return {?object}\n   * @private\n   */\n  _maskContext: function(context) {\n    var maskedContext = null;\n    // This really should be getting the component class for the element,\n    // but we know that we're not going to need it for built-ins.\n    if (typeof this._currentElement.type === 'string') {\n      return emptyObject;\n    }\n    var contextTypes = this._currentElement.type.contextTypes;\n    if (!contextTypes) {\n      return emptyObject;\n    }\n    maskedContext = {};\n    for (var contextName in contextTypes) {\n      maskedContext[contextName] = context[contextName];\n    }\n    return maskedContext;\n  },\n\n  /**\n   * Filters the context object to only contain keys specified in\n   * `contextTypes`, and asserts that they are valid.\n   *\n   * @param {object} context\n   * @return {?object}\n   * @private\n   */\n  _processContext: function(context) {\n    var maskedContext = this._maskContext(context);\n    if (false) {\n      var Component = ReactNativeComponent.getComponentClassForElement(\n        this._currentElement\n      );\n      if (Component.contextTypes) {\n        this._checkPropTypes(\n          Component.contextTypes,\n          maskedContext,\n          ReactPropTypeLocations.context\n        );\n      }\n    }\n    return maskedContext;\n  },\n\n  /**\n   * @param {object} currentContext\n   * @return {object}\n   * @private\n   */\n  _getValidatedChildContext: function(currentContext) {\n    var inst = this._instance;\n    var childContext = inst.getChildContext && inst.getChildContext();\n    if (childContext) {\n      (false ? invariant(\n        typeof inst.constructor.childContextTypes === 'object',\n        '%s.getChildContext(): childContextTypes must be defined in order to ' +\n        'use getChildContext().',\n        this.getName() || 'ReactCompositeComponent'\n      ) : invariant(typeof inst.constructor.childContextTypes === 'object'));\n      if (false) {\n        this._checkPropTypes(\n          inst.constructor.childContextTypes,\n          childContext,\n          ReactPropTypeLocations.childContext\n        );\n      }\n      for (var name in childContext) {\n        (false ? invariant(\n          name in inst.constructor.childContextTypes,\n          '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.',\n          this.getName() || 'ReactCompositeComponent',\n          name\n        ) : invariant(name in inst.constructor.childContextTypes));\n      }\n      return childContext;\n    }\n    return null;\n  },\n\n  _mergeChildContext: function(currentContext, childContext) {\n    if (childContext) {\n      return assign({}, currentContext, childContext);\n    }\n    return currentContext;\n  },\n\n  /**\n   * Processes props by setting default values for unspecified props and\n   * asserting that the props are valid. Does not mutate its argument; returns\n   * a new props object with defaults merged in.\n   *\n   * @param {object} newProps\n   * @return {object}\n   * @private\n   */\n  _processProps: function(newProps) {\n    if (false) {\n      var Component = ReactNativeComponent.getComponentClassForElement(\n        this._currentElement\n      );\n      if (Component.propTypes) {\n        this._checkPropTypes(\n          Component.propTypes,\n          newProps,\n          ReactPropTypeLocations.prop\n        );\n      }\n    }\n    return newProps;\n  },\n\n  /**\n   * Assert that the props are valid\n   *\n   * @param {object} propTypes Map of prop name to a ReactPropType\n   * @param {object} props\n   * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n   * @private\n   */\n  _checkPropTypes: function(propTypes, props, location) {\n    // TODO: Stop validating prop types here and only use the element\n    // validation.\n    var componentName = this.getName();\n    for (var propName in propTypes) {\n      if (propTypes.hasOwnProperty(propName)) {\n        var error;\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          (false ? invariant(\n            typeof propTypes[propName] === 'function',\n            '%s: %s type `%s` is invalid; it must be a function, usually ' +\n            'from React.PropTypes.',\n            componentName || 'React class',\n            ReactPropTypeLocationNames[location],\n            propName\n          ) : invariant(typeof propTypes[propName] === 'function'));\n          error = propTypes[propName](props, propName, componentName, location);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error instanceof Error) {\n          // We may want to extend this logic for similar errors in\n          // React.render calls, so I'm abstracting it away into\n          // a function to minimize refactoring in the future\n          var addendum = getDeclarationErrorAddendum(this);\n\n          if (location === ReactPropTypeLocations.prop) {\n            // Preface gives us something to blacklist in warning module\n            (false ? warning(\n              false,\n              'Failed Composite propType: %s%s',\n              error.message,\n              addendum\n            ) : null);\n          } else {\n            (false ? warning(\n              false,\n              'Failed Context Types: %s%s',\n              error.message,\n              addendum\n            ) : null);\n          }\n        }\n      }\n    }\n  },\n\n  receiveComponent: function(nextElement, transaction, nextContext) {\n    var prevElement = this._currentElement;\n    var prevContext = this._context;\n\n    this._pendingElement = null;\n\n    this.updateComponent(\n      transaction,\n      prevElement,\n      nextElement,\n      prevContext,\n      nextContext\n    );\n  },\n\n  /**\n   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`\n   * is set, update the component.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  performUpdateIfNecessary: function(transaction) {\n    if (this._pendingElement != null) {\n      ReactReconciler.receiveComponent(\n        this,\n        this._pendingElement || this._currentElement,\n        transaction,\n        this._context\n      );\n    }\n\n    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {\n      if (false) {\n        ReactElementValidator.checkAndWarnForMutatedProps(\n          this._currentElement\n        );\n      }\n\n      this.updateComponent(\n        transaction,\n        this._currentElement,\n        this._currentElement,\n        this._context,\n        this._context\n      );\n    }\n  },\n\n  /**\n   * Compare two contexts, warning if they are different\n   * TODO: Remove this check when owner-context is removed\n   */\n   _warnIfContextsDiffer: function(ownerBasedContext, parentBasedContext) {\n    ownerBasedContext = this._maskContext(ownerBasedContext);\n    parentBasedContext = this._maskContext(parentBasedContext);\n    var parentKeys = Object.keys(parentBasedContext).sort();\n    var displayName = this.getName() || 'ReactCompositeComponent';\n    for (var i = 0; i < parentKeys.length; i++) {\n      var key = parentKeys[i];\n      (false ? warning(\n        ownerBasedContext[key] === parentBasedContext[key],\n        'owner-based and parent-based contexts differ '  +\n        '(values: `%s` vs `%s`) for key (%s) while mounting %s ' +\n        '(see: http://fb.me/react-context-by-parent)',\n        ownerBasedContext[key],\n        parentBasedContext[key],\n        key,\n        displayName\n      ) : null);\n    }\n  },\n\n  /**\n   * Perform an update to a mounted component. The componentWillReceiveProps and\n   * shouldComponentUpdate methods are called, then (assuming the update isn't\n   * skipped) the remaining update lifecycle methods are called and the DOM\n   * representation is updated.\n   *\n   * By default, this implements React's rendering and reconciliation algorithm.\n   * Sophisticated clients may wish to override this.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @param {ReactElement} prevParentElement\n   * @param {ReactElement} nextParentElement\n   * @internal\n   * @overridable\n   */\n  updateComponent: function(\n    transaction,\n    prevParentElement,\n    nextParentElement,\n    prevUnmaskedContext,\n    nextUnmaskedContext\n  ) {\n    var inst = this._instance;\n\n    var nextContext = inst.context;\n    var nextProps = inst.props;\n\n    // Distinguish between a props update versus a simple state update\n    if (prevParentElement !== nextParentElement) {\n      nextContext = this._processContext(nextParentElement._context);\n      nextProps = this._processProps(nextParentElement.props);\n\n      if (false) {\n        if (nextUnmaskedContext != null) {\n          this._warnIfContextsDiffer(\n            nextParentElement._context,\n            nextUnmaskedContext\n          );\n        }\n      }\n\n      // An update here will schedule an update but immediately set\n      // _pendingStateQueue which will ensure that any state updates gets\n      // immediately reconciled instead of waiting for the next batch.\n\n      if (inst.componentWillReceiveProps) {\n        inst.componentWillReceiveProps(nextProps, nextContext);\n      }\n    }\n\n    var nextState = this._processPendingState(nextProps, nextContext);\n\n    var shouldUpdate =\n      this._pendingForceUpdate ||\n      !inst.shouldComponentUpdate ||\n      inst.shouldComponentUpdate(nextProps, nextState, nextContext);\n\n    if (false) {\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        typeof shouldUpdate !== 'undefined',\n        '%s.shouldComponentUpdate(): Returned undefined instead of a ' +\n        'boolean value. Make sure to return true or false.',\n        this.getName() || 'ReactCompositeComponent'\n      ) : null);\n    }\n\n    if (shouldUpdate) {\n      this._pendingForceUpdate = false;\n      // Will set `this.props`, `this.state` and `this.context`.\n      this._performComponentUpdate(\n        nextParentElement,\n        nextProps,\n        nextState,\n        nextContext,\n        transaction,\n        nextUnmaskedContext\n      );\n    } else {\n      // If it's determined that a component should not update, we still want\n      // to set props and state but we shortcut the rest of the update.\n      this._currentElement = nextParentElement;\n      this._context = nextUnmaskedContext;\n      inst.props = nextProps;\n      inst.state = nextState;\n      inst.context = nextContext;\n    }\n  },\n\n  _processPendingState: function(props, context) {\n    var inst = this._instance;\n    var queue = this._pendingStateQueue;\n    var replace = this._pendingReplaceState;\n    this._pendingReplaceState = false;\n    this._pendingStateQueue = null;\n\n    if (!queue) {\n      return inst.state;\n    }\n\n    if (replace && queue.length === 1) {\n      return queue[0];\n    }\n\n    var nextState = assign({}, replace ? queue[0] : inst.state);\n    for (var i = replace ? 1 : 0; i < queue.length; i++) {\n      var partial = queue[i];\n      assign(\n        nextState,\n        typeof partial === 'function' ?\n          partial.call(inst, nextState, props, context) :\n          partial\n      );\n    }\n\n    return nextState;\n  },\n\n  /**\n   * Merges new props and state, notifies delegate methods of update and\n   * performs update.\n   *\n   * @param {ReactElement} nextElement Next element\n   * @param {object} nextProps Next public object to set as properties.\n   * @param {?object} nextState Next object to set as state.\n   * @param {?object} nextContext Next public object to set as context.\n   * @param {ReactReconcileTransaction} transaction\n   * @param {?object} unmaskedContext\n   * @private\n   */\n  _performComponentUpdate: function(\n    nextElement,\n    nextProps,\n    nextState,\n    nextContext,\n    transaction,\n    unmaskedContext\n  ) {\n    var inst = this._instance;\n\n    var prevProps = inst.props;\n    var prevState = inst.state;\n    var prevContext = inst.context;\n\n    if (inst.componentWillUpdate) {\n      inst.componentWillUpdate(nextProps, nextState, nextContext);\n    }\n\n    this._currentElement = nextElement;\n    this._context = unmaskedContext;\n    inst.props = nextProps;\n    inst.state = nextState;\n    inst.context = nextContext;\n\n    this._updateRenderedComponent(transaction, unmaskedContext);\n\n    if (inst.componentDidUpdate) {\n      transaction.getReactMountReady().enqueue(\n        inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext),\n        inst\n      );\n    }\n  },\n\n  /**\n   * Call the component's `render` method and update the DOM accordingly.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  _updateRenderedComponent: function(transaction, context) {\n    var prevComponentInstance = this._renderedComponent;\n    var prevRenderedElement = prevComponentInstance._currentElement;\n    var childContext = this._getValidatedChildContext();\n    var nextRenderedElement = this._renderValidatedComponent(childContext);\n    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n      ReactReconciler.receiveComponent(\n        prevComponentInstance,\n        nextRenderedElement,\n        transaction,\n        this._mergeChildContext(context, childContext)\n      );\n    } else {\n      // These two IDs are actually the same! But nothing should rely on that.\n      var thisID = this._rootNodeID;\n      var prevComponentID = prevComponentInstance._rootNodeID;\n      ReactReconciler.unmountComponent(prevComponentInstance);\n\n      this._renderedComponent = this._instantiateReactComponent(\n        nextRenderedElement,\n        this._currentElement.type\n      );\n      var nextMarkup = ReactReconciler.mountComponent(\n        this._renderedComponent,\n        thisID,\n        transaction,\n        this._mergeChildContext(context, childContext)\n      );\n      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  _replaceNodeWithMarkupByID: function(prevComponentID, nextMarkup) {\n    ReactComponentEnvironment.replaceNodeWithMarkupByID(\n      prevComponentID,\n      nextMarkup\n    );\n  },\n\n  /**\n   * @protected\n   */\n  _renderValidatedComponentWithoutOwnerOrContext: function() {\n    var inst = this._instance;\n    var renderedComponent = inst.render();\n    if (false) {\n      // We allow auto-mocks to proceed as if they're returning null.\n      if (typeof renderedComponent === 'undefined' &&\n          inst.render._isMockFunction) {\n        // This is probably bad practice. Consider warning here and\n        // deprecating this convenience.\n        renderedComponent = null;\n      }\n    }\n\n    return renderedComponent;\n  },\n\n  /**\n   * @private\n   */\n  _renderValidatedComponent: function(childContext) {\n    var renderedComponent;\n    var previousContext = ReactContext.current;\n    ReactContext.current = this._mergeChildContext(\n      this._currentElement._context,\n      childContext\n    );\n    ReactCurrentOwner.current = this;\n    try {\n      renderedComponent =\n        this._renderValidatedComponentWithoutOwnerOrContext();\n    } finally {\n      ReactContext.current = previousContext;\n      ReactCurrentOwner.current = null;\n    }\n    (false ? invariant(\n      // TODO: An `isValidNode` function would probably be more appropriate\n      renderedComponent === null || renderedComponent === false ||\n      ReactElement.isValidElement(renderedComponent),\n      '%s.render(): A valid ReactComponent must be returned. You may have ' +\n        'returned undefined, an array or some other invalid object.',\n      this.getName() || 'ReactCompositeComponent'\n    ) : invariant(// TODO: An `isValidNode` function would probably be more appropriate\n    renderedComponent === null || renderedComponent === false ||\n    ReactElement.isValidElement(renderedComponent)));\n    return renderedComponent;\n  },\n\n  /**\n   * Lazily allocates the refs object and stores `component` as `ref`.\n   *\n   * @param {string} ref Reference name.\n   * @param {component} component Component to store as `ref`.\n   * @final\n   * @private\n   */\n  attachRef: function(ref, component) {\n    var inst = this.getPublicInstance();\n    var refs = inst.refs === emptyObject ? (inst.refs = {}) : inst.refs;\n    refs[ref] = component.getPublicInstance();\n  },\n\n  /**\n   * Detaches a reference name.\n   *\n   * @param {string} ref Name to dereference.\n   * @final\n   * @private\n   */\n  detachRef: function(ref) {\n    var refs = this.getPublicInstance().refs;\n    delete refs[ref];\n  },\n\n  /**\n   * Get a text description of the component that can be used to identify it\n   * in error messages.\n   * @return {string} The name or null.\n   * @internal\n   */\n  getName: function() {\n    var type = this._currentElement.type;\n    var constructor = this._instance && this._instance.constructor;\n    return (\n      type.displayName || (constructor && constructor.displayName) ||\n      type.name || (constructor && constructor.name) ||\n      null\n    );\n  },\n\n  /**\n   * Get the publicly accessible representation of this component - i.e. what\n   * is exposed by refs and returned by React.render. Can be null for stateless\n   * components.\n   *\n   * @return {ReactComponent} the public component instance.\n   * @internal\n   */\n  getPublicInstance: function() {\n    return this._instance;\n  },\n\n  // Stub\n  _instantiateReactComponent: null\n\n};\n\nReactPerf.measureMethods(\n  ReactCompositeComponentMixin,\n  'ReactCompositeComponent',\n  {\n    mountComponent: 'mountComponent',\n    updateComponent: 'updateComponent',\n    _renderValidatedComponent: '_renderValidatedComponent'\n  }\n);\n\nvar ReactCompositeComponent = {\n\n  Mixin: ReactCompositeComponentMixin\n\n};\n\nmodule.exports = ReactCompositeComponent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactCompositeComponent.js\n ** module id = 140\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactCompositeComponent.js?")},/*!*********************************!*\
  !*** ./~/react/lib/ReactDOM.js ***!
  \*********************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOM\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\nvar ReactElementValidator = __webpack_require__(/*! ./ReactElementValidator */ 32);\n\nvar mapObject = __webpack_require__(/*! ./mapObject */ 198);\n\n/**\n * Create a factory that creates HTML tag elements.\n *\n * @param {string} tag Tag name (e.g. `div`).\n * @private\n */\nfunction createDOMFactory(tag) {\n  if (false) {\n    return ReactElementValidator.createFactory(tag);\n  }\n  return ReactElement.createFactory(tag);\n}\n\n/**\n * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.\n * This is also accessible via `React.DOM`.\n *\n * @public\n */\nvar ReactDOM = mapObject({\n  a: 'a',\n  abbr: 'abbr',\n  address: 'address',\n  area: 'area',\n  article: 'article',\n  aside: 'aside',\n  audio: 'audio',\n  b: 'b',\n  base: 'base',\n  bdi: 'bdi',\n  bdo: 'bdo',\n  big: 'big',\n  blockquote: 'blockquote',\n  body: 'body',\n  br: 'br',\n  button: 'button',\n  canvas: 'canvas',\n  caption: 'caption',\n  cite: 'cite',\n  code: 'code',\n  col: 'col',\n  colgroup: 'colgroup',\n  data: 'data',\n  datalist: 'datalist',\n  dd: 'dd',\n  del: 'del',\n  details: 'details',\n  dfn: 'dfn',\n  dialog: 'dialog',\n  div: 'div',\n  dl: 'dl',\n  dt: 'dt',\n  em: 'em',\n  embed: 'embed',\n  fieldset: 'fieldset',\n  figcaption: 'figcaption',\n  figure: 'figure',\n  footer: 'footer',\n  form: 'form',\n  h1: 'h1',\n  h2: 'h2',\n  h3: 'h3',\n  h4: 'h4',\n  h5: 'h5',\n  h6: 'h6',\n  head: 'head',\n  header: 'header',\n  hr: 'hr',\n  html: 'html',\n  i: 'i',\n  iframe: 'iframe',\n  img: 'img',\n  input: 'input',\n  ins: 'ins',\n  kbd: 'kbd',\n  keygen: 'keygen',\n  label: 'label',\n  legend: 'legend',\n  li: 'li',\n  link: 'link',\n  main: 'main',\n  map: 'map',\n  mark: 'mark',\n  menu: 'menu',\n  menuitem: 'menuitem',\n  meta: 'meta',\n  meter: 'meter',\n  nav: 'nav',\n  noscript: 'noscript',\n  object: 'object',\n  ol: 'ol',\n  optgroup: 'optgroup',\n  option: 'option',\n  output: 'output',\n  p: 'p',\n  param: 'param',\n  picture: 'picture',\n  pre: 'pre',\n  progress: 'progress',\n  q: 'q',\n  rp: 'rp',\n  rt: 'rt',\n  ruby: 'ruby',\n  s: 's',\n  samp: 'samp',\n  script: 'script',\n  section: 'section',\n  select: 'select',\n  small: 'small',\n  source: 'source',\n  span: 'span',\n  strong: 'strong',\n  style: 'style',\n  sub: 'sub',\n  summary: 'summary',\n  sup: 'sup',\n  table: 'table',\n  tbody: 'tbody',\n  td: 'td',\n  textarea: 'textarea',\n  tfoot: 'tfoot',\n  th: 'th',\n  thead: 'thead',\n  time: 'time',\n  title: 'title',\n  tr: 'tr',\n  track: 'track',\n  u: 'u',\n  ul: 'ul',\n  'var': 'var',\n  video: 'video',\n  wbr: 'wbr',\n\n  // SVG\n  circle: 'circle',\n  clipPath: 'clipPath',\n  defs: 'defs',\n  ellipse: 'ellipse',\n  g: 'g',\n  line: 'line',\n  linearGradient: 'linearGradient',\n  mask: 'mask',\n  path: 'path',\n  pattern: 'pattern',\n  polygon: 'polygon',\n  polyline: 'polyline',\n  radialGradient: 'radialGradient',\n  rect: 'rect',\n  stop: 'stop',\n  svg: 'svg',\n  text: 'text',\n  tspan: 'tspan'\n\n}, createDOMFactory);\n\nmodule.exports = ReactDOM;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOM.js\n ** module id = 141\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOM.js?")},/*!***************************************!*\
  !*** ./~/react/lib/ReactDOMButton.js ***!
  \***************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMButton\n */\n\n'use strict';\n\nvar AutoFocusMixin = __webpack_require__(/*! ./AutoFocusMixin */ 37);\nvar ReactBrowserComponentMixin = __webpack_require__(/*! ./ReactBrowserComponentMixin */ 13);\nvar ReactClass = __webpack_require__(/*! ./ReactClass */ 8);\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\n\nvar keyMirror = __webpack_require__(/*! ./keyMirror */ 34);\n\nvar button = ReactElement.createFactory('button');\n\nvar mouseListenerNames = keyMirror({\n  onClick: true,\n  onDoubleClick: true,\n  onMouseDown: true,\n  onMouseMove: true,\n  onMouseUp: true,\n  onClickCapture: true,\n  onDoubleClickCapture: true,\n  onMouseDownCapture: true,\n  onMouseMoveCapture: true,\n  onMouseUpCapture: true\n});\n\n/**\n * Implements a <button> native component that does not receive mouse events\n * when `disabled` is set.\n */\nvar ReactDOMButton = ReactClass.createClass({\n  displayName: 'ReactDOMButton',\n  tagName: 'BUTTON',\n\n  mixins: [AutoFocusMixin, ReactBrowserComponentMixin],\n\n  render: function() {\n    var props = {};\n\n    // Copy the props; except the mouse listeners if we're disabled\n    for (var key in this.props) {\n      if (this.props.hasOwnProperty(key) &&\n          (!this.props.disabled || !mouseListenerNames[key])) {\n        props[key] = this.props[key];\n      }\n    }\n\n    return button(props, this.props.children);\n  }\n\n});\n\nmodule.exports = ReactDOMButton;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMButton.js\n ** module id = 142\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMButton.js?")},/*!*************************************!*\
  !*** ./~/react/lib/ReactDOMForm.js ***!
  \*************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMForm\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(/*! ./EventConstants */ 7);\nvar LocalEventTrapMixin = __webpack_require__(/*! ./LocalEventTrapMixin */ 48);\nvar ReactBrowserComponentMixin = __webpack_require__(/*! ./ReactBrowserComponentMixin */ 13);\nvar ReactClass = __webpack_require__(/*! ./ReactClass */ 8);\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\n\nvar form = ReactElement.createFactory('form');\n\n/**\n * Since onSubmit doesn't bubble OR capture on the top level in IE8, we need\n * to capture it on the <form> element itself. There are lots of hacks we could\n * do to accomplish this, but the most reliable is to make <form> a\n * composite component and use `componentDidMount` to attach the event handlers.\n */\nvar ReactDOMForm = ReactClass.createClass({\n  displayName: 'ReactDOMForm',\n  tagName: 'FORM',\n\n  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],\n\n  render: function() {\n    // TODO: Instead of using `ReactDOM` directly, we should use JSX. However,\n    // `jshint` fails to parse JSX so in order for linting to work in the open\n    // source repo, we need to just use `ReactDOM.form`.\n    return form(this.props);\n  },\n\n  componentDidMount: function() {\n    this.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset');\n    this.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit');\n  }\n});\n\nmodule.exports = ReactDOMForm;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMForm.js\n ** module id = 143\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMForm.js?")},/*!***************************************!*\
  !*** ./~/react/lib/ReactDOMIframe.js ***!
  \***************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMIframe\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(/*! ./EventConstants */ 7);\nvar LocalEventTrapMixin = __webpack_require__(/*! ./LocalEventTrapMixin */ 48);\nvar ReactBrowserComponentMixin = __webpack_require__(/*! ./ReactBrowserComponentMixin */ 13);\nvar ReactClass = __webpack_require__(/*! ./ReactClass */ 8);\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\n\nvar iframe = ReactElement.createFactory('iframe');\n\n/**\n * Since onLoad doesn't bubble OR capture on the top level in IE8, we need to\n * capture it on the <iframe> element itself. There are lots of hacks we could\n * do to accomplish this, but the most reliable is to make <iframe> a composite\n * component and use `componentDidMount` to attach the event handlers.\n */\nvar ReactDOMIframe = ReactClass.createClass({\n  displayName: 'ReactDOMIframe',\n  tagName: 'IFRAME',\n\n  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],\n\n  render: function() {\n    return iframe(this.props);\n  },\n\n  componentDidMount: function() {\n    this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load');\n  }\n});\n\nmodule.exports = ReactDOMIframe;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMIframe.js\n ** module id = 144\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMIframe.js?")},/*!************************************!*\
  !*** ./~/react/lib/ReactDOMImg.js ***!
  \************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMImg\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(/*! ./EventConstants */ 7);\nvar LocalEventTrapMixin = __webpack_require__(/*! ./LocalEventTrapMixin */ 48);\nvar ReactBrowserComponentMixin = __webpack_require__(/*! ./ReactBrowserComponentMixin */ 13);\nvar ReactClass = __webpack_require__(/*! ./ReactClass */ 8);\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\n\nvar img = ReactElement.createFactory('img');\n\n/**\n * Since onLoad doesn't bubble OR capture on the top level in IE8, we need to\n * capture it on the <img> element itself. There are lots of hacks we could do\n * to accomplish this, but the most reliable is to make <img> a composite\n * component and use `componentDidMount` to attach the event handlers.\n */\nvar ReactDOMImg = ReactClass.createClass({\n  displayName: 'ReactDOMImg',\n  tagName: 'IMG',\n\n  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],\n\n  render: function() {\n    return img(this.props);\n  },\n\n  componentDidMount: function() {\n    this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load');\n    this.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error');\n  }\n});\n\nmodule.exports = ReactDOMImg;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMImg.js\n ** module id = 145\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMImg.js?")},/*!**************************************!*\
  !*** ./~/react/lib/ReactDOMInput.js ***!
  \**************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMInput\n */\n\n'use strict';\n\nvar AutoFocusMixin = __webpack_require__(/*! ./AutoFocusMixin */ 37);\nvar DOMPropertyOperations = __webpack_require__(/*! ./DOMPropertyOperations */ 29);\nvar LinkedValueUtils = __webpack_require__(/*! ./LinkedValueUtils */ 47);\nvar ReactBrowserComponentMixin = __webpack_require__(/*! ./ReactBrowserComponentMixin */ 13);\nvar ReactClass = __webpack_require__(/*! ./ReactClass */ 8);\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\nvar ReactMount = __webpack_require__(/*! ./ReactMount */ 15);\nvar ReactUpdates = __webpack_require__(/*! ./ReactUpdates */ 9);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\nvar input = ReactElement.createFactory('input');\n\nvar instancesByReactID = {};\n\nfunction forceUpdateIfMounted() {\n  /*jshint validthis:true */\n  if (this.isMounted()) {\n    this.forceUpdate();\n  }\n}\n\n/**\n * Implements an <input> native component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */\nvar ReactDOMInput = ReactClass.createClass({\n  displayName: 'ReactDOMInput',\n  tagName: 'INPUT',\n\n  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],\n\n  getInitialState: function() {\n    var defaultValue = this.props.defaultValue;\n    return {\n      initialChecked: this.props.defaultChecked || false,\n      initialValue: defaultValue != null ? defaultValue : null\n    };\n  },\n\n  render: function() {\n    // Clone `this.props` so we don't mutate the input.\n    var props = assign({}, this.props);\n\n    props.defaultChecked = null;\n    props.defaultValue = null;\n\n    var value = LinkedValueUtils.getValue(this);\n    props.value = value != null ? value : this.state.initialValue;\n\n    var checked = LinkedValueUtils.getChecked(this);\n    props.checked = checked != null ? checked : this.state.initialChecked;\n\n    props.onChange = this._handleChange;\n\n    return input(props, this.props.children);\n  },\n\n  componentDidMount: function() {\n    var id = ReactMount.getID(this.getDOMNode());\n    instancesByReactID[id] = this;\n  },\n\n  componentWillUnmount: function() {\n    var rootNode = this.getDOMNode();\n    var id = ReactMount.getID(rootNode);\n    delete instancesByReactID[id];\n  },\n\n  componentDidUpdate: function(prevProps, prevState, prevContext) {\n    var rootNode = this.getDOMNode();\n    if (this.props.checked != null) {\n      DOMPropertyOperations.setValueForProperty(\n        rootNode,\n        'checked',\n        this.props.checked || false\n      );\n    }\n\n    var value = LinkedValueUtils.getValue(this);\n    if (value != null) {\n      // Cast `value` to a string to ensure the value is set correctly. While\n      // browsers typically do this as necessary, jsdom doesn't.\n      DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);\n    }\n  },\n\n  _handleChange: function(event) {\n    var returnValue;\n    var onChange = LinkedValueUtils.getOnChange(this);\n    if (onChange) {\n      returnValue = onChange.call(this, event);\n    }\n    // Here we use asap to wait until all updates have propagated, which\n    // is important when using controlled components within layers:\n    // https://github.com/facebook/react/issues/1698\n    ReactUpdates.asap(forceUpdateIfMounted, this);\n\n    var name = this.props.name;\n    if (this.props.type === 'radio' && name != null) {\n      var rootNode = this.getDOMNode();\n      var queryRoot = rootNode;\n\n      while (queryRoot.parentNode) {\n        queryRoot = queryRoot.parentNode;\n      }\n\n      // If `rootNode.form` was non-null, then we could try `form.elements`,\n      // but that sometimes behaves strangely in IE8. We could also try using\n      // `form.getElementsByName`, but that will only return direct children\n      // and won't include inputs that use the HTML5 `form=` attribute. Since\n      // the input might not even be in a form, let's just use the global\n      // `querySelectorAll` to ensure we don't miss anything.\n      var group = queryRoot.querySelectorAll(\n        'input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]');\n\n      for (var i = 0, groupLen = group.length; i < groupLen; i++) {\n        var otherNode = group[i];\n        if (otherNode === rootNode ||\n            otherNode.form !== rootNode.form) {\n          continue;\n        }\n        var otherID = ReactMount.getID(otherNode);\n        (false ? invariant(\n          otherID,\n          'ReactDOMInput: Mixing React and non-React radio inputs with the ' +\n          'same `name` is not supported.'\n        ) : invariant(otherID));\n        var otherInstance = instancesByReactID[otherID];\n        (false ? invariant(\n          otherInstance,\n          'ReactDOMInput: Unknown radio button ID %s.',\n          otherID\n        ) : invariant(otherInstance));\n        // If this is a controlled radio button group, forcing the input that\n        // was previously checked to update will cause it to be come re-checked\n        // as appropriate.\n        ReactUpdates.asap(forceUpdateIfMounted, otherInstance);\n      }\n    }\n\n    return returnValue;\n  }\n\n});\n\nmodule.exports = ReactDOMInput;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMInput.js\n ** module id = 146\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMInput.js?")},/*!***************************************!*\
  !*** ./~/react/lib/ReactDOMOption.js ***!
  \***************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMOption\n */\n\n'use strict';\n\nvar ReactBrowserComponentMixin = __webpack_require__(/*! ./ReactBrowserComponentMixin */ 13);\nvar ReactClass = __webpack_require__(/*! ./ReactClass */ 8);\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\n\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nvar option = ReactElement.createFactory('option');\n\n/**\n * Implements an <option> native component that warns when `selected` is set.\n */\nvar ReactDOMOption = ReactClass.createClass({\n  displayName: 'ReactDOMOption',\n  tagName: 'OPTION',\n\n  mixins: [ReactBrowserComponentMixin],\n\n  componentWillMount: function() {\n    // TODO (yungsters): Remove support for `selected` in <option>.\n    if (false) {\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        this.props.selected == null,\n        'Use the `defaultValue` or `value` props on <select> instead of ' +\n        'setting `selected` on <option>.'\n      ) : null);\n    }\n  },\n\n  render: function() {\n    return option(this.props, this.props.children);\n  }\n\n});\n\nmodule.exports = ReactDOMOption;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMOption.js\n ** module id = 147\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMOption.js?")},/*!***************************************!*\
  !*** ./~/react/lib/ReactDOMSelect.js ***!
  \***************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMSelect\n */\n\n'use strict';\n\nvar AutoFocusMixin = __webpack_require__(/*! ./AutoFocusMixin */ 37);\nvar LinkedValueUtils = __webpack_require__(/*! ./LinkedValueUtils */ 47);\nvar ReactBrowserComponentMixin = __webpack_require__(/*! ./ReactBrowserComponentMixin */ 13);\nvar ReactClass = __webpack_require__(/*! ./ReactClass */ 8);\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\nvar ReactUpdates = __webpack_require__(/*! ./ReactUpdates */ 9);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\n\nvar select = ReactElement.createFactory('select');\n\nfunction updateOptionsIfPendingUpdateAndMounted() {\n  /*jshint validthis:true */\n  if (this._pendingUpdate) {\n    this._pendingUpdate = false;\n    var value = LinkedValueUtils.getValue(this);\n    if (value != null && this.isMounted()) {\n      updateOptions(this, value);\n    }\n  }\n}\n\n/**\n * Validation function for `value` and `defaultValue`.\n * @private\n */\nfunction selectValueType(props, propName, componentName) {\n  if (props[propName] == null) {\n    return null;\n  }\n  if (props.multiple) {\n    if (!Array.isArray(props[propName])) {\n      return new Error(\n        (\"The `\" + propName + \"` prop supplied to <select> must be an array if \") +\n        (\"`multiple` is true.\")\n      );\n    }\n  } else {\n    if (Array.isArray(props[propName])) {\n      return new Error(\n        (\"The `\" + propName + \"` prop supplied to <select> must be a scalar \") +\n        (\"value if `multiple` is false.\")\n      );\n    }\n  }\n}\n\n/**\n * @param {ReactComponent} component Instance of ReactDOMSelect\n * @param {*} propValue A stringable (with `multiple`, a list of stringables).\n * @private\n */\nfunction updateOptions(component, propValue) {\n  var selectedValue, i, l;\n  var options = component.getDOMNode().options;\n\n  if (component.props.multiple) {\n    selectedValue = {};\n    for (i = 0, l = propValue.length; i < l; i++) {\n      selectedValue['' + propValue[i]] = true;\n    }\n    for (i = 0, l = options.length; i < l; i++) {\n      var selected = selectedValue.hasOwnProperty(options[i].value);\n      if (options[i].selected !== selected) {\n        options[i].selected = selected;\n      }\n    }\n  } else {\n    // Do not set `select.value` as exact behavior isn't consistent across all\n    // browsers for all cases.\n    selectedValue = '' + propValue;\n    for (i = 0, l = options.length; i < l; i++) {\n      if (options[i].value === selectedValue) {\n        options[i].selected = true;\n        return;\n      }\n    }\n    if (options.length) {\n      options[0].selected = true;\n    }\n  }\n}\n\n/**\n * Implements a <select> native component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */\nvar ReactDOMSelect = ReactClass.createClass({\n  displayName: 'ReactDOMSelect',\n  tagName: 'SELECT',\n\n  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],\n\n  propTypes: {\n    defaultValue: selectValueType,\n    value: selectValueType\n  },\n\n  render: function() {\n    // Clone `this.props` so we don't mutate the input.\n    var props = assign({}, this.props);\n\n    props.onChange = this._handleChange;\n    props.value = null;\n\n    return select(props, this.props.children);\n  },\n\n  componentWillMount: function() {\n    this._pendingUpdate = false;\n  },\n\n  componentDidMount: function() {\n    var value = LinkedValueUtils.getValue(this);\n    if (value != null) {\n      updateOptions(this, value);\n    } else if (this.props.defaultValue != null) {\n      updateOptions(this, this.props.defaultValue);\n    }\n  },\n\n  componentDidUpdate: function(prevProps) {\n    var value = LinkedValueUtils.getValue(this);\n    if (value != null) {\n      this._pendingUpdate = false;\n      updateOptions(this, value);\n    } else if (!prevProps.multiple !== !this.props.multiple) {\n      // For simplicity, reapply `defaultValue` if `multiple` is toggled.\n      if (this.props.defaultValue != null) {\n        updateOptions(this, this.props.defaultValue);\n      } else {\n        // Revert the select back to its default unselected state.\n        updateOptions(this, this.props.multiple ? [] : '');\n      }\n    }\n  },\n\n  _handleChange: function(event) {\n    var returnValue;\n    var onChange = LinkedValueUtils.getOnChange(this);\n    if (onChange) {\n      returnValue = onChange.call(this, event);\n    }\n\n    this._pendingUpdate = true;\n    ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);\n    return returnValue;\n  }\n\n});\n\nmodule.exports = ReactDOMSelect;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMSelect.js\n ** module id = 148\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMSelect.js?")},/*!******************************************!*\
  !*** ./~/react/lib/ReactDOMSelection.js ***!
  \******************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMSelection\n */\n\n'use strict';\n\nvar ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ 6);\n\nvar getNodeForCharacterOffset = __webpack_require__(/*! ./getNodeForCharacterOffset */ 191);\nvar getTextContentAccessor = __webpack_require__(/*! ./getTextContentAccessor */ 93);\n\n/**\n * While `isCollapsed` is available on the Selection object and `collapsed`\n * is available on the Range object, IE11 sometimes gets them wrong.\n * If the anchor/focus nodes and offsets are the same, the range is collapsed.\n */\nfunction isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {\n  return anchorNode === focusNode && anchorOffset === focusOffset;\n}\n\n/**\n * Get the appropriate anchor and focus node/offset pairs for IE.\n *\n * The catch here is that IE's selection API doesn't provide information\n * about whether the selection is forward or backward, so we have to\n * behave as though it's always forward.\n *\n * IE text differs from modern selection in that it behaves as though\n * block elements end with a new line. This means character offsets will\n * differ between the two APIs.\n *\n * @param {DOMElement} node\n * @return {object}\n */\nfunction getIEOffsets(node) {\n  var selection = document.selection;\n  var selectedRange = selection.createRange();\n  var selectedLength = selectedRange.text.length;\n\n  // Duplicate selection so we can move range without breaking user selection.\n  var fromStart = selectedRange.duplicate();\n  fromStart.moveToElementText(node);\n  fromStart.setEndPoint('EndToStart', selectedRange);\n\n  var startOffset = fromStart.text.length;\n  var endOffset = startOffset + selectedLength;\n\n  return {\n    start: startOffset,\n    end: endOffset\n  };\n}\n\n/**\n * @param {DOMElement} node\n * @return {?object}\n */\nfunction getModernOffsets(node) {\n  var selection = window.getSelection && window.getSelection();\n\n  if (!selection || selection.rangeCount === 0) {\n    return null;\n  }\n\n  var anchorNode = selection.anchorNode;\n  var anchorOffset = selection.anchorOffset;\n  var focusNode = selection.focusNode;\n  var focusOffset = selection.focusOffset;\n\n  var currentRange = selection.getRangeAt(0);\n\n  // If the node and offset values are the same, the selection is collapsed.\n  // `Selection.isCollapsed` is available natively, but IE sometimes gets\n  // this value wrong.\n  var isSelectionCollapsed = isCollapsed(\n    selection.anchorNode,\n    selection.anchorOffset,\n    selection.focusNode,\n    selection.focusOffset\n  );\n\n  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;\n\n  var tempRange = currentRange.cloneRange();\n  tempRange.selectNodeContents(node);\n  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);\n\n  var isTempRangeCollapsed = isCollapsed(\n    tempRange.startContainer,\n    tempRange.startOffset,\n    tempRange.endContainer,\n    tempRange.endOffset\n  );\n\n  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;\n  var end = start + rangeLength;\n\n  // Detect whether the selection is backward.\n  var detectionRange = document.createRange();\n  detectionRange.setStart(anchorNode, anchorOffset);\n  detectionRange.setEnd(focusNode, focusOffset);\n  var isBackward = detectionRange.collapsed;\n\n  return {\n    start: isBackward ? end : start,\n    end: isBackward ? start : end\n  };\n}\n\n/**\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nfunction setIEOffsets(node, offsets) {\n  var range = document.selection.createRange().duplicate();\n  var start, end;\n\n  if (typeof offsets.end === 'undefined') {\n    start = offsets.start;\n    end = start;\n  } else if (offsets.start > offsets.end) {\n    start = offsets.end;\n    end = offsets.start;\n  } else {\n    start = offsets.start;\n    end = offsets.end;\n  }\n\n  range.moveToElementText(node);\n  range.moveStart('character', start);\n  range.setEndPoint('EndToStart', range);\n  range.moveEnd('character', end - start);\n  range.select();\n}\n\n/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nfunction setModernOffsets(node, offsets) {\n  if (!window.getSelection) {\n    return;\n  }\n\n  var selection = window.getSelection();\n  var length = node[getTextContentAccessor()].length;\n  var start = Math.min(offsets.start, length);\n  var end = typeof offsets.end === 'undefined' ?\n            start : Math.min(offsets.end, length);\n\n  // IE 11 uses modern selection, but doesn't support the extend method.\n  // Flip backward selections, so we can set with a single range.\n  if (!selection.extend && start > end) {\n    var temp = end;\n    end = start;\n    start = temp;\n  }\n\n  var startMarker = getNodeForCharacterOffset(node, start);\n  var endMarker = getNodeForCharacterOffset(node, end);\n\n  if (startMarker && endMarker) {\n    var range = document.createRange();\n    range.setStart(startMarker.node, startMarker.offset);\n    selection.removeAllRanges();\n\n    if (start > end) {\n      selection.addRange(range);\n      selection.extend(endMarker.node, endMarker.offset);\n    } else {\n      range.setEnd(endMarker.node, endMarker.offset);\n      selection.addRange(range);\n    }\n  }\n}\n\nvar useIEOffsets = (\n  ExecutionEnvironment.canUseDOM &&\n  'selection' in document &&\n  !('getSelection' in window)\n);\n\nvar ReactDOMSelection = {\n  /**\n   * @param {DOMElement} node\n   */\n  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,\n\n  /**\n   * @param {DOMElement|DOMTextNode} node\n   * @param {object} offsets\n   */\n  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets\n};\n\nmodule.exports = ReactDOMSelection;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMSelection.js\n ** module id = 149\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMSelection.js?")},/*!*****************************************!*\
  !*** ./~/react/lib/ReactDOMTextarea.js ***!
  \*****************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMTextarea\n */\n\n'use strict';\n\nvar AutoFocusMixin = __webpack_require__(/*! ./AutoFocusMixin */ 37);\nvar DOMPropertyOperations = __webpack_require__(/*! ./DOMPropertyOperations */ 29);\nvar LinkedValueUtils = __webpack_require__(/*! ./LinkedValueUtils */ 47);\nvar ReactBrowserComponentMixin = __webpack_require__(/*! ./ReactBrowserComponentMixin */ 13);\nvar ReactClass = __webpack_require__(/*! ./ReactClass */ 8);\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\nvar ReactUpdates = __webpack_require__(/*! ./ReactUpdates */ 9);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nvar textarea = ReactElement.createFactory('textarea');\n\nfunction forceUpdateIfMounted() {\n  /*jshint validthis:true */\n  if (this.isMounted()) {\n    this.forceUpdate();\n  }\n}\n\n/**\n * Implements a <textarea> native component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */\nvar ReactDOMTextarea = ReactClass.createClass({\n  displayName: 'ReactDOMTextarea',\n  tagName: 'TEXTAREA',\n\n  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],\n\n  getInitialState: function() {\n    var defaultValue = this.props.defaultValue;\n    // TODO (yungsters): Remove support for children content in <textarea>.\n    var children = this.props.children;\n    if (children != null) {\n      if (false) {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          false,\n          'Use the `defaultValue` or `value` props instead of setting ' +\n          'children on <textarea>.'\n        ) : null);\n      }\n      (false ? invariant(\n        defaultValue == null,\n        'If you supply `defaultValue` on a <textarea>, do not pass children.'\n      ) : invariant(defaultValue == null));\n      if (Array.isArray(children)) {\n        (false ? invariant(\n          children.length <= 1,\n          '<textarea> can only have at most one child.'\n        ) : invariant(children.length <= 1));\n        children = children[0];\n      }\n\n      defaultValue = '' + children;\n    }\n    if (defaultValue == null) {\n      defaultValue = '';\n    }\n    var value = LinkedValueUtils.getValue(this);\n    return {\n      // We save the initial value so that `ReactDOMComponent` doesn't update\n      // `textContent` (unnecessary since we update value).\n      // The initial value can be a boolean or object so that's why it's\n      // forced to be a string.\n      initialValue: '' + (value != null ? value : defaultValue)\n    };\n  },\n\n  render: function() {\n    // Clone `this.props` so we don't mutate the input.\n    var props = assign({}, this.props);\n\n    (false ? invariant(\n      props.dangerouslySetInnerHTML == null,\n      '`dangerouslySetInnerHTML` does not make sense on <textarea>.'\n    ) : invariant(props.dangerouslySetInnerHTML == null));\n\n    props.defaultValue = null;\n    props.value = null;\n    props.onChange = this._handleChange;\n\n    // Always set children to the same thing. In IE9, the selection range will\n    // get reset if `textContent` is mutated.\n    return textarea(props, this.state.initialValue);\n  },\n\n  componentDidUpdate: function(prevProps, prevState, prevContext) {\n    var value = LinkedValueUtils.getValue(this);\n    if (value != null) {\n      var rootNode = this.getDOMNode();\n      // Cast `value` to a string to ensure the value is set correctly. While\n      // browsers typically do this as necessary, jsdom doesn't.\n      DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);\n    }\n  },\n\n  _handleChange: function(event) {\n    var returnValue;\n    var onChange = LinkedValueUtils.getOnChange(this);\n    if (onChange) {\n      returnValue = onChange.call(this, event);\n    }\n    ReactUpdates.asap(forceUpdateIfMounted, this);\n    return returnValue;\n  }\n\n});\n\nmodule.exports = ReactDOMTextarea;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMTextarea.js\n ** module id = 150\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMTextarea.js?")},/*!*****************************************************!*\
  !*** ./~/react/lib/ReactDefaultBatchingStrategy.js ***!
  \*****************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDefaultBatchingStrategy\n */\n\n'use strict';\n\nvar ReactUpdates = __webpack_require__(/*! ./ReactUpdates */ 9);\nvar Transaction = __webpack_require__(/*! ./Transaction */ 41);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar emptyFunction = __webpack_require__(/*! ./emptyFunction */ 10);\n\nvar RESET_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: function() {\n    ReactDefaultBatchingStrategy.isBatchingUpdates = false;\n  }\n};\n\nvar FLUSH_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)\n};\n\nvar TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];\n\nfunction ReactDefaultBatchingStrategyTransaction() {\n  this.reinitializeTransaction();\n}\n\nassign(\n  ReactDefaultBatchingStrategyTransaction.prototype,\n  Transaction.Mixin,\n  {\n    getTransactionWrappers: function() {\n      return TRANSACTION_WRAPPERS;\n    }\n  }\n);\n\nvar transaction = new ReactDefaultBatchingStrategyTransaction();\n\nvar ReactDefaultBatchingStrategy = {\n  isBatchingUpdates: false,\n\n  /**\n   * Call the provided function in a context within which calls to `setState`\n   * and friends are batched such that components aren't updated unnecessarily.\n   */\n  batchedUpdates: function(callback, a, b, c, d) {\n    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;\n\n    ReactDefaultBatchingStrategy.isBatchingUpdates = true;\n\n    // The code is written this way to avoid extra allocations\n    if (alreadyBatchingUpdates) {\n      callback(a, b, c, d);\n    } else {\n      transaction.perform(callback, null, a, b, c, d);\n    }\n  }\n};\n\nmodule.exports = ReactDefaultBatchingStrategy;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDefaultBatchingStrategy.js\n ** module id = 151\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDefaultBatchingStrategy.js?")},/*!**********************************************!*\
  !*** ./~/react/lib/ReactDefaultInjection.js ***!
  \**********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDefaultInjection\n */\n\n'use strict';\n\nvar BeforeInputEventPlugin = __webpack_require__(/*! ./BeforeInputEventPlugin */ 123);\nvar ChangeEventPlugin = __webpack_require__(/*! ./ChangeEventPlugin */ 125);\nvar ClientReactRootIndex = __webpack_require__(/*! ./ClientReactRootIndex */ 126);\nvar DefaultEventPluginOrder = __webpack_require__(/*! ./DefaultEventPluginOrder */ 129);\nvar EnterLeaveEventPlugin = __webpack_require__(/*! ./EnterLeaveEventPlugin */ 130);\nvar ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ 6);\nvar HTMLDOMPropertyConfig = __webpack_require__(/*! ./HTMLDOMPropertyConfig */ 133);\nvar MobileSafariClickEventPlugin = __webpack_require__(/*! ./MobileSafariClickEventPlugin */ 135);\nvar ReactBrowserComponentMixin = __webpack_require__(/*! ./ReactBrowserComponentMixin */ 13);\nvar ReactClass = __webpack_require__(/*! ./ReactClass */ 8);\nvar ReactComponentBrowserEnvironment =\n  __webpack_require__(/*! ./ReactComponentBrowserEnvironment */ 49);\nvar ReactDefaultBatchingStrategy = __webpack_require__(/*! ./ReactDefaultBatchingStrategy */ 151);\nvar ReactDOMComponent = __webpack_require__(/*! ./ReactDOMComponent */ 52);\nvar ReactDOMButton = __webpack_require__(/*! ./ReactDOMButton */ 142);\nvar ReactDOMForm = __webpack_require__(/*! ./ReactDOMForm */ 143);\nvar ReactDOMImg = __webpack_require__(/*! ./ReactDOMImg */ 145);\nvar ReactDOMIDOperations = __webpack_require__(/*! ./ReactDOMIDOperations */ 76);\nvar ReactDOMIframe = __webpack_require__(/*! ./ReactDOMIframe */ 144);\nvar ReactDOMInput = __webpack_require__(/*! ./ReactDOMInput */ 146);\nvar ReactDOMOption = __webpack_require__(/*! ./ReactDOMOption */ 147);\nvar ReactDOMSelect = __webpack_require__(/*! ./ReactDOMSelect */ 148);\nvar ReactDOMTextarea = __webpack_require__(/*! ./ReactDOMTextarea */ 150);\nvar ReactDOMTextComponent = __webpack_require__(/*! ./ReactDOMTextComponent */ 77);\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\nvar ReactEventListener = __webpack_require__(/*! ./ReactEventListener */ 155);\nvar ReactInjection = __webpack_require__(/*! ./ReactInjection */ 156);\nvar ReactInstanceHandles = __webpack_require__(/*! ./ReactInstanceHandles */ 23);\nvar ReactMount = __webpack_require__(/*! ./ReactMount */ 15);\nvar ReactReconcileTransaction = __webpack_require__(/*! ./ReactReconcileTransaction */ 161);\nvar SelectEventPlugin = __webpack_require__(/*! ./SelectEventPlugin */ 170);\nvar ServerReactRootIndex = __webpack_require__(/*! ./ServerReactRootIndex */ 171);\nvar SimpleEventPlugin = __webpack_require__(/*! ./SimpleEventPlugin */ 172);\nvar SVGDOMPropertyConfig = __webpack_require__(/*! ./SVGDOMPropertyConfig */ 169);\n\nvar createFullPageComponent = __webpack_require__(/*! ./createFullPageComponent */ 185);\n\nfunction autoGenerateWrapperClass(type) {\n  return ReactClass.createClass({\n    tagName: type.toUpperCase(),\n    render: function() {\n      return new ReactElement(\n        type,\n        null,\n        null,\n        null,\n        null,\n        this.props\n      );\n    }\n  });\n}\n\nfunction inject() {\n  ReactInjection.EventEmitter.injectReactEventListener(\n    ReactEventListener\n  );\n\n  /**\n   * Inject modules for resolving DOM hierarchy and plugin ordering.\n   */\n  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);\n  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);\n  ReactInjection.EventPluginHub.injectMount(ReactMount);\n\n  /**\n   * Some important event plugins included by default (without having to require\n   * them).\n   */\n  ReactInjection.EventPluginHub.injectEventPluginsByName({\n    SimpleEventPlugin: SimpleEventPlugin,\n    EnterLeaveEventPlugin: EnterLeaveEventPlugin,\n    ChangeEventPlugin: ChangeEventPlugin,\n    MobileSafariClickEventPlugin: MobileSafariClickEventPlugin,\n    SelectEventPlugin: SelectEventPlugin,\n    BeforeInputEventPlugin: BeforeInputEventPlugin\n  });\n\n  ReactInjection.NativeComponent.injectGenericComponentClass(\n    ReactDOMComponent\n  );\n\n  ReactInjection.NativeComponent.injectTextComponentClass(\n    ReactDOMTextComponent\n  );\n\n  ReactInjection.NativeComponent.injectAutoWrapper(\n    autoGenerateWrapperClass\n  );\n\n  // This needs to happen before createFullPageComponent() otherwise the mixin\n  // won't be included.\n  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);\n\n  ReactInjection.NativeComponent.injectComponentClasses({\n    'button': ReactDOMButton,\n    'form': ReactDOMForm,\n    'iframe': ReactDOMIframe,\n    'img': ReactDOMImg,\n    'input': ReactDOMInput,\n    'option': ReactDOMOption,\n    'select': ReactDOMSelect,\n    'textarea': ReactDOMTextarea,\n\n    'html': createFullPageComponent('html'),\n    'head': createFullPageComponent('head'),\n    'body': createFullPageComponent('body')\n  });\n\n  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);\n  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);\n\n  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');\n\n  ReactInjection.Updates.injectReconcileTransaction(\n    ReactReconcileTransaction\n  );\n  ReactInjection.Updates.injectBatchingStrategy(\n    ReactDefaultBatchingStrategy\n  );\n\n  ReactInjection.RootIndex.injectCreateReactRootIndex(\n    ExecutionEnvironment.canUseDOM ?\n      ClientReactRootIndex.createReactRootIndex :\n      ServerReactRootIndex.createReactRootIndex\n  );\n\n  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);\n  ReactInjection.DOMComponent.injectIDOperations(ReactDOMIDOperations);\n\n  if (false) {\n    var url = (ExecutionEnvironment.canUseDOM && window.location.href) || '';\n    if ((/[?&]react_perf\\b/).test(url)) {\n      var ReactDefaultPerf = require(\"./ReactDefaultPerf\");\n      ReactDefaultPerf.start();\n    }\n  }\n}\n\nmodule.exports = {\n  inject: inject\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDefaultInjection.js\n ** module id = 152\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDefaultInjection.js?")},/*!****************************************!*\
  !*** ./~/react/lib/ReactErrorUtils.js ***!
  \****************************************/
function(module,exports){eval('/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactErrorUtils\n * @typechecks\n */\n\n"use strict";\n\nvar ReactErrorUtils = {\n  /**\n   * Creates a guarded version of a function. This is supposed to make debugging\n   * of event handlers easier. To aid debugging with the browser\'s debugger,\n   * this currently simply returns the original function.\n   *\n   * @param {function} func Function to be executed\n   * @param {string} name The name of the guard\n   * @return {function}\n   */\n  guard: function(func, name) {\n    return func;\n  }\n};\n\nmodule.exports = ReactErrorUtils;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactErrorUtils.js\n ** module id = 153\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactErrorUtils.js?')},/*!***********************************************!*\
  !*** ./~/react/lib/ReactEventEmitterMixin.js ***!
  \***********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactEventEmitterMixin\n */\n\n'use strict';\n\nvar EventPluginHub = __webpack_require__(/*! ./EventPluginHub */ 30);\n\nfunction runEventQueueInBatch(events) {\n  EventPluginHub.enqueueEvents(events);\n  EventPluginHub.processEventQueue();\n}\n\nvar ReactEventEmitterMixin = {\n\n  /**\n   * Streams a fired top-level event to `EventPluginHub` where plugins have the\n   * opportunity to create `ReactEvent`s to be dispatched.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {object} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native environment event.\n   */\n  handleTopLevel: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n    var events = EventPluginHub.extractEvents(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent\n    );\n\n    runEventQueueInBatch(events);\n  }\n};\n\nmodule.exports = ReactEventEmitterMixin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactEventEmitterMixin.js\n ** module id = 154\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactEventEmitterMixin.js?")},/*!*******************************************!*\
  !*** ./~/react/lib/ReactEventListener.js ***!
  \*******************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactEventListener\n * @typechecks static-only\n */\n\n'use strict';\n\nvar EventListener = __webpack_require__(/*! ./EventListener */ 131);\nvar ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ 6);\nvar PooledClass = __webpack_require__(/*! ./PooledClass */ 12);\nvar ReactInstanceHandles = __webpack_require__(/*! ./ReactInstanceHandles */ 23);\nvar ReactMount = __webpack_require__(/*! ./ReactMount */ 15);\nvar ReactUpdates = __webpack_require__(/*! ./ReactUpdates */ 9);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar getEventTarget = __webpack_require__(/*! ./getEventTarget */ 61);\nvar getUnboundedScrollPosition = __webpack_require__(/*! ./getUnboundedScrollPosition */ 193);\n\n/**\n * Finds the parent React component of `node`.\n *\n * @param {*} node\n * @return {?DOMEventTarget} Parent container, or `null` if the specified node\n *                           is not nested.\n */\nfunction findParent(node) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  var nodeID = ReactMount.getID(node);\n  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);\n  var container = ReactMount.findReactContainerForID(rootID);\n  var parent = ReactMount.getFirstReactDOM(container);\n  return parent;\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {\n  this.topLevelType = topLevelType;\n  this.nativeEvent = nativeEvent;\n  this.ancestors = [];\n}\nassign(TopLevelCallbackBookKeeping.prototype, {\n  destructor: function() {\n    this.topLevelType = null;\n    this.nativeEvent = null;\n    this.ancestors.length = 0;\n  }\n});\nPooledClass.addPoolingTo(\n  TopLevelCallbackBookKeeping,\n  PooledClass.twoArgumentPooler\n);\n\nfunction handleTopLevelImpl(bookKeeping) {\n  var topLevelTarget = ReactMount.getFirstReactDOM(\n    getEventTarget(bookKeeping.nativeEvent)\n  ) || window;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  var ancestor = topLevelTarget;\n  while (ancestor) {\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = findParent(ancestor);\n  }\n\n  for (var i = 0, l = bookKeeping.ancestors.length; i < l; i++) {\n    topLevelTarget = bookKeeping.ancestors[i];\n    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';\n    ReactEventListener._handleTopLevel(\n      bookKeeping.topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      bookKeeping.nativeEvent\n    );\n  }\n}\n\nfunction scrollValueMonitor(cb) {\n  var scrollPosition = getUnboundedScrollPosition(window);\n  cb(scrollPosition);\n}\n\nvar ReactEventListener = {\n  _enabled: true,\n  _handleTopLevel: null,\n\n  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,\n\n  setHandleTopLevel: function(handleTopLevel) {\n    ReactEventListener._handleTopLevel = handleTopLevel;\n  },\n\n  setEnabled: function(enabled) {\n    ReactEventListener._enabled = !!enabled;\n  },\n\n  isEnabled: function() {\n    return ReactEventListener._enabled;\n  },\n\n\n  /**\n   * Traps top-level events by using event bubbling.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} handle Element on which to attach listener.\n   * @return {object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {\n    var element = handle;\n    if (!element) {\n      return null;\n    }\n    return EventListener.listen(\n      element,\n      handlerBaseName,\n      ReactEventListener.dispatchEvent.bind(null, topLevelType)\n    );\n  },\n\n  /**\n   * Traps a top-level event by using event capturing.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} handle Element on which to attach listener.\n   * @return {object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {\n    var element = handle;\n    if (!element) {\n      return null;\n    }\n    return EventListener.capture(\n      element,\n      handlerBaseName,\n      ReactEventListener.dispatchEvent.bind(null, topLevelType)\n    );\n  },\n\n  monitorScrollValue: function(refresh) {\n    var callback = scrollValueMonitor.bind(null, refresh);\n    EventListener.listen(window, 'scroll', callback);\n  },\n\n  dispatchEvent: function(topLevelType, nativeEvent) {\n    if (!ReactEventListener._enabled) {\n      return;\n    }\n\n    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(\n      topLevelType,\n      nativeEvent\n    );\n    try {\n      // Event queue being processed in the same cycle allows\n      // `preventDefault`.\n      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);\n    } finally {\n      TopLevelCallbackBookKeeping.release(bookKeeping);\n    }\n  }\n};\n\nmodule.exports = ReactEventListener;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactEventListener.js\n ** module id = 155\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactEventListener.js?")},/*!***************************************!*\
  !*** ./~/react/lib/ReactInjection.js ***!
  \***************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactInjection\n */\n\n'use strict';\n\nvar DOMProperty = __webpack_require__(/*! ./DOMProperty */ 19);\nvar EventPluginHub = __webpack_require__(/*! ./EventPluginHub */ 30);\nvar ReactComponentEnvironment = __webpack_require__(/*! ./ReactComponentEnvironment */ 50);\nvar ReactClass = __webpack_require__(/*! ./ReactClass */ 8);\nvar ReactEmptyComponent = __webpack_require__(/*! ./ReactEmptyComponent */ 53);\nvar ReactBrowserEventEmitter = __webpack_require__(/*! ./ReactBrowserEventEmitter */ 21);\nvar ReactNativeComponent = __webpack_require__(/*! ./ReactNativeComponent */ 38);\nvar ReactDOMComponent = __webpack_require__(/*! ./ReactDOMComponent */ 52);\nvar ReactPerf = __webpack_require__(/*! ./ReactPerf */ 17);\nvar ReactRootIndex = __webpack_require__(/*! ./ReactRootIndex */ 83);\nvar ReactUpdates = __webpack_require__(/*! ./ReactUpdates */ 9);\n\nvar ReactInjection = {\n  Component: ReactComponentEnvironment.injection,\n  Class: ReactClass.injection,\n  DOMComponent: ReactDOMComponent.injection,\n  DOMProperty: DOMProperty.injection,\n  EmptyComponent: ReactEmptyComponent.injection,\n  EventPluginHub: EventPluginHub.injection,\n  EventEmitter: ReactBrowserEventEmitter.injection,\n  NativeComponent: ReactNativeComponent.injection,\n  Perf: ReactPerf.injection,\n  RootIndex: ReactRootIndex.injection,\n  Updates: ReactUpdates.injection\n};\n\nmodule.exports = ReactInjection;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactInjection.js\n ** module id = 156\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactInjection.js?")},/*!**********************************!*\
  !*** ./~/react/lib/ReactLink.js ***!
  \**********************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactLink\n * @typechecks static-only\n */\n\n'use strict';\n\n/**\n * ReactLink encapsulates a common pattern in which a component wants to modify\n * a prop received from its parent. ReactLink allows the parent to pass down a\n * value coupled with a callback that, when invoked, expresses an intent to\n * modify that value. For example:\n *\n * React.createClass({\n *   getInitialState: function() {\n *     return {value: ''};\n *   },\n *   render: function() {\n *     var valueLink = new ReactLink(this.state.value, this._handleValueChange);\n *     return <input valueLink={valueLink} />;\n *   },\n *   this._handleValueChange: function(newValue) {\n *     this.setState({value: newValue});\n *   }\n * });\n *\n * We have provided some sugary mixins to make the creation and\n * consumption of ReactLink easier; see LinkedValueUtils and LinkedStateMixin.\n */\n\nvar React = __webpack_require__(/*! ./React */ 20);\n\n/**\n * @param {*} value current value of the link\n * @param {function} requestChange callback to request a change\n */\nfunction ReactLink(value, requestChange) {\n  this.value = value;\n  this.requestChange = requestChange;\n}\n\n/**\n * Creates a PropType that enforces the ReactLink API and optionally checks the\n * type of the value being passed inside the link. Example:\n *\n * MyComponent.propTypes = {\n *   tabIndexLink: ReactLink.PropTypes.link(React.PropTypes.number)\n * }\n */\nfunction createLinkTypeChecker(linkType) {\n  var shapes = {\n    value: typeof linkType === 'undefined' ?\n      React.PropTypes.any.isRequired :\n      linkType.isRequired,\n    requestChange: React.PropTypes.func.isRequired\n  };\n  return React.PropTypes.shape(shapes);\n}\n\nReactLink.PropTypes = {\n  link: createLinkTypeChecker\n};\n\nmodule.exports = ReactLink;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactLink.js\n ** module id = 157\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactLink.js?")},/*!****************************************!*\
  !*** ./~/react/lib/ReactMultiChild.js ***!
  \****************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMultiChild\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactComponentEnvironment = __webpack_require__(/*! ./ReactComponentEnvironment */ 50);\nvar ReactMultiChildUpdateTypes = __webpack_require__(/*! ./ReactMultiChildUpdateTypes */ 80);\n\nvar ReactReconciler = __webpack_require__(/*! ./ReactReconciler */ 25);\nvar ReactChildReconciler = __webpack_require__(/*! ./ReactChildReconciler */ 138);\n\n/**\n * Updating children of a component may trigger recursive updates. The depth is\n * used to batch recursive updates to render markup more efficiently.\n *\n * @type {number}\n * @private\n */\nvar updateDepth = 0;\n\n/**\n * Queue of update configuration objects.\n *\n * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.\n *\n * @type {array<object>}\n * @private\n */\nvar updateQueue = [];\n\n/**\n * Queue of markup to be rendered.\n *\n * @type {array<string>}\n * @private\n */\nvar markupQueue = [];\n\n/**\n * Enqueues markup to be rendered and inserted at a supplied index.\n *\n * @param {string} parentID ID of the parent component.\n * @param {string} markup Markup that renders into an element.\n * @param {number} toIndex Destination index.\n * @private\n */\nfunction enqueueMarkup(parentID, markup, toIndex) {\n  // NOTE: Null values reduce hidden classes.\n  updateQueue.push({\n    parentID: parentID,\n    parentNode: null,\n    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,\n    markupIndex: markupQueue.push(markup) - 1,\n    textContent: null,\n    fromIndex: null,\n    toIndex: toIndex\n  });\n}\n\n/**\n * Enqueues moving an existing element to another index.\n *\n * @param {string} parentID ID of the parent component.\n * @param {number} fromIndex Source index of the existing element.\n * @param {number} toIndex Destination index of the element.\n * @private\n */\nfunction enqueueMove(parentID, fromIndex, toIndex) {\n  // NOTE: Null values reduce hidden classes.\n  updateQueue.push({\n    parentID: parentID,\n    parentNode: null,\n    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,\n    markupIndex: null,\n    textContent: null,\n    fromIndex: fromIndex,\n    toIndex: toIndex\n  });\n}\n\n/**\n * Enqueues removing an element at an index.\n *\n * @param {string} parentID ID of the parent component.\n * @param {number} fromIndex Index of the element to remove.\n * @private\n */\nfunction enqueueRemove(parentID, fromIndex) {\n  // NOTE: Null values reduce hidden classes.\n  updateQueue.push({\n    parentID: parentID,\n    parentNode: null,\n    type: ReactMultiChildUpdateTypes.REMOVE_NODE,\n    markupIndex: null,\n    textContent: null,\n    fromIndex: fromIndex,\n    toIndex: null\n  });\n}\n\n/**\n * Enqueues setting the text content.\n *\n * @param {string} parentID ID of the parent component.\n * @param {string} textContent Text content to set.\n * @private\n */\nfunction enqueueTextContent(parentID, textContent) {\n  // NOTE: Null values reduce hidden classes.\n  updateQueue.push({\n    parentID: parentID,\n    parentNode: null,\n    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,\n    markupIndex: null,\n    textContent: textContent,\n    fromIndex: null,\n    toIndex: null\n  });\n}\n\n/**\n * Processes any enqueued updates.\n *\n * @private\n */\nfunction processQueue() {\n  if (updateQueue.length) {\n    ReactComponentEnvironment.processChildrenUpdates(\n      updateQueue,\n      markupQueue\n    );\n    clearQueue();\n  }\n}\n\n/**\n * Clears any enqueued updates.\n *\n * @private\n */\nfunction clearQueue() {\n  updateQueue.length = 0;\n  markupQueue.length = 0;\n}\n\n/**\n * ReactMultiChild are capable of reconciling multiple children.\n *\n * @class ReactMultiChild\n * @internal\n */\nvar ReactMultiChild = {\n\n  /**\n   * Provides common functionality for components that must reconcile multiple\n   * children. This is used by `ReactDOMComponent` to mount, update, and\n   * unmount child components.\n   *\n   * @lends {ReactMultiChild.prototype}\n   */\n  Mixin: {\n\n    /**\n     * Generates a \"mount image\" for each of the supplied children. In the case\n     * of `ReactDOMComponent`, a mount image is a string of markup.\n     *\n     * @param {?object} nestedChildren Nested child maps.\n     * @return {array} An array of mounted representations.\n     * @internal\n     */\n    mountChildren: function(nestedChildren, transaction, context) {\n      var children = ReactChildReconciler.instantiateChildren(\n        nestedChildren, transaction, context\n      );\n      this._renderedChildren = children;\n      var mountImages = [];\n      var index = 0;\n      for (var name in children) {\n        if (children.hasOwnProperty(name)) {\n          var child = children[name];\n          // Inlined for performance, see `ReactInstanceHandles.createReactID`.\n          var rootID = this._rootNodeID + name;\n          var mountImage = ReactReconciler.mountComponent(\n            child,\n            rootID,\n            transaction,\n            context\n          );\n          child._mountIndex = index;\n          mountImages.push(mountImage);\n          index++;\n        }\n      }\n      return mountImages;\n    },\n\n    /**\n     * Replaces any rendered children with a text content string.\n     *\n     * @param {string} nextContent String of content.\n     * @internal\n     */\n    updateTextContent: function(nextContent) {\n      updateDepth++;\n      var errorThrown = true;\n      try {\n        var prevChildren = this._renderedChildren;\n        // Remove any rendered children.\n        ReactChildReconciler.unmountChildren(prevChildren);\n        // TODO: The setTextContent operation should be enough\n        for (var name in prevChildren) {\n          if (prevChildren.hasOwnProperty(name)) {\n            this._unmountChildByName(prevChildren[name], name);\n          }\n        }\n        // Set new text content.\n        this.setTextContent(nextContent);\n        errorThrown = false;\n      } finally {\n        updateDepth--;\n        if (!updateDepth) {\n          if (errorThrown) {\n            clearQueue();\n          } else {\n            processQueue();\n          }\n        }\n      }\n    },\n\n    /**\n     * Updates the rendered children with new children.\n     *\n     * @param {?object} nextNestedChildren Nested child maps.\n     * @param {ReactReconcileTransaction} transaction\n     * @internal\n     */\n    updateChildren: function(nextNestedChildren, transaction, context) {\n      updateDepth++;\n      var errorThrown = true;\n      try {\n        this._updateChildren(nextNestedChildren, transaction, context);\n        errorThrown = false;\n      } finally {\n        updateDepth--;\n        if (!updateDepth) {\n          if (errorThrown) {\n            clearQueue();\n          } else {\n            processQueue();\n          }\n        }\n\n      }\n    },\n\n    /**\n     * Improve performance by isolating this hot code path from the try/catch\n     * block in `updateChildren`.\n     *\n     * @param {?object} nextNestedChildren Nested child maps.\n     * @param {ReactReconcileTransaction} transaction\n     * @final\n     * @protected\n     */\n    _updateChildren: function(nextNestedChildren, transaction, context) {\n      var prevChildren = this._renderedChildren;\n      var nextChildren = ReactChildReconciler.updateChildren(\n        prevChildren, nextNestedChildren, transaction, context\n      );\n      this._renderedChildren = nextChildren;\n      if (!nextChildren && !prevChildren) {\n        return;\n      }\n      var name;\n      // `nextIndex` will increment for each child in `nextChildren`, but\n      // `lastIndex` will be the last index visited in `prevChildren`.\n      var lastIndex = 0;\n      var nextIndex = 0;\n      for (name in nextChildren) {\n        if (!nextChildren.hasOwnProperty(name)) {\n          continue;\n        }\n        var prevChild = prevChildren && prevChildren[name];\n        var nextChild = nextChildren[name];\n        if (prevChild === nextChild) {\n          this.moveChild(prevChild, nextIndex, lastIndex);\n          lastIndex = Math.max(prevChild._mountIndex, lastIndex);\n          prevChild._mountIndex = nextIndex;\n        } else {\n          if (prevChild) {\n            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.\n            lastIndex = Math.max(prevChild._mountIndex, lastIndex);\n            this._unmountChildByName(prevChild, name);\n          }\n          // The child must be instantiated before it's mounted.\n          this._mountChildByNameAtIndex(\n            nextChild, name, nextIndex, transaction, context\n          );\n        }\n        nextIndex++;\n      }\n      // Remove children that are no longer present.\n      for (name in prevChildren) {\n        if (prevChildren.hasOwnProperty(name) &&\n            !(nextChildren && nextChildren.hasOwnProperty(name))) {\n          this._unmountChildByName(prevChildren[name], name);\n        }\n      }\n    },\n\n    /**\n     * Unmounts all rendered children. This should be used to clean up children\n     * when this component is unmounted.\n     *\n     * @internal\n     */\n    unmountChildren: function() {\n      var renderedChildren = this._renderedChildren;\n      ReactChildReconciler.unmountChildren(renderedChildren);\n      this._renderedChildren = null;\n    },\n\n    /**\n     * Moves a child component to the supplied index.\n     *\n     * @param {ReactComponent} child Component to move.\n     * @param {number} toIndex Destination index of the element.\n     * @param {number} lastIndex Last index visited of the siblings of `child`.\n     * @protected\n     */\n    moveChild: function(child, toIndex, lastIndex) {\n      // If the index of `child` is less than `lastIndex`, then it needs to\n      // be moved. Otherwise, we do not need to move it because a child will be\n      // inserted or moved before `child`.\n      if (child._mountIndex < lastIndex) {\n        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);\n      }\n    },\n\n    /**\n     * Creates a child component.\n     *\n     * @param {ReactComponent} child Component to create.\n     * @param {string} mountImage Markup to insert.\n     * @protected\n     */\n    createChild: function(child, mountImage) {\n      enqueueMarkup(this._rootNodeID, mountImage, child._mountIndex);\n    },\n\n    /**\n     * Removes a child component.\n     *\n     * @param {ReactComponent} child Child to remove.\n     * @protected\n     */\n    removeChild: function(child) {\n      enqueueRemove(this._rootNodeID, child._mountIndex);\n    },\n\n    /**\n     * Sets this text content string.\n     *\n     * @param {string} textContent Text content to set.\n     * @protected\n     */\n    setTextContent: function(textContent) {\n      enqueueTextContent(this._rootNodeID, textContent);\n    },\n\n    /**\n     * Mounts a child with the supplied name.\n     *\n     * NOTE: This is part of `updateChildren` and is here for readability.\n     *\n     * @param {ReactComponent} child Component to mount.\n     * @param {string} name Name of the child.\n     * @param {number} index Index at which to insert the child.\n     * @param {ReactReconcileTransaction} transaction\n     * @private\n     */\n    _mountChildByNameAtIndex: function(\n      child,\n      name,\n      index,\n      transaction,\n      context) {\n      // Inlined for performance, see `ReactInstanceHandles.createReactID`.\n      var rootID = this._rootNodeID + name;\n      var mountImage = ReactReconciler.mountComponent(\n        child,\n        rootID,\n        transaction,\n        context\n      );\n      child._mountIndex = index;\n      this.createChild(child, mountImage);\n    },\n\n    /**\n     * Unmounts a rendered child by name.\n     *\n     * NOTE: This is part of `updateChildren` and is here for readability.\n     *\n     * @param {ReactComponent} child Component to unmount.\n     * @param {string} name Name of the child in `this._renderedChildren`.\n     * @private\n     */\n    _unmountChildByName: function(child, name) {\n      this.removeChild(child);\n      child._mountIndex = null;\n    }\n\n  }\n\n};\n\nmodule.exports = ReactMultiChild;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactMultiChild.js\n ** module id = 158\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactMultiChild.js?")},/*!***********************************!*\
  !*** ./~/react/lib/ReactOwner.js ***!
  \***********************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactOwner\n */\n\n'use strict';\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\n/**\n * ReactOwners are capable of storing references to owned components.\n *\n * All components are capable of //being// referenced by owner components, but\n * only ReactOwner components are capable of //referencing// owned components.\n * The named reference is known as a \"ref\".\n *\n * Refs are available when mounted and updated during reconciliation.\n *\n *   var MyComponent = React.createClass({\n *     render: function() {\n *       return (\n *         <div onClick={this.handleClick}>\n *           <CustomComponent ref=\"custom\" />\n *         </div>\n *       );\n *     },\n *     handleClick: function() {\n *       this.refs.custom.handleClick();\n *     },\n *     componentDidMount: function() {\n *       this.refs.custom.initialize();\n *     }\n *   });\n *\n * Refs should rarely be used. When refs are used, they should only be done to\n * control data that is not handled by React's data flow.\n *\n * @class ReactOwner\n */\nvar ReactOwner = {\n\n  /**\n   * @param {?object} object\n   * @return {boolean} True if `object` is a valid owner.\n   * @final\n   */\n  isValidOwner: function(object) {\n    return !!(\n      (object &&\n      typeof object.attachRef === 'function' && typeof object.detachRef === 'function')\n    );\n  },\n\n  /**\n   * Adds a component by ref to an owner component.\n   *\n   * @param {ReactComponent} component Component to reference.\n   * @param {string} ref Name by which to refer to the component.\n   * @param {ReactOwner} owner Component on which to record the ref.\n   * @final\n   * @internal\n   */\n  addComponentAsRefTo: function(component, ref, owner) {\n    (false ? invariant(\n      ReactOwner.isValidOwner(owner),\n      'addComponentAsRefTo(...): Only a ReactOwner can have refs. This ' +\n      'usually means that you\\'re trying to add a ref to a component that ' +\n      'doesn\\'t have an owner (that is, was not created inside of another ' +\n      'component\\'s `render` method). Try rendering this component inside of ' +\n      'a new top-level component which will hold the ref.'\n    ) : invariant(ReactOwner.isValidOwner(owner)));\n    owner.attachRef(ref, component);\n  },\n\n  /**\n   * Removes a component by ref from an owner component.\n   *\n   * @param {ReactComponent} component Component to dereference.\n   * @param {string} ref Name of the ref to remove.\n   * @param {ReactOwner} owner Component on which the ref is recorded.\n   * @final\n   * @internal\n   */\n  removeComponentAsRefFrom: function(component, ref, owner) {\n    (false ? invariant(\n      ReactOwner.isValidOwner(owner),\n      'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. This ' +\n      'usually means that you\\'re trying to remove a ref to a component that ' +\n      'doesn\\'t have an owner (that is, was not created inside of another ' +\n      'component\\'s `render` method). Try rendering this component inside of ' +\n      'a new top-level component which will hold the ref.'\n    ) : invariant(ReactOwner.isValidOwner(owner)));\n    // Check that `component` is still the current ref because we do not want to\n    // detach the ref if another component stole it.\n    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {\n      owner.detachRef(ref);\n    }\n  }\n\n};\n\nmodule.exports = ReactOwner;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactOwner.js\n ** module id = 159\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactOwner.js?")},/*!********************************************!*\
  !*** ./~/react/lib/ReactPropTransferer.js ***!
  \********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPropTransferer\n */\n\n'use strict';\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar emptyFunction = __webpack_require__(/*! ./emptyFunction */ 10);\nvar joinClasses = __webpack_require__(/*! ./joinClasses */ 197);\n\n/**\n * Creates a transfer strategy that will merge prop values using the supplied\n * `mergeStrategy`. If a prop was previously unset, this just sets it.\n *\n * @param {function} mergeStrategy\n * @return {function}\n */\nfunction createTransferStrategy(mergeStrategy) {\n  return function(props, key, value) {\n    if (!props.hasOwnProperty(key)) {\n      props[key] = value;\n    } else {\n      props[key] = mergeStrategy(props[key], value);\n    }\n  };\n}\n\nvar transferStrategyMerge = createTransferStrategy(function(a, b) {\n  // `merge` overrides the first object's (`props[key]` above) keys using the\n  // second object's (`value`) keys. An object's style's existing `propA` would\n  // get overridden. Flip the order here.\n  return assign({}, b, a);\n});\n\n/**\n * Transfer strategies dictate how props are transferred by `transferPropsTo`.\n * NOTE: if you add any more exceptions to this list you should be sure to\n * update `cloneWithProps()` accordingly.\n */\nvar TransferStrategies = {\n  /**\n   * Never transfer `children`.\n   */\n  children: emptyFunction,\n  /**\n   * Transfer the `className` prop by merging them.\n   */\n  className: createTransferStrategy(joinClasses),\n  /**\n   * Transfer the `style` prop (which is an object) by merging them.\n   */\n  style: transferStrategyMerge\n};\n\n/**\n * Mutates the first argument by transferring the properties from the second\n * argument.\n *\n * @param {object} props\n * @param {object} newProps\n * @return {object}\n */\nfunction transferInto(props, newProps) {\n  for (var thisKey in newProps) {\n    if (!newProps.hasOwnProperty(thisKey)) {\n      continue;\n    }\n\n    var transferStrategy = TransferStrategies[thisKey];\n\n    if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {\n      transferStrategy(props, thisKey, newProps[thisKey]);\n    } else if (!props.hasOwnProperty(thisKey)) {\n      props[thisKey] = newProps[thisKey];\n    }\n  }\n  return props;\n}\n\n/**\n * ReactPropTransferer are capable of transferring props to another component\n * using a `transferPropsTo` method.\n *\n * @class ReactPropTransferer\n */\nvar ReactPropTransferer = {\n\n  /**\n   * Merge two props objects using TransferStrategies.\n   *\n   * @param {object} oldProps original props (they take precedence)\n   * @param {object} newProps new props to merge in\n   * @return {object} a new object containing both sets of props merged.\n   */\n  mergeProps: function(oldProps, newProps) {\n    return transferInto(assign({}, oldProps), newProps);\n  }\n\n};\n\nmodule.exports = ReactPropTransferer;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactPropTransferer.js\n ** module id = 160\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactPropTransferer.js?")},/*!**************************************************!*\
  !*** ./~/react/lib/ReactReconcileTransaction.js ***!
  \**************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactReconcileTransaction\n * @typechecks static-only\n */\n\n'use strict';\n\nvar CallbackQueue = __webpack_require__(/*! ./CallbackQueue */ 45);\nvar PooledClass = __webpack_require__(/*! ./PooledClass */ 12);\nvar ReactBrowserEventEmitter = __webpack_require__(/*! ./ReactBrowserEventEmitter */ 21);\nvar ReactInputSelection = __webpack_require__(/*! ./ReactInputSelection */ 78);\nvar ReactPutListenerQueue = __webpack_require__(/*! ./ReactPutListenerQueue */ 82);\nvar Transaction = __webpack_require__(/*! ./Transaction */ 41);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\n\n/**\n * Ensures that, when possible, the selection range (currently selected text\n * input) is not disturbed by performing the transaction.\n */\nvar SELECTION_RESTORATION = {\n  /**\n   * @return {Selection} Selection information.\n   */\n  initialize: ReactInputSelection.getSelectionInformation,\n  /**\n   * @param {Selection} sel Selection information returned from `initialize`.\n   */\n  close: ReactInputSelection.restoreSelection\n};\n\n/**\n * Suppresses events (blur/focus) that could be inadvertently dispatched due to\n * high level DOM manipulations (like temporarily removing a text input from the\n * DOM).\n */\nvar EVENT_SUPPRESSION = {\n  /**\n   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before\n   * the reconciliation.\n   */\n  initialize: function() {\n    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();\n    ReactBrowserEventEmitter.setEnabled(false);\n    return currentlyEnabled;\n  },\n\n  /**\n   * @param {boolean} previouslyEnabled Enabled status of\n   *   `ReactBrowserEventEmitter` before the reconciliation occured. `close`\n   *   restores the previous value.\n   */\n  close: function(previouslyEnabled) {\n    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);\n  }\n};\n\n/**\n * Provides a queue for collecting `componentDidMount` and\n * `componentDidUpdate` callbacks during the the transaction.\n */\nvar ON_DOM_READY_QUEUEING = {\n  /**\n   * Initializes the internal `onDOMReady` queue.\n   */\n  initialize: function() {\n    this.reactMountReady.reset();\n  },\n\n  /**\n   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.\n   */\n  close: function() {\n    this.reactMountReady.notifyAll();\n  }\n};\n\nvar PUT_LISTENER_QUEUEING = {\n  initialize: function() {\n    this.putListenerQueue.reset();\n  },\n\n  close: function() {\n    this.putListenerQueue.putListeners();\n  }\n};\n\n/**\n * Executed within the scope of the `Transaction` instance. Consider these as\n * being member methods, but with an implied ordering while being isolated from\n * each other.\n */\nvar TRANSACTION_WRAPPERS = [\n  PUT_LISTENER_QUEUEING,\n  SELECTION_RESTORATION,\n  EVENT_SUPPRESSION,\n  ON_DOM_READY_QUEUEING\n];\n\n/**\n * Currently:\n * - The order that these are listed in the transaction is critical:\n * - Suppresses events.\n * - Restores selection range.\n *\n * Future:\n * - Restore document/overflow scroll positions that were unintentionally\n *   modified via DOM insertions above the top viewport boundary.\n * - Implement/integrate with customized constraint based layout system and keep\n *   track of which dimensions must be remeasured.\n *\n * @class ReactReconcileTransaction\n */\nfunction ReactReconcileTransaction() {\n  this.reinitializeTransaction();\n  // Only server-side rendering really needs this option (see\n  // `ReactServerRendering`), but server-side uses\n  // `ReactServerRenderingTransaction` instead. This option is here so that it's\n  // accessible and defaults to false when `ReactDOMComponent` and\n  // `ReactTextComponent` checks it in `mountComponent`.`\n  this.renderToStaticMarkup = false;\n  this.reactMountReady = CallbackQueue.getPooled(null);\n  this.putListenerQueue = ReactPutListenerQueue.getPooled();\n}\n\nvar Mixin = {\n  /**\n   * @see Transaction\n   * @abstract\n   * @final\n   * @return {array<object>} List of operation wrap proceedures.\n   *   TODO: convert to array<TransactionWrapper>\n   */\n  getTransactionWrappers: function() {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  /**\n   * @return {object} The queue to collect `onDOMReady` callbacks with.\n   */\n  getReactMountReady: function() {\n    return this.reactMountReady;\n  },\n\n  getPutListenerQueue: function() {\n    return this.putListenerQueue;\n  },\n\n  /**\n   * `PooledClass` looks for this, and will invoke this before allowing this\n   * instance to be resused.\n   */\n  destructor: function() {\n    CallbackQueue.release(this.reactMountReady);\n    this.reactMountReady = null;\n\n    ReactPutListenerQueue.release(this.putListenerQueue);\n    this.putListenerQueue = null;\n  }\n};\n\n\nassign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);\n\nPooledClass.addPoolingTo(ReactReconcileTransaction);\n\nmodule.exports = ReactReconcileTransaction;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactReconcileTransaction.js\n ** module id = 161\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactReconcileTransaction.js?")},/*!*********************************!*\
  !*** ./~/react/lib/ReactRef.js ***!
  \*********************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactRef\n */\n\n'use strict';\n\nvar ReactOwner = __webpack_require__(/*! ./ReactOwner */ 159);\n\nvar ReactRef = {};\n\nfunction attachRef(ref, component, owner) {\n  if (typeof ref === 'function') {\n    ref(component.getPublicInstance());\n  } else {\n    // Legacy ref\n    ReactOwner.addComponentAsRefTo(component, ref, owner);\n  }\n}\n\nfunction detachRef(ref, component, owner) {\n  if (typeof ref === 'function') {\n    ref(null);\n  } else {\n    // Legacy ref\n    ReactOwner.removeComponentAsRefFrom(component, ref, owner);\n  }\n}\n\nReactRef.attachRefs = function(instance, element) {\n  var ref = element.ref;\n  if (ref != null) {\n    attachRef(ref, instance, element._owner);\n  }\n};\n\nReactRef.shouldUpdateRefs = function(prevElement, nextElement) {\n  // If either the owner or a `ref` has changed, make sure the newest owner\n  // has stored a reference to `this`, and the previous owner (if different)\n  // has forgotten the reference to `this`. We use the element instead\n  // of the public this.props because the post processing cannot determine\n  // a ref. The ref conceptually lives on the element.\n\n  // TODO: Should this even be possible? The owner cannot change because\n  // it's forbidden by shouldUpdateReactComponent. The ref can change\n  // if you swap the keys of but not the refs. Reconsider where this check\n  // is made. It probably belongs where the key checking and\n  // instantiateReactComponent is done.\n\n  return (\n    nextElement._owner !== prevElement._owner ||\n    nextElement.ref !== prevElement.ref\n  );\n};\n\nReactRef.detachRefs = function(instance, element) {\n  var ref = element.ref;\n  if (ref != null) {\n    detachRef(ref, instance, element._owner);\n  }\n};\n\nmodule.exports = ReactRef;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactRef.js\n ** module id = 162\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactRef.js?")},/*!*********************************************!*\
  !*** ./~/react/lib/ReactServerRendering.js ***!
  \*********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks static-only\n * @providesModule ReactServerRendering\n */\n'use strict';\n\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\nvar ReactInstanceHandles = __webpack_require__(/*! ./ReactInstanceHandles */ 23);\nvar ReactMarkupChecksum = __webpack_require__(/*! ./ReactMarkupChecksum */ 79);\nvar ReactServerRenderingTransaction =\n  __webpack_require__(/*! ./ReactServerRenderingTransaction */ 164);\n\nvar emptyObject = __webpack_require__(/*! ./emptyObject */ 42);\nvar instantiateReactComponent = __webpack_require__(/*! ./instantiateReactComponent */ 62);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\n/**\n * @param {ReactElement} element\n * @return {string} the HTML markup\n */\nfunction renderToString(element) {\n  (false ? invariant(\n    ReactElement.isValidElement(element),\n    'renderToString(): You must pass a valid ReactElement.'\n  ) : invariant(ReactElement.isValidElement(element)));\n\n  var transaction;\n  try {\n    var id = ReactInstanceHandles.createReactRootID();\n    transaction = ReactServerRenderingTransaction.getPooled(false);\n\n    return transaction.perform(function() {\n      var componentInstance = instantiateReactComponent(element, null);\n      var markup =\n        componentInstance.mountComponent(id, transaction, emptyObject);\n      return ReactMarkupChecksum.addChecksumToMarkup(markup);\n    }, null);\n  } finally {\n    ReactServerRenderingTransaction.release(transaction);\n  }\n}\n\n/**\n * @param {ReactElement} element\n * @return {string} the HTML markup, without the extra React ID and checksum\n * (for generating static pages)\n */\nfunction renderToStaticMarkup(element) {\n  (false ? invariant(\n    ReactElement.isValidElement(element),\n    'renderToStaticMarkup(): You must pass a valid ReactElement.'\n  ) : invariant(ReactElement.isValidElement(element)));\n\n  var transaction;\n  try {\n    var id = ReactInstanceHandles.createReactRootID();\n    transaction = ReactServerRenderingTransaction.getPooled(true);\n\n    return transaction.perform(function() {\n      var componentInstance = instantiateReactComponent(element, null);\n      return componentInstance.mountComponent(id, transaction, emptyObject);\n    }, null);\n  } finally {\n    ReactServerRenderingTransaction.release(transaction);\n  }\n}\n\nmodule.exports = {\n  renderToString: renderToString,\n  renderToStaticMarkup: renderToStaticMarkup\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactServerRendering.js\n ** module id = 163\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactServerRendering.js?")},/*!********************************************************!*\
  !*** ./~/react/lib/ReactServerRenderingTransaction.js ***!
  \********************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactServerRenderingTransaction\n * @typechecks\n */\n\n'use strict';\n\nvar PooledClass = __webpack_require__(/*! ./PooledClass */ 12);\nvar CallbackQueue = __webpack_require__(/*! ./CallbackQueue */ 45);\nvar ReactPutListenerQueue = __webpack_require__(/*! ./ReactPutListenerQueue */ 82);\nvar Transaction = __webpack_require__(/*! ./Transaction */ 41);\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar emptyFunction = __webpack_require__(/*! ./emptyFunction */ 10);\n\n/**\n * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks\n * during the performing of the transaction.\n */\nvar ON_DOM_READY_QUEUEING = {\n  /**\n   * Initializes the internal `onDOMReady` queue.\n   */\n  initialize: function() {\n    this.reactMountReady.reset();\n  },\n\n  close: emptyFunction\n};\n\nvar PUT_LISTENER_QUEUEING = {\n  initialize: function() {\n    this.putListenerQueue.reset();\n  },\n\n  close: emptyFunction\n};\n\n/**\n * Executed within the scope of the `Transaction` instance. Consider these as\n * being member methods, but with an implied ordering while being isolated from\n * each other.\n */\nvar TRANSACTION_WRAPPERS = [\n  PUT_LISTENER_QUEUEING,\n  ON_DOM_READY_QUEUEING\n];\n\n/**\n * @class ReactServerRenderingTransaction\n * @param {boolean} renderToStaticMarkup\n */\nfunction ReactServerRenderingTransaction(renderToStaticMarkup) {\n  this.reinitializeTransaction();\n  this.renderToStaticMarkup = renderToStaticMarkup;\n  this.reactMountReady = CallbackQueue.getPooled(null);\n  this.putListenerQueue = ReactPutListenerQueue.getPooled();\n}\n\nvar Mixin = {\n  /**\n   * @see Transaction\n   * @abstract\n   * @final\n   * @return {array} Empty list of operation wrap proceedures.\n   */\n  getTransactionWrappers: function() {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  /**\n   * @return {object} The queue to collect `onDOMReady` callbacks with.\n   */\n  getReactMountReady: function() {\n    return this.reactMountReady;\n  },\n\n  getPutListenerQueue: function() {\n    return this.putListenerQueue;\n  },\n\n  /**\n   * `PooledClass` looks for this, and will invoke this before allowing this\n   * instance to be resused.\n   */\n  destructor: function() {\n    CallbackQueue.release(this.reactMountReady);\n    this.reactMountReady = null;\n\n    ReactPutListenerQueue.release(this.putListenerQueue);\n    this.putListenerQueue = null;\n  }\n};\n\n\nassign(\n  ReactServerRenderingTransaction.prototype,\n  Transaction.Mixin,\n  Mixin\n);\n\nPooledClass.addPoolingTo(ReactServerRenderingTransaction);\n\nmodule.exports = ReactServerRenderingTransaction;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactServerRenderingTransaction.js\n ** module id = 164\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactServerRenderingTransaction.js?")},/*!******************************************!*\
  !*** ./~/react/lib/ReactStateSetters.js ***!
  \******************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactStateSetters\n */\n\n'use strict';\n\nvar ReactStateSetters = {\n  /**\n   * Returns a function that calls the provided function, and uses the result\n   * of that to set the component's state.\n   *\n   * @param {ReactCompositeComponent} component\n   * @param {function} funcReturningState Returned callback uses this to\n   *                                      determine how to update state.\n   * @return {function} callback that when invoked uses funcReturningState to\n   *                    determined the object literal to setState.\n   */\n  createStateSetter: function(component, funcReturningState) {\n    return function(a, b, c, d, e, f) {\n      var partialState = funcReturningState.call(component, a, b, c, d, e, f);\n      if (partialState) {\n        component.setState(partialState);\n      }\n    };\n  },\n\n  /**\n   * Returns a single-argument callback that can be used to update a single\n   * key in the component's state.\n   *\n   * Note: this is memoized function, which makes it inexpensive to call.\n   *\n   * @param {ReactCompositeComponent} component\n   * @param {string} key The key in the state that you should update.\n   * @return {function} callback of 1 argument which calls setState() with\n   *                    the provided keyName and callback argument.\n   */\n  createStateKeySetter: function(component, key) {\n    // Memoize the setters.\n    var cache = component.__keySetters || (component.__keySetters = {});\n    return cache[key] || (cache[key] = createStateKeySetter(component, key));\n  }\n};\n\nfunction createStateKeySetter(component, key) {\n  // Partial state is allocated outside of the function closure so it can be\n  // reused with every call, avoiding memory allocation when this function\n  // is called.\n  var partialState = {};\n  return function stateKeySetter(value) {\n    partialState[key] = value;\n    component.setState(partialState);\n  };\n}\n\nReactStateSetters.Mixin = {\n  /**\n   * Returns a function that calls the provided function, and uses the result\n   * of that to set the component's state.\n   *\n   * For example, these statements are equivalent:\n   *\n   *   this.setState({x: 1});\n   *   this.createStateSetter(function(xValue) {\n   *     return {x: xValue};\n   *   })(1);\n   *\n   * @param {function} funcReturningState Returned callback uses this to\n   *                                      determine how to update state.\n   * @return {function} callback that when invoked uses funcReturningState to\n   *                    determined the object literal to setState.\n   */\n  createStateSetter: function(funcReturningState) {\n    return ReactStateSetters.createStateSetter(this, funcReturningState);\n  },\n\n  /**\n   * Returns a single-argument callback that can be used to update a single\n   * key in the component's state.\n   *\n   * For example, these statements are equivalent:\n   *\n   *   this.setState({x: 1});\n   *   this.createStateKeySetter('x')(1);\n   *\n   * Note: this is memoized function, which makes it inexpensive to call.\n   *\n   * @param {string} key The key in the state that you should update.\n   * @return {function} callback of 1 argument which calls setState() with\n   *                    the provided keyName and callback argument.\n   */\n  createStateKeySetter: function(key) {\n    return ReactStateSetters.createStateKeySetter(this, key);\n  }\n};\n\nmodule.exports = ReactStateSetters;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactStateSetters.js\n ** module id = 165\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactStateSetters.js?")},/*!****************************************************!*\
  !*** ./~/react/lib/ReactTransitionChildMapping.js ***!
  \****************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks static-only\n * @providesModule ReactTransitionChildMapping\n */\n\n'use strict';\n\nvar ReactChildren = __webpack_require__(/*! ./ReactChildren */ 74);\nvar ReactFragment = __webpack_require__(/*! ./ReactFragment */ 22);\n\nvar ReactTransitionChildMapping = {\n  /**\n   * Given `this.props.children`, return an object mapping key to child. Just\n   * simple syntactic sugar around ReactChildren.map().\n   *\n   * @param {*} children `this.props.children`\n   * @return {object} Mapping of key to child\n   */\n  getChildMapping: function(children) {\n    if (!children) {\n      return children;\n    }\n    return ReactFragment.extract(ReactChildren.map(children, function(child) {\n      return child;\n    }));\n  },\n\n  /**\n   * When you're adding or removing children some may be added or removed in the\n   * same render pass. We want to show *both* since we want to simultaneously\n   * animate elements in and out. This function takes a previous set of keys\n   * and a new set of keys and merges them with its best guess of the correct\n   * ordering. In the future we may expose some of the utilities in\n   * ReactMultiChild to make this easy, but for now React itself does not\n   * directly have this concept of the union of prevChildren and nextChildren\n   * so we implement it here.\n   *\n   * @param {object} prev prev children as returned from\n   * `ReactTransitionChildMapping.getChildMapping()`.\n   * @param {object} next next children as returned from\n   * `ReactTransitionChildMapping.getChildMapping()`.\n   * @return {object} a key set that contains all keys in `prev` and all keys\n   * in `next` in a reasonable order.\n   */\n  mergeChildMappings: function(prev, next) {\n    prev = prev || {};\n    next = next || {};\n\n    function getValueForKey(key) {\n      if (next.hasOwnProperty(key)) {\n        return next[key];\n      } else {\n        return prev[key];\n      }\n    }\n\n    // For each key of `next`, the list of keys to insert before that key in\n    // the combined list\n    var nextKeysPending = {};\n\n    var pendingKeys = [];\n    for (var prevKey in prev) {\n      if (next.hasOwnProperty(prevKey)) {\n        if (pendingKeys.length) {\n          nextKeysPending[prevKey] = pendingKeys;\n          pendingKeys = [];\n        }\n      } else {\n        pendingKeys.push(prevKey);\n      }\n    }\n\n    var i;\n    var childMapping = {};\n    for (var nextKey in next) {\n      if (nextKeysPending.hasOwnProperty(nextKey)) {\n        for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n          var pendingNextKey = nextKeysPending[nextKey][i];\n          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(\n            pendingNextKey\n          );\n        }\n      }\n      childMapping[nextKey] = getValueForKey(nextKey);\n    }\n\n    // Finally, add the keys which didn't appear before any key in `next`\n    for (i = 0; i < pendingKeys.length; i++) {\n      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n    }\n\n    return childMapping;\n  }\n};\n\nmodule.exports = ReactTransitionChildMapping;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactTransitionChildMapping.js\n ** module id = 166\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactTransitionChildMapping.js?")},/*!**********************************************!*\
  !*** ./~/react/lib/ReactTransitionEvents.js ***!
  \**********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactTransitionEvents\n */\n\n'use strict';\n\nvar ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ 6);\n\n/**\n * EVENT_NAME_MAP is used to determine which event fired when a\n * transition/animation ends, based on the style property used to\n * define that event.\n */\nvar EVENT_NAME_MAP = {\n  transitionend: {\n    'transition': 'transitionend',\n    'WebkitTransition': 'webkitTransitionEnd',\n    'MozTransition': 'mozTransitionEnd',\n    'OTransition': 'oTransitionEnd',\n    'msTransition': 'MSTransitionEnd'\n  },\n\n  animationend: {\n    'animation': 'animationend',\n    'WebkitAnimation': 'webkitAnimationEnd',\n    'MozAnimation': 'mozAnimationEnd',\n    'OAnimation': 'oAnimationEnd',\n    'msAnimation': 'MSAnimationEnd'\n  }\n};\n\nvar endEvents = [];\n\nfunction detectEvents() {\n  var testEl = document.createElement('div');\n  var style = testEl.style;\n\n  // On some platforms, in particular some releases of Android 4.x,\n  // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n  // style object but the events that fire will still be prefixed, so we need\n  // to check if the un-prefixed events are useable, and if not remove them\n  // from the map\n  if (!('AnimationEvent' in window)) {\n    delete EVENT_NAME_MAP.animationend.animation;\n  }\n\n  if (!('TransitionEvent' in window)) {\n    delete EVENT_NAME_MAP.transitionend.transition;\n  }\n\n  for (var baseEventName in EVENT_NAME_MAP) {\n    var baseEvents = EVENT_NAME_MAP[baseEventName];\n    for (var styleName in baseEvents) {\n      if (styleName in style) {\n        endEvents.push(baseEvents[styleName]);\n        break;\n      }\n    }\n  }\n}\n\nif (ExecutionEnvironment.canUseDOM) {\n  detectEvents();\n}\n\n// We use the raw {add|remove}EventListener() call because EventListener\n// does not know how to remove event listeners and we really should\n// clean up. Also, these events are not triggered in older browsers\n// so we should be A-OK here.\n\nfunction addEventListener(node, eventName, eventListener) {\n  node.addEventListener(eventName, eventListener, false);\n}\n\nfunction removeEventListener(node, eventName, eventListener) {\n  node.removeEventListener(eventName, eventListener, false);\n}\n\nvar ReactTransitionEvents = {\n  addEndEventListener: function(node, eventListener) {\n    if (endEvents.length === 0) {\n      // If CSS transitions are not supported, trigger an \"end animation\"\n      // event immediately.\n      window.setTimeout(eventListener, 0);\n      return;\n    }\n    endEvents.forEach(function(endEvent) {\n      addEventListener(node, endEvent, eventListener);\n    });\n  },\n\n  removeEndEventListener: function(node, eventListener) {\n    if (endEvents.length === 0) {\n      return;\n    }\n    endEvents.forEach(function(endEvent) {\n      removeEventListener(node, endEvent, eventListener);\n    });\n  }\n};\n\nmodule.exports = ReactTransitionEvents;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactTransitionEvents.js\n ** module id = 167\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactTransitionEvents.js?")},/*!****************************************!*\
  !*** ./~/react/lib/ReactWithAddons.js ***!
  \****************************************/
function(module,exports,__webpack_require__){eval('/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactWithAddons\n */\n\n/**\n * This module exists purely in the open source project, and is meant as a way\n * to create a separate standalone build of React. This build has "addons", or\n * functionality we\'ve built and think might be useful but doesn\'t have a good\n * place to live inside React core.\n */\n\n\'use strict\';\n\nvar LinkedStateMixin = __webpack_require__(/*! ./LinkedStateMixin */ 134);\nvar React = __webpack_require__(/*! ./React */ 20);\nvar ReactComponentWithPureRenderMixin =\n  __webpack_require__(/*! ./ReactComponentWithPureRenderMixin */ 139);\nvar ReactCSSTransitionGroup = __webpack_require__(/*! ./ReactCSSTransitionGroup */ 136);\nvar ReactFragment = __webpack_require__(/*! ./ReactFragment */ 22);\nvar ReactTransitionGroup = __webpack_require__(/*! ./ReactTransitionGroup */ 84);\nvar ReactUpdates = __webpack_require__(/*! ./ReactUpdates */ 9);\n\nvar cx = __webpack_require__(/*! ./cx */ 187);\nvar cloneWithProps = __webpack_require__(/*! ./cloneWithProps */ 86);\nvar update = __webpack_require__(/*! ./update */ 203);\n\nReact.addons = {\n  CSSTransitionGroup: ReactCSSTransitionGroup,\n  LinkedStateMixin: LinkedStateMixin,\n  PureRenderMixin: ReactComponentWithPureRenderMixin,\n  TransitionGroup: ReactTransitionGroup,\n\n  batchedUpdates: ReactUpdates.batchedUpdates,\n  classSet: cx,\n  cloneWithProps: cloneWithProps,\n  createFragment: ReactFragment.create,\n  update: update\n};\n\nif (false) {\n  React.addons.Perf = require("./ReactDefaultPerf");\n  React.addons.TestUtils = require("./ReactTestUtils");\n}\n\nmodule.exports = React;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactWithAddons.js\n ** module id = 168\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactWithAddons.js?')},/*!*********************************************!*\
  !*** ./~/react/lib/SVGDOMPropertyConfig.js ***!
  \*********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SVGDOMPropertyConfig\n */\n\n/*jslint bitwise: true*/\n\n'use strict';\n\nvar DOMProperty = __webpack_require__(/*! ./DOMProperty */ 19);\n\nvar MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;\n\nvar SVGDOMPropertyConfig = {\n  Properties: {\n    clipPath: MUST_USE_ATTRIBUTE,\n    cx: MUST_USE_ATTRIBUTE,\n    cy: MUST_USE_ATTRIBUTE,\n    d: MUST_USE_ATTRIBUTE,\n    dx: MUST_USE_ATTRIBUTE,\n    dy: MUST_USE_ATTRIBUTE,\n    fill: MUST_USE_ATTRIBUTE,\n    fillOpacity: MUST_USE_ATTRIBUTE,\n    fontFamily: MUST_USE_ATTRIBUTE,\n    fontSize: MUST_USE_ATTRIBUTE,\n    fx: MUST_USE_ATTRIBUTE,\n    fy: MUST_USE_ATTRIBUTE,\n    gradientTransform: MUST_USE_ATTRIBUTE,\n    gradientUnits: MUST_USE_ATTRIBUTE,\n    markerEnd: MUST_USE_ATTRIBUTE,\n    markerMid: MUST_USE_ATTRIBUTE,\n    markerStart: MUST_USE_ATTRIBUTE,\n    offset: MUST_USE_ATTRIBUTE,\n    opacity: MUST_USE_ATTRIBUTE,\n    patternContentUnits: MUST_USE_ATTRIBUTE,\n    patternUnits: MUST_USE_ATTRIBUTE,\n    points: MUST_USE_ATTRIBUTE,\n    preserveAspectRatio: MUST_USE_ATTRIBUTE,\n    r: MUST_USE_ATTRIBUTE,\n    rx: MUST_USE_ATTRIBUTE,\n    ry: MUST_USE_ATTRIBUTE,\n    spreadMethod: MUST_USE_ATTRIBUTE,\n    stopColor: MUST_USE_ATTRIBUTE,\n    stopOpacity: MUST_USE_ATTRIBUTE,\n    stroke: MUST_USE_ATTRIBUTE,\n    strokeDasharray: MUST_USE_ATTRIBUTE,\n    strokeLinecap: MUST_USE_ATTRIBUTE,\n    strokeOpacity: MUST_USE_ATTRIBUTE,\n    strokeWidth: MUST_USE_ATTRIBUTE,\n    textAnchor: MUST_USE_ATTRIBUTE,\n    transform: MUST_USE_ATTRIBUTE,\n    version: MUST_USE_ATTRIBUTE,\n    viewBox: MUST_USE_ATTRIBUTE,\n    x1: MUST_USE_ATTRIBUTE,\n    x2: MUST_USE_ATTRIBUTE,\n    x: MUST_USE_ATTRIBUTE,\n    y1: MUST_USE_ATTRIBUTE,\n    y2: MUST_USE_ATTRIBUTE,\n    y: MUST_USE_ATTRIBUTE\n  },\n  DOMAttributeNames: {\n    clipPath: 'clip-path',\n    fillOpacity: 'fill-opacity',\n    fontFamily: 'font-family',\n    fontSize: 'font-size',\n    gradientTransform: 'gradientTransform',\n    gradientUnits: 'gradientUnits',\n    markerEnd: 'marker-end',\n    markerMid: 'marker-mid',\n    markerStart: 'marker-start',\n    patternContentUnits: 'patternContentUnits',\n    patternUnits: 'patternUnits',\n    preserveAspectRatio: 'preserveAspectRatio',\n    spreadMethod: 'spreadMethod',\n    stopColor: 'stop-color',\n    stopOpacity: 'stop-opacity',\n    strokeDasharray: 'stroke-dasharray',\n    strokeLinecap: 'stroke-linecap',\n    strokeOpacity: 'stroke-opacity',\n    strokeWidth: 'stroke-width',\n    textAnchor: 'text-anchor',\n    viewBox: 'viewBox'\n  }\n};\n\nmodule.exports = SVGDOMPropertyConfig;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SVGDOMPropertyConfig.js\n ** module id = 169\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SVGDOMPropertyConfig.js?")},/*!******************************************!*\
  !*** ./~/react/lib/SelectEventPlugin.js ***!
  \******************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SelectEventPlugin\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(/*! ./EventConstants */ 7);\nvar EventPropagators = __webpack_require__(/*! ./EventPropagators */ 31);\nvar ReactInputSelection = __webpack_require__(/*! ./ReactInputSelection */ 78);\nvar SyntheticEvent = __webpack_require__(/*! ./SyntheticEvent */ 18);\n\nvar getActiveElement = __webpack_require__(/*! ./getActiveElement */ 90);\nvar isTextInputElement = __webpack_require__(/*! ./isTextInputElement */ 95);\nvar keyOf = __webpack_require__(/*! ./keyOf */ 11);\nvar shallowEqual = __webpack_require__(/*! ./shallowEqual */ 97);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\nvar eventTypes = {\n  select: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onSelect: null}),\n      captured: keyOf({onSelectCapture: null})\n    },\n    dependencies: [\n      topLevelTypes.topBlur,\n      topLevelTypes.topContextMenu,\n      topLevelTypes.topFocus,\n      topLevelTypes.topKeyDown,\n      topLevelTypes.topMouseDown,\n      topLevelTypes.topMouseUp,\n      topLevelTypes.topSelectionChange\n    ]\n  }\n};\n\nvar activeElement = null;\nvar activeElementID = null;\nvar lastSelection = null;\nvar mouseDown = false;\n\n/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n *\n * @param {DOMElement} node\n * @param {object}\n */\nfunction getSelection(node) {\n  if ('selectionStart' in node &&\n      ReactInputSelection.hasSelectionCapabilities(node)) {\n    return {\n      start: node.selectionStart,\n      end: node.selectionEnd\n    };\n  } else if (window.getSelection) {\n    var selection = window.getSelection();\n    return {\n      anchorNode: selection.anchorNode,\n      anchorOffset: selection.anchorOffset,\n      focusNode: selection.focusNode,\n      focusOffset: selection.focusOffset\n    };\n  } else if (document.selection) {\n    var range = document.selection.createRange();\n    return {\n      parentElement: range.parentElement(),\n      text: range.text,\n      top: range.boundingTop,\n      left: range.boundingLeft\n    };\n  }\n}\n\n/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @return {?SyntheticEvent}\n */\nfunction constructSelectEvent(nativeEvent) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  if (mouseDown ||\n      activeElement == null ||\n      activeElement !== getActiveElement()) {\n    return null;\n  }\n\n  // Only fire when selection has actually changed.\n  var currentSelection = getSelection(activeElement);\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n\n    var syntheticEvent = SyntheticEvent.getPooled(\n      eventTypes.select,\n      activeElementID,\n      nativeEvent\n    );\n\n    syntheticEvent.type = 'select';\n    syntheticEvent.target = activeElement;\n\n    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);\n\n    return syntheticEvent;\n  }\n}\n\n/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */\nvar SelectEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n\n    switch (topLevelType) {\n      // Track the input node that has focus.\n      case topLevelTypes.topFocus:\n        if (isTextInputElement(topLevelTarget) ||\n            topLevelTarget.contentEditable === 'true') {\n          activeElement = topLevelTarget;\n          activeElementID = topLevelTargetID;\n          lastSelection = null;\n        }\n        break;\n      case topLevelTypes.topBlur:\n        activeElement = null;\n        activeElementID = null;\n        lastSelection = null;\n        break;\n\n      // Don't fire the event while the user is dragging. This matches the\n      // semantics of the native select event.\n      case topLevelTypes.topMouseDown:\n        mouseDown = true;\n        break;\n      case topLevelTypes.topContextMenu:\n      case topLevelTypes.topMouseUp:\n        mouseDown = false;\n        return constructSelectEvent(nativeEvent);\n\n      // Chrome and IE fire non-standard event when selection is changed (and\n      // sometimes when it hasn't).\n      // Firefox doesn't support selectionchange, so check selection status\n      // after each key entry. The selection changes after keydown and before\n      // keyup, but we check on keydown as well in the case of holding down a\n      // key, when multiple keydown events are fired but only one keyup is.\n      case topLevelTypes.topSelectionChange:\n      case topLevelTypes.topKeyDown:\n      case topLevelTypes.topKeyUp:\n        return constructSelectEvent(nativeEvent);\n    }\n  }\n};\n\nmodule.exports = SelectEventPlugin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SelectEventPlugin.js\n ** module id = 170\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SelectEventPlugin.js?")},/*!*********************************************!*\
  !*** ./~/react/lib/ServerReactRootIndex.js ***!
  \*********************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ServerReactRootIndex\n * @typechecks\n */\n\n'use strict';\n\n/**\n * Size of the reactRoot ID space. We generate random numbers for React root\n * IDs and if there's a collision the events and DOM update system will\n * get confused. In the future we need a way to generate GUIDs but for\n * now this will work on a smaller scale.\n */\nvar GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);\n\nvar ServerReactRootIndex = {\n  createReactRootIndex: function() {\n    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);\n  }\n};\n\nmodule.exports = ServerReactRootIndex;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ServerReactRootIndex.js\n ** module id = 171\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ServerReactRootIndex.js?")},/*!******************************************!*\
  !*** ./~/react/lib/SimpleEventPlugin.js ***!
  \******************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SimpleEventPlugin\n */\n\n'use strict';\n\nvar EventConstants = __webpack_require__(/*! ./EventConstants */ 7);\nvar EventPluginUtils = __webpack_require__(/*! ./EventPluginUtils */ 46);\nvar EventPropagators = __webpack_require__(/*! ./EventPropagators */ 31);\nvar SyntheticClipboardEvent = __webpack_require__(/*! ./SyntheticClipboardEvent */ 173);\nvar SyntheticEvent = __webpack_require__(/*! ./SyntheticEvent */ 18);\nvar SyntheticFocusEvent = __webpack_require__(/*! ./SyntheticFocusEvent */ 176);\nvar SyntheticKeyboardEvent = __webpack_require__(/*! ./SyntheticKeyboardEvent */ 178);\nvar SyntheticMouseEvent = __webpack_require__(/*! ./SyntheticMouseEvent */ 40);\nvar SyntheticDragEvent = __webpack_require__(/*! ./SyntheticDragEvent */ 175);\nvar SyntheticTouchEvent = __webpack_require__(/*! ./SyntheticTouchEvent */ 179);\nvar SyntheticUIEvent = __webpack_require__(/*! ./SyntheticUIEvent */ 33);\nvar SyntheticWheelEvent = __webpack_require__(/*! ./SyntheticWheelEvent */ 180);\n\nvar getEventCharCode = __webpack_require__(/*! ./getEventCharCode */ 59);\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\nvar keyOf = __webpack_require__(/*! ./keyOf */ 11);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\nvar eventTypes = {\n  blur: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onBlur: true}),\n      captured: keyOf({onBlurCapture: true})\n    }\n  },\n  click: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onClick: true}),\n      captured: keyOf({onClickCapture: true})\n    }\n  },\n  contextMenu: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onContextMenu: true}),\n      captured: keyOf({onContextMenuCapture: true})\n    }\n  },\n  copy: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onCopy: true}),\n      captured: keyOf({onCopyCapture: true})\n    }\n  },\n  cut: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onCut: true}),\n      captured: keyOf({onCutCapture: true})\n    }\n  },\n  doubleClick: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDoubleClick: true}),\n      captured: keyOf({onDoubleClickCapture: true})\n    }\n  },\n  drag: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDrag: true}),\n      captured: keyOf({onDragCapture: true})\n    }\n  },\n  dragEnd: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDragEnd: true}),\n      captured: keyOf({onDragEndCapture: true})\n    }\n  },\n  dragEnter: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDragEnter: true}),\n      captured: keyOf({onDragEnterCapture: true})\n    }\n  },\n  dragExit: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDragExit: true}),\n      captured: keyOf({onDragExitCapture: true})\n    }\n  },\n  dragLeave: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDragLeave: true}),\n      captured: keyOf({onDragLeaveCapture: true})\n    }\n  },\n  dragOver: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDragOver: true}),\n      captured: keyOf({onDragOverCapture: true})\n    }\n  },\n  dragStart: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDragStart: true}),\n      captured: keyOf({onDragStartCapture: true})\n    }\n  },\n  drop: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDrop: true}),\n      captured: keyOf({onDropCapture: true})\n    }\n  },\n  focus: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onFocus: true}),\n      captured: keyOf({onFocusCapture: true})\n    }\n  },\n  input: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onInput: true}),\n      captured: keyOf({onInputCapture: true})\n    }\n  },\n  keyDown: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onKeyDown: true}),\n      captured: keyOf({onKeyDownCapture: true})\n    }\n  },\n  keyPress: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onKeyPress: true}),\n      captured: keyOf({onKeyPressCapture: true})\n    }\n  },\n  keyUp: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onKeyUp: true}),\n      captured: keyOf({onKeyUpCapture: true})\n    }\n  },\n  load: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onLoad: true}),\n      captured: keyOf({onLoadCapture: true})\n    }\n  },\n  error: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onError: true}),\n      captured: keyOf({onErrorCapture: true})\n    }\n  },\n  // Note: We do not allow listening to mouseOver events. Instead, use the\n  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.\n  mouseDown: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onMouseDown: true}),\n      captured: keyOf({onMouseDownCapture: true})\n    }\n  },\n  mouseMove: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onMouseMove: true}),\n      captured: keyOf({onMouseMoveCapture: true})\n    }\n  },\n  mouseOut: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onMouseOut: true}),\n      captured: keyOf({onMouseOutCapture: true})\n    }\n  },\n  mouseOver: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onMouseOver: true}),\n      captured: keyOf({onMouseOverCapture: true})\n    }\n  },\n  mouseUp: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onMouseUp: true}),\n      captured: keyOf({onMouseUpCapture: true})\n    }\n  },\n  paste: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onPaste: true}),\n      captured: keyOf({onPasteCapture: true})\n    }\n  },\n  reset: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onReset: true}),\n      captured: keyOf({onResetCapture: true})\n    }\n  },\n  scroll: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onScroll: true}),\n      captured: keyOf({onScrollCapture: true})\n    }\n  },\n  submit: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onSubmit: true}),\n      captured: keyOf({onSubmitCapture: true})\n    }\n  },\n  touchCancel: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onTouchCancel: true}),\n      captured: keyOf({onTouchCancelCapture: true})\n    }\n  },\n  touchEnd: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onTouchEnd: true}),\n      captured: keyOf({onTouchEndCapture: true})\n    }\n  },\n  touchMove: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onTouchMove: true}),\n      captured: keyOf({onTouchMoveCapture: true})\n    }\n  },\n  touchStart: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onTouchStart: true}),\n      captured: keyOf({onTouchStartCapture: true})\n    }\n  },\n  wheel: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onWheel: true}),\n      captured: keyOf({onWheelCapture: true})\n    }\n  }\n};\n\nvar topLevelEventsToDispatchConfig = {\n  topBlur:        eventTypes.blur,\n  topClick:       eventTypes.click,\n  topContextMenu: eventTypes.contextMenu,\n  topCopy:        eventTypes.copy,\n  topCut:         eventTypes.cut,\n  topDoubleClick: eventTypes.doubleClick,\n  topDrag:        eventTypes.drag,\n  topDragEnd:     eventTypes.dragEnd,\n  topDragEnter:   eventTypes.dragEnter,\n  topDragExit:    eventTypes.dragExit,\n  topDragLeave:   eventTypes.dragLeave,\n  topDragOver:    eventTypes.dragOver,\n  topDragStart:   eventTypes.dragStart,\n  topDrop:        eventTypes.drop,\n  topError:       eventTypes.error,\n  topFocus:       eventTypes.focus,\n  topInput:       eventTypes.input,\n  topKeyDown:     eventTypes.keyDown,\n  topKeyPress:    eventTypes.keyPress,\n  topKeyUp:       eventTypes.keyUp,\n  topLoad:        eventTypes.load,\n  topMouseDown:   eventTypes.mouseDown,\n  topMouseMove:   eventTypes.mouseMove,\n  topMouseOut:    eventTypes.mouseOut,\n  topMouseOver:   eventTypes.mouseOver,\n  topMouseUp:     eventTypes.mouseUp,\n  topPaste:       eventTypes.paste,\n  topReset:       eventTypes.reset,\n  topScroll:      eventTypes.scroll,\n  topSubmit:      eventTypes.submit,\n  topTouchCancel: eventTypes.touchCancel,\n  topTouchEnd:    eventTypes.touchEnd,\n  topTouchMove:   eventTypes.touchMove,\n  topTouchStart:  eventTypes.touchStart,\n  topWheel:       eventTypes.wheel\n};\n\nfor (var type in topLevelEventsToDispatchConfig) {\n  topLevelEventsToDispatchConfig[type].dependencies = [type];\n}\n\nvar SimpleEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  /**\n   * Same as the default implementation, except cancels the event when return\n   * value is false. This behavior will be disabled in a future release.\n   *\n   * @param {object} Event to be dispatched.\n   * @param {function} Application-level callback.\n   * @param {string} domID DOM ID to pass to the callback.\n   */\n  executeDispatch: function(event, listener, domID) {\n    var returnValue = EventPluginUtils.executeDispatch(event, listener, domID);\n\n    (false ? warning(\n      typeof returnValue !== 'boolean',\n      'Returning `false` from an event handler is deprecated and will be ' +\n      'ignored in a future release. Instead, manually call ' +\n      'e.stopPropagation() or e.preventDefault(), as appropriate.'\n    ) : null);\n\n    if (returnValue === false) {\n      event.stopPropagation();\n      event.preventDefault();\n    }\n  },\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];\n    if (!dispatchConfig) {\n      return null;\n    }\n    var EventConstructor;\n    switch (topLevelType) {\n      case topLevelTypes.topInput:\n      case topLevelTypes.topLoad:\n      case topLevelTypes.topError:\n      case topLevelTypes.topReset:\n      case topLevelTypes.topSubmit:\n        // HTML Events\n        // @see http://www.w3.org/TR/html5/index.html#events-0\n        EventConstructor = SyntheticEvent;\n        break;\n      case topLevelTypes.topKeyPress:\n        // FireFox creates a keypress event for function keys too. This removes\n        // the unwanted keypress events. Enter is however both printable and\n        // non-printable. One would expect Tab to be as well (but it isn't).\n        if (getEventCharCode(nativeEvent) === 0) {\n          return null;\n        }\n        /* falls through */\n      case topLevelTypes.topKeyDown:\n      case topLevelTypes.topKeyUp:\n        EventConstructor = SyntheticKeyboardEvent;\n        break;\n      case topLevelTypes.topBlur:\n      case topLevelTypes.topFocus:\n        EventConstructor = SyntheticFocusEvent;\n        break;\n      case topLevelTypes.topClick:\n        // Firefox creates a click event on right mouse clicks. This removes the\n        // unwanted click events.\n        if (nativeEvent.button === 2) {\n          return null;\n        }\n        /* falls through */\n      case topLevelTypes.topContextMenu:\n      case topLevelTypes.topDoubleClick:\n      case topLevelTypes.topMouseDown:\n      case topLevelTypes.topMouseMove:\n      case topLevelTypes.topMouseOut:\n      case topLevelTypes.topMouseOver:\n      case topLevelTypes.topMouseUp:\n        EventConstructor = SyntheticMouseEvent;\n        break;\n      case topLevelTypes.topDrag:\n      case topLevelTypes.topDragEnd:\n      case topLevelTypes.topDragEnter:\n      case topLevelTypes.topDragExit:\n      case topLevelTypes.topDragLeave:\n      case topLevelTypes.topDragOver:\n      case topLevelTypes.topDragStart:\n      case topLevelTypes.topDrop:\n        EventConstructor = SyntheticDragEvent;\n        break;\n      case topLevelTypes.topTouchCancel:\n      case topLevelTypes.topTouchEnd:\n      case topLevelTypes.topTouchMove:\n      case topLevelTypes.topTouchStart:\n        EventConstructor = SyntheticTouchEvent;\n        break;\n      case topLevelTypes.topScroll:\n        EventConstructor = SyntheticUIEvent;\n        break;\n      case topLevelTypes.topWheel:\n        EventConstructor = SyntheticWheelEvent;\n        break;\n      case topLevelTypes.topCopy:\n      case topLevelTypes.topCut:\n      case topLevelTypes.topPaste:\n        EventConstructor = SyntheticClipboardEvent;\n        break;\n    }\n    (false ? invariant(\n      EventConstructor,\n      'SimpleEventPlugin: Unhandled event type, `%s`.',\n      topLevelType\n    ) : invariant(EventConstructor));\n    var event = EventConstructor.getPooled(\n      dispatchConfig,\n      topLevelTargetID,\n      nativeEvent\n    );\n    EventPropagators.accumulateTwoPhaseDispatches(event);\n    return event;\n  }\n\n};\n\nmodule.exports = SimpleEventPlugin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SimpleEventPlugin.js\n ** module id = 172\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SimpleEventPlugin.js?")},/*!************************************************!*\
  !*** ./~/react/lib/SyntheticClipboardEvent.js ***!
  \************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticClipboardEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticEvent = __webpack_require__(/*! ./SyntheticEvent */ 18);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */\nvar ClipboardEventInterface = {\n  clipboardData: function(event) {\n    return (\n      'clipboardData' in event ?\n        event.clipboardData :\n        window.clipboardData\n    );\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);\n\nmodule.exports = SyntheticClipboardEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticClipboardEvent.js\n ** module id = 173\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticClipboardEvent.js?")},/*!**************************************************!*\
  !*** ./~/react/lib/SyntheticCompositionEvent.js ***!
  \**************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticCompositionEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticEvent = __webpack_require__(/*! ./SyntheticEvent */ 18);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */\nvar CompositionEventInterface = {\n  data: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticCompositionEvent(\n  dispatchConfig,\n  dispatchMarker,\n  nativeEvent) {\n  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticEvent.augmentClass(\n  SyntheticCompositionEvent,\n  CompositionEventInterface\n);\n\nmodule.exports = SyntheticCompositionEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticCompositionEvent.js\n ** module id = 174\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticCompositionEvent.js?")},/*!*******************************************!*\
  !*** ./~/react/lib/SyntheticDragEvent.js ***!
  \*******************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticDragEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticMouseEvent = __webpack_require__(/*! ./SyntheticMouseEvent */ 40);\n\n/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar DragEventInterface = {\n  dataTransfer: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);\n\nmodule.exports = SyntheticDragEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticDragEvent.js\n ** module id = 175\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticDragEvent.js?")},/*!********************************************!*\
  !*** ./~/react/lib/SyntheticFocusEvent.js ***!
  \********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticFocusEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticUIEvent = __webpack_require__(/*! ./SyntheticUIEvent */ 33);\n\n/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar FocusEventInterface = {\n  relatedTarget: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);\n\nmodule.exports = SyntheticFocusEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticFocusEvent.js\n ** module id = 176\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticFocusEvent.js?")},/*!********************************************!*\
  !*** ./~/react/lib/SyntheticInputEvent.js ***!
  \********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticInputEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticEvent = __webpack_require__(/*! ./SyntheticEvent */ 18);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */\nvar InputEventInterface = {\n  data: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticInputEvent(\n  dispatchConfig,\n  dispatchMarker,\n  nativeEvent) {\n  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticEvent.augmentClass(\n  SyntheticInputEvent,\n  InputEventInterface\n);\n\nmodule.exports = SyntheticInputEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticInputEvent.js\n ** module id = 177\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticInputEvent.js?")},/*!***********************************************!*\
  !*** ./~/react/lib/SyntheticKeyboardEvent.js ***!
  \***********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticKeyboardEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticUIEvent = __webpack_require__(/*! ./SyntheticUIEvent */ 33);\n\nvar getEventCharCode = __webpack_require__(/*! ./getEventCharCode */ 59);\nvar getEventKey = __webpack_require__(/*! ./getEventKey */ 190);\nvar getEventModifierState = __webpack_require__(/*! ./getEventModifierState */ 60);\n\n/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar KeyboardEventInterface = {\n  key: getEventKey,\n  location: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  repeat: null,\n  locale: null,\n  getModifierState: getEventModifierState,\n  // Legacy Interface\n  charCode: function(event) {\n    // `charCode` is the result of a KeyPress event and represents the value of\n    // the actual printable character.\n\n    // KeyPress is deprecated, but its replacement is not yet final and not\n    // implemented in any major browser. Only KeyPress has charCode.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    return 0;\n  },\n  keyCode: function(event) {\n    // `keyCode` is the result of a KeyDown/Up event and represents the value of\n    // physical keyboard key.\n\n    // The actual meaning of the value depends on the users' keyboard layout\n    // which cannot be detected. Assuming that it is a US keyboard layout\n    // provides a surprisingly accurate mapping for US and European users.\n    // Due to this, it is left to the user to implement at this time.\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  },\n  which: function(event) {\n    // `which` is an alias for either `keyCode` or `charCode` depending on the\n    // type of the event.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);\n\nmodule.exports = SyntheticKeyboardEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticKeyboardEvent.js\n ** module id = 178\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticKeyboardEvent.js?")},/*!********************************************!*\
  !*** ./~/react/lib/SyntheticTouchEvent.js ***!
  \********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticTouchEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticUIEvent = __webpack_require__(/*! ./SyntheticUIEvent */ 33);\n\nvar getEventModifierState = __webpack_require__(/*! ./getEventModifierState */ 60);\n\n/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */\nvar TouchEventInterface = {\n  touches: null,\n  targetTouches: null,\n  changedTouches: null,\n  altKey: null,\n  metaKey: null,\n  ctrlKey: null,\n  shiftKey: null,\n  getModifierState: getEventModifierState\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);\n\nmodule.exports = SyntheticTouchEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticTouchEvent.js\n ** module id = 179\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticTouchEvent.js?")},/*!********************************************!*\
  !*** ./~/react/lib/SyntheticWheelEvent.js ***!
  \********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticWheelEvent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar SyntheticMouseEvent = __webpack_require__(/*! ./SyntheticMouseEvent */ 40);\n\n/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar WheelEventInterface = {\n  deltaX: function(event) {\n    return (\n      'deltaX' in event ? event.deltaX :\n      // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n      'wheelDeltaX' in event ? -event.wheelDeltaX : 0\n    );\n  },\n  deltaY: function(event) {\n    return (\n      'deltaY' in event ? event.deltaY :\n      // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n      'wheelDeltaY' in event ? -event.wheelDeltaY :\n      // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n      'wheelDelta' in event ? -event.wheelDelta : 0\n    );\n  },\n  deltaZ: null,\n\n  // Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n  // notch on the scroll is always +/- 120, roughly equivalent to pixels.\n  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\n  deltaMode: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticMouseEvent}\n */\nfunction SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);\n\nmodule.exports = SyntheticWheelEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticWheelEvent.js\n ** module id = 180\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticWheelEvent.js?")},/*!********************************!*\
  !*** ./~/react/lib/adler32.js ***!
  \********************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule adler32\n */\n\n/* jslint bitwise:true */\n\n'use strict';\n\nvar MOD = 65521;\n\n// This is a clean-room implementation of adler32 designed for detecting\n// if markup is not what we expect it to be. It does not need to be\n// cryptographically strong, only reasonably good at detecting if markup\n// generated on the server is different than that on the client.\nfunction adler32(data) {\n  var a = 1;\n  var b = 0;\n  for (var i = 0; i < data.length; i++) {\n    a = (a + data.charCodeAt(i)) % MOD;\n    b = (b + a) % MOD;\n  }\n  return a | (b << 16);\n}\n\nmodule.exports = adler32;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/adler32.js\n ** module id = 181\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/adler32.js?")},/*!*********************************!*\
  !*** ./~/react/lib/camelize.js ***!
  \*********************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule camelize\n * @typechecks\n */\n\nvar _hyphenPattern = /-(.)/g;\n\n/**\n * Camelcases a hyphenated string, for example:\n *\n *   > camelize('background-color')\n *   < \"backgroundColor\"\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelize(string) {\n  return string.replace(_hyphenPattern, function(_, character) {\n    return character.toUpperCase();\n  });\n}\n\nmodule.exports = camelize;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/camelize.js\n ** module id = 182\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/camelize.js?")},/*!******************************************!*\
  !*** ./~/react/lib/camelizeStyleName.js ***!
  \******************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule camelizeStyleName\n * @typechecks\n */\n\n\"use strict\";\n\nvar camelize = __webpack_require__(/*! ./camelize */ 182);\n\nvar msPattern = /^-ms-/;\n\n/**\n * Camelcases a hyphenated CSS property name, for example:\n *\n *   > camelizeStyleName('background-color')\n *   < \"backgroundColor\"\n *   > camelizeStyleName('-moz-transition')\n *   < \"MozTransition\"\n *   > camelizeStyleName('-ms-transition')\n *   < \"msTransition\"\n *\n * As Andi Smith suggests\n * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n * is converted to lowercase `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelizeStyleName(string) {\n  return camelize(string.replace(msPattern, 'ms-'));\n}\n\nmodule.exports = camelizeStyleName;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/camelizeStyleName.js\n ** module id = 183\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/camelizeStyleName.js?")},/*!*********************************************!*\
  !*** ./~/react/lib/createArrayFromMixed.js ***!
  \*********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule createArrayFromMixed\n * @typechecks\n */\n\nvar toArray = __webpack_require__(/*! ./toArray */ 202);\n\n/**\n * Perform a heuristic test to determine if an object is \"array-like\".\n *\n *   A monk asked Joshu, a Zen master, \"Has a dog Buddha nature?\"\n *   Joshu replied: \"Mu.\"\n *\n * This function determines if its argument has \"array nature\": it returns\n * true if the argument is an actual array, an `arguments' object, or an\n * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).\n *\n * It will return false for other array-like objects like Filelist.\n *\n * @param {*} obj\n * @return {boolean}\n */\nfunction hasArrayNature(obj) {\n  return (\n    // not null/false\n    !!obj &&\n    // arrays are objects, NodeLists are functions in Safari\n    (typeof obj == 'object' || typeof obj == 'function') &&\n    // quacks like an array\n    ('length' in obj) &&\n    // not window\n    !('setInterval' in obj) &&\n    // no DOM node should be considered an array-like\n    // a 'select' element has 'length' and 'item' properties on IE8\n    (typeof obj.nodeType != 'number') &&\n    (\n      // a real array\n      (// HTMLCollection/NodeList\n      (Array.isArray(obj) ||\n      // arguments\n      ('callee' in obj) || 'item' in obj))\n    )\n  );\n}\n\n/**\n * Ensure that the argument is an array by wrapping it in an array if it is not.\n * Creates a copy of the argument if it is already an array.\n *\n * This is mostly useful idiomatically:\n *\n *   var createArrayFromMixed = require('createArrayFromMixed');\n *\n *   function takesOneOrMoreThings(things) {\n *     things = createArrayFromMixed(things);\n *     ...\n *   }\n *\n * This allows you to treat `things' as an array, but accept scalars in the API.\n *\n * If you need to convert an array-like object, like `arguments`, into an array\n * use toArray instead.\n *\n * @param {*} obj\n * @return {array}\n */\nfunction createArrayFromMixed(obj) {\n  if (!hasArrayNature(obj)) {\n    return [obj];\n  } else if (Array.isArray(obj)) {\n    return obj.slice();\n  } else {\n    return toArray(obj);\n  }\n}\n\nmodule.exports = createArrayFromMixed;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/createArrayFromMixed.js\n ** module id = 184\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/createArrayFromMixed.js?")},/*!************************************************!*\
  !*** ./~/react/lib/createFullPageComponent.js ***!
  \************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule createFullPageComponent\n * @typechecks\n */\n\n'use strict';\n\n// Defeat circular references by requiring this directly.\nvar ReactClass = __webpack_require__(/*! ./ReactClass */ 8);\nvar ReactElement = __webpack_require__(/*! ./ReactElement */ 4);\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\n/**\n * Create a component that will throw an exception when unmounted.\n *\n * Components like <html> <head> and <body> can't be removed or added\n * easily in a cross-browser way, however it's valuable to be able to\n * take advantage of React's reconciliation for styling and <title>\n * management. So we just document it and throw in dangerous cases.\n *\n * @param {string} tag The tag to wrap\n * @return {function} convenience constructor of new component\n */\nfunction createFullPageComponent(tag) {\n  var elementFactory = ReactElement.createFactory(tag);\n\n  var FullPageComponent = ReactClass.createClass({\n    tagName: tag.toUpperCase(),\n    displayName: 'ReactFullPageComponent' + tag,\n\n    componentWillUnmount: function() {\n      (false ? invariant(\n        false,\n        '%s tried to unmount. Because of cross-browser quirks it is ' +\n        'impossible to unmount some top-level components (eg <html>, <head>, ' +\n        'and <body>) reliably and efficiently. To fix this, have a single ' +\n        'top-level component that never unmounts render these elements.',\n        this.constructor.displayName\n      ) : invariant(false));\n    },\n\n    render: function() {\n      return elementFactory(this.props);\n    }\n  });\n\n  return FullPageComponent;\n}\n\nmodule.exports = createFullPageComponent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/createFullPageComponent.js\n ** module id = 185\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/createFullPageComponent.js?")},/*!**********************************************!*\
  !*** ./~/react/lib/createNodesFromMarkup.js ***!
  \**********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule createNodesFromMarkup\n * @typechecks\n */\n\n/*jslint evil: true, sub: true */\n\nvar ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ 6);\n\nvar createArrayFromMixed = __webpack_require__(/*! ./createArrayFromMixed */ 184);\nvar getMarkupWrap = __webpack_require__(/*! ./getMarkupWrap */ 92);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\n/**\n * Dummy container used to render all markup.\n */\nvar dummyNode =\n  ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;\n\n/**\n * Pattern used by `getNodeName`.\n */\nvar nodeNamePattern = /^\\s*<(\\w+)/;\n\n/**\n * Extracts the `nodeName` of the first element in a string of markup.\n *\n * @param {string} markup String of markup.\n * @return {?string} Node name of the supplied markup.\n */\nfunction getNodeName(markup) {\n  var nodeNameMatch = markup.match(nodeNamePattern);\n  return nodeNameMatch && nodeNameMatch[1].toLowerCase();\n}\n\n/**\n * Creates an array containing the nodes rendered from the supplied markup. The\n * optionally supplied `handleScript` function will be invoked once for each\n * <script> element that is rendered. If no `handleScript` function is supplied,\n * an exception is thrown if any <script> elements are rendered.\n *\n * @param {string} markup A string of valid HTML markup.\n * @param {?function} handleScript Invoked once for each rendered <script>.\n * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.\n */\nfunction createNodesFromMarkup(markup, handleScript) {\n  var node = dummyNode;\n  (false ? invariant(!!dummyNode, 'createNodesFromMarkup dummy not initialized') : invariant(!!dummyNode));\n  var nodeName = getNodeName(markup);\n\n  var wrap = nodeName && getMarkupWrap(nodeName);\n  if (wrap) {\n    node.innerHTML = wrap[1] + markup + wrap[2];\n\n    var wrapDepth = wrap[0];\n    while (wrapDepth--) {\n      node = node.lastChild;\n    }\n  } else {\n    node.innerHTML = markup;\n  }\n\n  var scripts = node.getElementsByTagName('script');\n  if (scripts.length) {\n    (false ? invariant(\n      handleScript,\n      'createNodesFromMarkup(...): Unexpected <script> element rendered.'\n    ) : invariant(handleScript));\n    createArrayFromMixed(scripts).forEach(handleScript);\n  }\n\n  var nodes = createArrayFromMixed(node.childNodes);\n  while (node.lastChild) {\n    node.removeChild(node.lastChild);\n  }\n  return nodes;\n}\n\nmodule.exports = createNodesFromMarkup;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/createNodesFromMarkup.js\n ** module id = 186\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/createNodesFromMarkup.js?")},/*!***************************!*\
  !*** ./~/react/lib/cx.js ***!
  \***************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule cx\n */\n\n/**\n * This function is used to mark string literals representing CSS class names\n * so that they can be transformed statically. This allows for modularization\n * and minification of CSS class names.\n *\n * In static_upstream, this function is actually implemented, but it should\n * eventually be replaced with something more descriptive, and the transform\n * that is used in the main stack should be ported for use elsewhere.\n *\n * @param string|object className to modularize, or an object of key/values.\n *                      In the object case, the values are conditions that\n *                      determine if the className keys should be included.\n * @param [string ...]  Variable list of classNames in the string case.\n * @return string       Renderable space-separated CSS className.\n */\n\n'use strict';\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\nvar warned = false;\n\nfunction cx(classNames) {\n  if (false) {\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      warned,\n      'React.addons.classSet will be deprecated in a future version. See ' +\n      'http://fb.me/react-addons-classset'\n    ) : null);\n    warned = true;\n  }\n\n  if (typeof classNames == 'object') {\n    return Object.keys(classNames).filter(function(className) {\n      return classNames[className];\n    }).join(' ');\n  } else {\n    return Array.prototype.join.call(arguments, ' ');\n  }\n}\n\nmodule.exports = cx;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/cx.js\n ** module id = 187\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/cx.js?")},/*!********************************************!*\
  !*** ./~/react/lib/dangerousStyleValue.js ***!
  \********************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule dangerousStyleValue\n * @typechecks static-only\n */\n\n'use strict';\n\nvar CSSProperty = __webpack_require__(/*! ./CSSProperty */ 71);\n\nvar isUnitlessNumber = CSSProperty.isUnitlessNumber;\n\n/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */\nfunction dangerousStyleValue(name, value) {\n  // Note that we've removed escapeTextForBrowser() calls here since the\n  // whole string will be escaped when the attribute is injected into\n  // the markup. If you provide unsafe user data here they can inject\n  // arbitrary CSS which may be problematic (I couldn't repro this):\n  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n  // This is not an XSS hole but instead a potential CSS injection issue\n  // which has lead to a greater discussion about how we're going to\n  // trust URLs moving forward. See #2115901\n\n  var isEmpty = value == null || typeof value === 'boolean' || value === '';\n  if (isEmpty) {\n    return '';\n  }\n\n  var isNonNumeric = isNaN(value);\n  if (isNonNumeric || value === 0 ||\n      isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {\n    return '' + value; // cast to string\n  }\n\n  if (typeof value === 'string') {\n    value = value.trim();\n  }\n  return value + 'px';\n}\n\nmodule.exports = dangerousStyleValue;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/dangerousStyleValue.js\n ** module id = 188\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/dangerousStyleValue.js?")},/*!****************************************!*\
  !*** ./~/react/lib/flattenChildren.js ***!
  \****************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule flattenChildren\n */\n\n'use strict';\n\nvar traverseAllChildren = __webpack_require__(/*! ./traverseAllChildren */ 98);\nvar warning = __webpack_require__(/*! ./warning */ 3);\n\n/**\n * @param {function} traverseContext Context passed through traversal.\n * @param {?ReactComponent} child React child component.\n * @param {!string} name String name of key path to child.\n */\nfunction flattenSingleChildIntoContext(traverseContext, child, name) {\n  // We found a component instance.\n  var result = traverseContext;\n  var keyUnique = !result.hasOwnProperty(name);\n  if (false) {\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      keyUnique,\n      'flattenChildren(...): Encountered two children with the same key, ' +\n      '`%s`. Child keys must be unique; when two children share a key, only ' +\n      'the first child will be used.',\n      name\n    ) : null);\n  }\n  if (keyUnique && child != null) {\n    result[name] = child;\n  }\n}\n\n/**\n * Flattens children that are typically specified as `props.children`. Any null\n * children will not be included in the resulting object.\n * @return {!object} flattened children keyed by name.\n */\nfunction flattenChildren(children) {\n  if (children == null) {\n    return children;\n  }\n  var result = {};\n  traverseAllChildren(children, flattenSingleChildIntoContext, result);\n  return result;\n}\n\nmodule.exports = flattenChildren;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/flattenChildren.js\n ** module id = 189\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/flattenChildren.js?")},/*!************************************!*\
  !*** ./~/react/lib/getEventKey.js ***!
  \************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getEventKey\n * @typechecks static-only\n */\n\n'use strict';\n\nvar getEventCharCode = __webpack_require__(/*! ./getEventCharCode */ 59);\n\n/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar normalizeKey = {\n  'Esc': 'Escape',\n  'Spacebar': ' ',\n  'Left': 'ArrowLeft',\n  'Up': 'ArrowUp',\n  'Right': 'ArrowRight',\n  'Down': 'ArrowDown',\n  'Del': 'Delete',\n  'Win': 'OS',\n  'Menu': 'ContextMenu',\n  'Apps': 'ContextMenu',\n  'Scroll': 'ScrollLock',\n  'MozPrintableKey': 'Unidentified'\n};\n\n/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar translateToKey = {\n  8: 'Backspace',\n  9: 'Tab',\n  12: 'Clear',\n  13: 'Enter',\n  16: 'Shift',\n  17: 'Control',\n  18: 'Alt',\n  19: 'Pause',\n  20: 'CapsLock',\n  27: 'Escape',\n  32: ' ',\n  33: 'PageUp',\n  34: 'PageDown',\n  35: 'End',\n  36: 'Home',\n  37: 'ArrowLeft',\n  38: 'ArrowUp',\n  39: 'ArrowRight',\n  40: 'ArrowDown',\n  45: 'Insert',\n  46: 'Delete',\n  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',\n  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',\n  144: 'NumLock',\n  145: 'ScrollLock',\n  224: 'Meta'\n};\n\n/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */\nfunction getEventKey(nativeEvent) {\n  if (nativeEvent.key) {\n    // Normalize inconsistent values reported by browsers due to\n    // implementations of a working draft specification.\n\n    // FireFox implements `key` but returns `MozPrintableKey` for all\n    // printable characters (normalized to `Unidentified`), ignore it.\n    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n    if (key !== 'Unidentified') {\n      return key;\n    }\n  }\n\n  // Browser does not implement `key`, polyfill as much of it as we can.\n  if (nativeEvent.type === 'keypress') {\n    var charCode = getEventCharCode(nativeEvent);\n\n    // The enter-key is technically both printable and non-printable and can\n    // thus be captured by `keypress`, no other non-printable key should.\n    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);\n  }\n  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {\n    // While user keyboard layout determines the actual meaning of each\n    // `keyCode` value, almost all function keys have a universal value.\n    return translateToKey[nativeEvent.keyCode] || 'Unidentified';\n  }\n  return '';\n}\n\nmodule.exports = getEventKey;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getEventKey.js\n ** module id = 190\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getEventKey.js?")},/*!**************************************************!*\
  !*** ./~/react/lib/getNodeForCharacterOffset.js ***!
  \**************************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getNodeForCharacterOffset\n */\n\n'use strict';\n\n/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */\nfunction getLeafNode(node) {\n  while (node && node.firstChild) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */\nfunction getSiblingNode(node) {\n  while (node) {\n    if (node.nextSibling) {\n      return node.nextSibling;\n    }\n    node = node.parentNode;\n  }\n}\n\n/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */\nfunction getNodeForCharacterOffset(root, offset) {\n  var node = getLeafNode(root);\n  var nodeStart = 0;\n  var nodeEnd = 0;\n\n  while (node) {\n    if (node.nodeType === 3) {\n      nodeEnd = nodeStart + node.textContent.length;\n\n      if (nodeStart <= offset && nodeEnd >= offset) {\n        return {\n          node: node,\n          offset: offset - nodeStart\n        };\n      }\n\n      nodeStart = nodeEnd;\n    }\n\n    node = getLeafNode(getSiblingNode(node));\n  }\n}\n\nmodule.exports = getNodeForCharacterOffset;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getNodeForCharacterOffset.js\n ** module id = 191\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getNodeForCharacterOffset.js?")},/*!*******************************************************!*\
  !*** ./~/react/lib/getReactRootElementInContainer.js ***!
  \*******************************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getReactRootElementInContainer\n */\n\n'use strict';\n\nvar DOC_NODE_TYPE = 9;\n\n/**\n * @param {DOMElement|DOMDocument} container DOM element that may contain\n *                                           a React component\n * @return {?*} DOM element that may have the reactRoot ID, or null.\n */\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOC_NODE_TYPE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nmodule.exports = getReactRootElementInContainer;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getReactRootElementInContainer.js\n ** module id = 192\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getReactRootElementInContainer.js?")},/*!***************************************************!*\
  !*** ./~/react/lib/getUnboundedScrollPosition.js ***!
  \***************************************************/
function(module,exports){eval('/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getUnboundedScrollPosition\n * @typechecks\n */\n\n"use strict";\n\n/**\n * Gets the scroll position of the supplied element or window.\n *\n * The return values are unbounded, unlike `getScrollPosition`. This means they\n * may be negative or exceed the element boundaries (which is possible using\n * inertial scrolling).\n *\n * @param {DOMWindow|DOMElement} scrollable\n * @return {object} Map with `x` and `y` keys.\n */\nfunction getUnboundedScrollPosition(scrollable) {\n  if (scrollable === window) {\n    return {\n      x: window.pageXOffset || document.documentElement.scrollLeft,\n      y: window.pageYOffset || document.documentElement.scrollTop\n    };\n  }\n  return {\n    x: scrollable.scrollLeft,\n    y: scrollable.scrollTop\n  };\n}\n\nmodule.exports = getUnboundedScrollPosition;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getUnboundedScrollPosition.js\n ** module id = 193\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getUnboundedScrollPosition.js?')},/*!**********************************!*\
  !*** ./~/react/lib/hyphenate.js ***!
  \**********************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule hyphenate\n * @typechecks\n */\n\nvar _uppercasePattern = /([A-Z])/g;\n\n/**\n * Hyphenates a camelcased string, for example:\n *\n *   > hyphenate('backgroundColor')\n *   < \"background-color\"\n *\n * For CSS style names, use `hyphenateStyleName` instead which works properly\n * with all vendor prefixes, including `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenate(string) {\n  return string.replace(_uppercasePattern, '-$1').toLowerCase();\n}\n\nmodule.exports = hyphenate;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/hyphenate.js\n ** module id = 194\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/hyphenate.js?")},/*!*******************************************!*\
  !*** ./~/react/lib/hyphenateStyleName.js ***!
  \*******************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule hyphenateStyleName\n * @typechecks\n */\n\n\"use strict\";\n\nvar hyphenate = __webpack_require__(/*! ./hyphenate */ 194);\n\nvar msPattern = /^ms-/;\n\n/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenateStyleName(string) {\n  return hyphenate(string).replace(msPattern, '-ms-');\n}\n\nmodule.exports = hyphenateStyleName;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/hyphenateStyleName.js\n ** module id = 195\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/hyphenateStyleName.js?")},/*!***********************************!*\
  !*** ./~/react/lib/isTextNode.js ***!
  \***********************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isTextNode\n * @typechecks\n */\n\nvar isNode = __webpack_require__(/*! ./isNode */ 94);\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM text node.\n */\nfunction isTextNode(object) {\n  return isNode(object) && object.nodeType == 3;\n}\n\nmodule.exports = isTextNode;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/isTextNode.js\n ** module id = 196\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/isTextNode.js?")},/*!************************************!*\
  !*** ./~/react/lib/joinClasses.js ***!
  \************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule joinClasses\n * @typechecks static-only\n */\n\n'use strict';\n\n/**\n * Combines multiple className strings into one.\n * http://jsperf.com/joinclasses-args-vs-array\n *\n * @param {...?string} classes\n * @return {string}\n */\nfunction joinClasses(className/*, ... */) {\n  if (!className) {\n    className = '';\n  }\n  var nextClass;\n  var argLength = arguments.length;\n  if (argLength > 1) {\n    for (var ii = 1; ii < argLength; ii++) {\n      nextClass = arguments[ii];\n      if (nextClass) {\n        className = (className ? className + ' ' : '') + nextClass;\n      }\n    }\n  }\n  return className;\n}\n\nmodule.exports = joinClasses;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/joinClasses.js\n ** module id = 197\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/joinClasses.js?")},/*!**********************************!*\
  !*** ./~/react/lib/mapObject.js ***!
  \**********************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule mapObject\n */\n\n'use strict';\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Executes the provided `callback` once for each enumerable own property in the\n * object and constructs a new object from the results. The `callback` is\n * invoked with three arguments:\n *\n *  - the property value\n *  - the property name\n *  - the object being traversed\n *\n * Properties that are added after the call to `mapObject` will not be visited\n * by `callback`. If the values of existing properties are changed, the value\n * passed to `callback` will be the value at the time `mapObject` visits them.\n * Properties that are deleted before being visited are not visited.\n *\n * @grep function objectMap()\n * @grep function objMap()\n *\n * @param {?object} object\n * @param {function} callback\n * @param {*} context\n * @return {?object}\n */\nfunction mapObject(object, callback, context) {\n  if (!object) {\n    return null;\n  }\n  var result = {};\n  for (var name in object) {\n    if (hasOwnProperty.call(object, name)) {\n      result[name] = callback.call(context, object[name], name, object);\n    }\n  }\n  return result;\n}\n\nmodule.exports = mapObject;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/mapObject.js\n ** module id = 198\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/mapObject.js?")},/*!******************************************!*\
  !*** ./~/react/lib/memoizeStringOnly.js ***!
  \******************************************/
function(module,exports){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule memoizeStringOnly\n * @typechecks static-only\n */\n\n'use strict';\n\n/**\n * Memoizes the return value of a function that accepts one string argument.\n *\n * @param {function} callback\n * @return {function}\n */\nfunction memoizeStringOnly(callback) {\n  var cache = {};\n  return function(string) {\n    if (!cache.hasOwnProperty(string)) {\n      cache[string] = callback.call(this, string);\n    }\n    return cache[string];\n  };\n}\n\nmodule.exports = memoizeStringOnly;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/memoizeStringOnly.js\n ** module id = 199\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/memoizeStringOnly.js?")},/*!******************************************************!*\
  !*** ./~/react/lib/quoteAttributeValueForBrowser.js ***!
  \******************************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule quoteAttributeValueForBrowser\n */\n\n'use strict';\n\nvar escapeTextContentForBrowser = __webpack_require__(/*! ./escapeTextContentForBrowser */ 43);\n\n/**\n * Escapes attribute value to prevent scripting attacks.\n *\n * @param {*} value Value to escape.\n * @return {string} An escaped string.\n */\nfunction quoteAttributeValueForBrowser(value) {\n  return '\"' + escapeTextContentForBrowser(value) + '\"';\n}\n\nmodule.exports = quoteAttributeValueForBrowser;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/quoteAttributeValueForBrowser.js\n ** module id = 200\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/quoteAttributeValueForBrowser.js?")},/*!***************************************!*\
  !*** ./~/react/lib/setTextContent.js ***!
  \***************************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule setTextContent\n */\n\n'use strict';\n\nvar ExecutionEnvironment = __webpack_require__(/*! ./ExecutionEnvironment */ 6);\nvar escapeTextContentForBrowser = __webpack_require__(/*! ./escapeTextContentForBrowser */ 43);\nvar setInnerHTML = __webpack_require__(/*! ./setInnerHTML */ 64);\n\n/**\n * Set the textContent property of a node, ensuring that whitespace is preserved\n * even in IE8. innerText is a poor substitute for textContent and, among many\n * issues, inserts <br> instead of the literal newline chars. innerHTML behaves\n * as it should.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */\nvar setTextContent = function(node, text) {\n  node.textContent = text;\n};\n\nif (ExecutionEnvironment.canUseDOM) {\n  if (!('textContent' in document.documentElement)) {\n    setTextContent = function(node, text) {\n      setInnerHTML(node, escapeTextContentForBrowser(text));\n    };\n  }\n}\n\nmodule.exports = setTextContent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/setTextContent.js\n ** module id = 201\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/setTextContent.js?")},/*!********************************!*\
  !*** ./~/react/lib/toArray.js ***!
  \********************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule toArray\n * @typechecks\n */\n\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\n\n/**\n * Convert array-like objects to arrays.\n *\n * This API assumes the caller knows the contents of the data type. For less\n * well defined inputs use createArrayFromMixed.\n *\n * @param {object|function|filelist} obj\n * @return {array}\n */\nfunction toArray(obj) {\n  var length = obj.length;\n\n  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in\n  // old versions of Safari).\n  (false ? invariant(\n    !Array.isArray(obj) &&\n    (typeof obj === 'object' || typeof obj === 'function'),\n    'toArray: Array-like object expected'\n  ) : invariant(!Array.isArray(obj) &&\n  (typeof obj === 'object' || typeof obj === 'function')));\n\n  (false ? invariant(\n    typeof length === 'number',\n    'toArray: Object needs a length property'\n  ) : invariant(typeof length === 'number'));\n\n  (false ? invariant(\n    length === 0 ||\n    (length - 1) in obj,\n    'toArray: Object should have keys for indices'\n  ) : invariant(length === 0 ||\n  (length - 1) in obj));\n\n  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs\n  // without method will throw during the slice call and skip straight to the\n  // fallback.\n  if (obj.hasOwnProperty) {\n    try {\n      return Array.prototype.slice.call(obj);\n    } catch (e) {\n      // IE < 9 does not support Array#slice on collections objects\n    }\n  }\n\n  // Fall back to copying key by key. This assumes all keys have a value,\n  // so will not preserve sparsely populated inputs.\n  var ret = Array(length);\n  for (var ii = 0; ii < length; ii++) {\n    ret[ii] = obj[ii];\n  }\n  return ret;\n}\n\nmodule.exports = toArray;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/toArray.js\n ** module id = 202\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/toArray.js?")},/*!*******************************!*\
  !*** ./~/react/lib/update.js ***!
  \*******************************/
function(module,exports,__webpack_require__){eval("/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule update\n */\n\n /* global hasOwnProperty:true */\n\n'use strict';\n\nvar assign = __webpack_require__(/*! ./Object.assign */ 2);\nvar keyOf = __webpack_require__(/*! ./keyOf */ 11);\nvar invariant = __webpack_require__(/*! ./invariant */ 1);\nvar hasOwnProperty = {}.hasOwnProperty;\n\nfunction shallowCopy(x) {\n  if (Array.isArray(x)) {\n    return x.concat();\n  } else if (x && typeof x === 'object') {\n    return assign(new x.constructor(), x);\n  } else {\n    return x;\n  }\n}\n\nvar COMMAND_PUSH = keyOf({$push: null});\nvar COMMAND_UNSHIFT = keyOf({$unshift: null});\nvar COMMAND_SPLICE = keyOf({$splice: null});\nvar COMMAND_SET = keyOf({$set: null});\nvar COMMAND_MERGE = keyOf({$merge: null});\nvar COMMAND_APPLY = keyOf({$apply: null});\n\nvar ALL_COMMANDS_LIST = [\n  COMMAND_PUSH,\n  COMMAND_UNSHIFT,\n  COMMAND_SPLICE,\n  COMMAND_SET,\n  COMMAND_MERGE,\n  COMMAND_APPLY\n];\n\nvar ALL_COMMANDS_SET = {};\n\nALL_COMMANDS_LIST.forEach(function(command) {\n  ALL_COMMANDS_SET[command] = true;\n});\n\nfunction invariantArrayCase(value, spec, command) {\n  (false ? invariant(\n    Array.isArray(value),\n    'update(): expected target of %s to be an array; got %s.',\n    command,\n    value\n  ) : invariant(Array.isArray(value)));\n  var specValue = spec[command];\n  (false ? invariant(\n    Array.isArray(specValue),\n    'update(): expected spec of %s to be an array; got %s. ' +\n    'Did you forget to wrap your parameter in an array?',\n    command,\n    specValue\n  ) : invariant(Array.isArray(specValue)));\n}\n\nfunction update(value, spec) {\n  (false ? invariant(\n    typeof spec === 'object',\n    'update(): You provided a key path to update() that did not contain one ' +\n    'of %s. Did you forget to include {%s: ...}?',\n    ALL_COMMANDS_LIST.join(', '),\n    COMMAND_SET\n  ) : invariant(typeof spec === 'object'));\n\n  if (hasOwnProperty.call(spec, COMMAND_SET)) {\n    (false ? invariant(\n      Object.keys(spec).length === 1,\n      'Cannot have more than one key in an object with %s',\n      COMMAND_SET\n    ) : invariant(Object.keys(spec).length === 1));\n\n    return spec[COMMAND_SET];\n  }\n\n  var nextValue = shallowCopy(value);\n\n  if (hasOwnProperty.call(spec, COMMAND_MERGE)) {\n    var mergeObj = spec[COMMAND_MERGE];\n    (false ? invariant(\n      mergeObj && typeof mergeObj === 'object',\n      'update(): %s expects a spec of type \\'object\\'; got %s',\n      COMMAND_MERGE,\n      mergeObj\n    ) : invariant(mergeObj && typeof mergeObj === 'object'));\n    (false ? invariant(\n      nextValue && typeof nextValue === 'object',\n      'update(): %s expects a target of type \\'object\\'; got %s',\n      COMMAND_MERGE,\n      nextValue\n    ) : invariant(nextValue && typeof nextValue === 'object'));\n    assign(nextValue, spec[COMMAND_MERGE]);\n  }\n\n  if (hasOwnProperty.call(spec, COMMAND_PUSH)) {\n    invariantArrayCase(value, spec, COMMAND_PUSH);\n    spec[COMMAND_PUSH].forEach(function(item) {\n      nextValue.push(item);\n    });\n  }\n\n  if (hasOwnProperty.call(spec, COMMAND_UNSHIFT)) {\n    invariantArrayCase(value, spec, COMMAND_UNSHIFT);\n    spec[COMMAND_UNSHIFT].forEach(function(item) {\n      nextValue.unshift(item);\n    });\n  }\n\n  if (hasOwnProperty.call(spec, COMMAND_SPLICE)) {\n    (false ? invariant(\n      Array.isArray(value),\n      'Expected %s target to be an array; got %s',\n      COMMAND_SPLICE,\n      value\n    ) : invariant(Array.isArray(value)));\n    (false ? invariant(\n      Array.isArray(spec[COMMAND_SPLICE]),\n      'update(): expected spec of %s to be an array of arrays; got %s. ' +\n      'Did you forget to wrap your parameters in an array?',\n      COMMAND_SPLICE,\n      spec[COMMAND_SPLICE]\n    ) : invariant(Array.isArray(spec[COMMAND_SPLICE])));\n    spec[COMMAND_SPLICE].forEach(function(args) {\n      (false ? invariant(\n        Array.isArray(args),\n        'update(): expected spec of %s to be an array of arrays; got %s. ' +\n        'Did you forget to wrap your parameters in an array?',\n        COMMAND_SPLICE,\n        spec[COMMAND_SPLICE]\n      ) : invariant(Array.isArray(args)));\n      nextValue.splice.apply(nextValue, args);\n    });\n  }\n\n  if (hasOwnProperty.call(spec, COMMAND_APPLY)) {\n    (false ? invariant(\n      typeof spec[COMMAND_APPLY] === 'function',\n      'update(): expected spec of %s to be a function; got %s.',\n      COMMAND_APPLY,\n      spec[COMMAND_APPLY]\n    ) : invariant(typeof spec[COMMAND_APPLY] === 'function'));\n    nextValue = spec[COMMAND_APPLY](nextValue);\n  }\n\n  for (var k in spec) {\n    if (!(ALL_COMMANDS_SET.hasOwnProperty(k) && ALL_COMMANDS_SET[k])) {\n      nextValue[k] = update(value[k], spec[k]);\n    }\n  }\n\n  return nextValue;\n}\n\nmodule.exports = update;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/update.js\n ** module id = 203\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/update.js?")}]);